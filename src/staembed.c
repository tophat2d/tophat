const char *th_em_modulesrc[] = {
"// Module for frame based image animation.\n"
"// TODO: Rework this module to use atlases.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"image.um\"\n"
"\t\"rect.um\"\n"
")\n"
"\n"
"// Anim is able to animate an array of images. As opposed to ent.Ent.animate,\n"
"// it starts from the first frame.\n"
"type Anim* = struct {\n"
"\tanim: []image.Image\n"
"\trot: th.fu\n"
"\tscale: th.fu\n"
"\tfps: th.uu\n"
"\tlooping: bool\n"
"\n"
"\tpos: th.Vf2\n"
"\n"
"\tzeroTime: int\n"
"\n"
"\tframe: int\n"
"}\n"
"\n"
"// Anim\'s constructor.\n"
"fn mk*(pos: th.Vf2, anm: []image.Image, fps: th.uu): Anim {\n"
"\ta := Anim{}\n"
"\n"
"\ta.anim = append(anm, anm[len(anm)-1])\n"
"\n"
"\ta.fps = fps\n"
"\ta.scale = 1\n"
"\ta.rot = 0\n"
"\n"
"\ta.pos = pos\n"
"\n"
"\ta.looping = false\n"
"\n"
"\treturn a\n"
"}\n"
"\n"
"// Starts animation with start_time of t.\n"
"fn (a: ^Anim) start*(t: int) {\n"
"\ta.zeroTime = t\n"
"}\n"
"\n"
"// This draws the animation. Returns true, if the animation ended.\n"
"fn (a: ^Anim) handle*(t: uint, cam: rect.Rect): bool {\n"
"\ta.frame = (round(real(t-a.zeroTime)/round((1000.0/a.fps))) % len(a.anim))\n"
"\n"
"\ta.anim[a.frame].draw(\n"
"\t\tth.Transform{\n"
"\t\t\tth.Vf2{round(a.pos.x) - cam.x + cam.w/2, round(a.pos.y) - cam.y + cam.h/2},\n"
"\t\t\tth.Vf2{a.scale, a.scale}, th.Vf2{}, a.rot})\n"
"\n"
"\tif a.frame == len(a.anim) - 1 {\n"
"\t\tif a.looping {\n"
"\t\t\ta.zeroTime = t\n"
"\t\t} else {\n"
"\t\t\treturn true\n"
"\t\t}\n"
"\t}\n"
"\n"
"\treturn false\n"
"}\n"
"",
"// Module for audio loading and playback.\n"
"\n"
"// Represents an instance of a playable sound. It is an opaque structure.\n"
"type Sound* = struct { _: ^struct{} }\n"
"\n"
"var pool: []^Sound\n"
"\n"
"fn umth_sound_load(path: str): ^struct{}\n"
"// Loads a sounds at path, if there is an error, the underlying pointer\n"
"// will be `NULL` and `validate` will return false.\n"
"fn load*(path: str): Sound {\n"
"\treturn Sound{umth_sound_load(path)}\n"
"}\n"
"\n"
"fn umth_sound_copy(s: Sound): ^struct{}\n"
"// Copies the sound. This will create another sound which can be configured\n"
"// and played independently from the original sound.\n"
"fn (s: ^Sound) copy*(): Sound {\n"
"\treturn Sound{umth_sound_copy(s^)}\n"
"}\n"
"\n"
"// Returns `true` if `s` loaded correctly.\n"
"fn (s: ^Sound) validate*(): bool {\n"
"\treturn s._ != null\n"
"}\n"
"\n"
"fn umth_sound_is_playing(s: Sound): bool\n"
"// Returns true if the sound is still playing.\n"
"fn (s: ^Sound) isPlaying*(): bool {\n"
"\treturn umth_sound_is_playing(s^)\n"
"}\n"
"\n"
"fn umth_sound_play(s: Sound)\n"
"// Plays the sound.\n"
"fn (s: ^Sound) play*() {\n"
"\tumth_sound_play(s^)\n"
"}\n"
"\n"
"// The start function allows you to play a single sound multiple times.\n"
"// It will create a copy and return a pointer to it, so you can controll it\n"
"// while it is playing. The returned pointer can be discarded.\n"
"fn (s: ^Sound) start*(): ^Sound {\n"
"\tcpy := new(Sound)\n"
"\tcpy ^= s.copy()\n"
"\tcpy.play()\n"
"\n"
"\tpool = append(pool, cpy)\n"
"\n"
"\treturn cpy\n"
"}\n"
"\n"
"fn umth_sound_stop(s: Sound)\n"
"// Stops the sound, but keeps the progress. If you want to start from the\n"
"// begginning, use `audio.Sound.seekToFrame(0)`.\n"
"fn (s: ^Sound) stop*() {\n"
"\tumth_sound_stop(s^)\n"
"}\n"
"\n"
"fn umth_sound_set_volume(s: Sound, vol: real32)\n"
"// Sets the volume as a multiplier of the base volume.\n"
"fn (s: ^Sound) setVol*(vol: real32) {\n"
"\tumth_sound_set_volume(s^, vol)\n"
"}\n"
"\n"
"fn umth_sound_set_pan(s: Sound, pan: real32)\n"
"// Sets the pan of the sound.\n"
"fn (s: ^Sound) setPan*(pan: real32) {\n"
"\tumth_sound_set_pan(s^, pan)\n"
"}\n"
"\n"
"fn umth_sound_set_pitch(s: Sound, pitch: real32)\n"
"// Sets the pitch of the sound.\n"
"fn (s: ^Sound) setPitch*(pitch: real32) {\n"
"\tumth_sound_set_pitch(s^, pitch)\n"
"}\n"
"\n"
"fn umth_sound_set_looping(s: Sound, looping: bool)\n"
"// Sets whether the sound will loop upon finishing.\n"
"fn (s: ^Sound) setLooping*(looping: bool) {\n"
"\tumth_sound_set_looping(s^, looping)\n"
"}\n"
"\n"
"fn umth_sound_seek_to_frame(s: Sound, frame: uint)\n"
"// Seeks to a specified PCM frame.\n"
"fn (s: ^Sound) seekToFrame*(frame: uint) {\n"
"\tumth_sound_seek_to_frame(s^, frame)\n"
"}\n"
"\n"
"fn umth_sound_frame_count(s: Sound): uint\n"
"// Returns length of the sound in PCM frames.\n"
"fn (s: ^Sound) frameCount*(): uint {\n"
"\treturn umth_sound_frame_count(s^)\n"
"}\n"
"\n"
"fn umth_sound_set_start_time_ms(s: Sound, t: uint)\n"
"fn (s: ^Sound) setStartTimeMs*(t: uint) {\n"
"\tumth_sound_set_start_time_ms(s^, t)\n"
"}\n"
"\n"
"fn umth_sound_set_stop_time_ms(s: Sound, t: uint)\n"
"fn (s: ^Sound) setStopTimeMs*(t: uint) {\n"
"\tumth_sound_set_stop_time_ms(s^, t)\n"
"}\n"
"\n"
"// **INTERNAL**\n"
"fn __setup*() {\n"
"\tpool = []^Sound{}\n"
"}\n"
"\n"
"// **INTERNAL**\n"
"fn __cycle*() {\n"
"\tfor i:=0; i >= 0 && i < len(pool); i++ {\n"
"\t\tif !pool[i].isPlaying() {\n"
"\t\t\tpool = delete(pool, i)\n"
"\t\t\ti--\n"
"\t\t}\n"
"\t}\n"
"}\n"
"",
"\n"
"// Parses input into a 2d string array.\n"
"fn parse*(inp: str): [][]str {\n"
"\tlength := len(inp)\n"
"\toutLen := 0\n"
"\tout := [][]str{}\n"
"\trow := []str{}\n"
"\tstart := 0\n"
"\n"
"\tfor i := 0; i < length; i++ {\n"
"\t\tif inp[i] == \'\\n\' {\n"
"\t\t\trow = append(row, slice(inp, start, i))\n"
"\n"
"\t\t\tif outLen % 64 == 0 {\n"
"\t\t\t\tvar more: [64][]str\n"
"\t\t\t\tout = append(out, more)\n"
"\t\t\t}\n"
"\n"
"\t\t\tout[outLen] = row\n"
"\t\t\toutLen++\n"
"\n"
"\t\t\trow = []str{}\n"
"\t\t\tstart = i+1\n"
"\t\t} else if inp[i] == \',\' {\n"
"\t\t\trow = append(row, slice(inp, start, i))\n"
"\t\t\tstart = i+1\n"
"\t\t}\n"
"\t}\n"
"\n"
"\treturn slice(out, 0, outLen)\n"
"}\n"
"\n"
"// Converts 2d array to csv string.\n"
"fn encode*(inp: [][]str): str {\n"
"\tstrLen := 1\n"
"\tfor i in inp {\n"
"\t\tfor j in inp[i] {\n"
"\t\t\tstrLen += len(inp[i][j])\n"
"\t\t\tstrLen += 1 // Comma, Newline\n"
"\t\t}\n"
"\t}\n"
"\n"
"\tout := make([]char, strLen)\n"
"\toutI := 0\n"
"\n"
"\tfor i:=0; i < len(inp); i++ {\n"
"\t\tfor j:=0; j < len(inp[i]); j++ {\n"
"\t\t\tfor _, c in inp[i][j] {\n"
"\t\t\t\tout[outI] = c\n"
"\t\t\t\toutI++\n"
"\t\t\t}\n"
"\t\t\tif j < len(inp[i])-1 { out[outI] = \',\'; outI++ }\n"
"\t\t}\n"
"\t\tout[outI] = \'\\n\'\n"
"\t\toutI += 1\n"
"\t}\n"
"\treturn out\n"
"}\n"
"\n"
"",
"\n"
"import (\n"
"\t\"rect.um\"\n"
"\t\"image.um\"\n"
"\t\"th.um\"\n"
")\n"
"\n"
"// Entity is the main game object. It features drawing and collisions.\n"
"// Every entity has an image used for drawing and a rectangle used\n"
"// for collisions. It also has a transform used for transforming it\'s image\n"
"// and rectangle.\n"
"type Ent* = struct {\n"
"\t// used as a collider, used as backup when invalid image is supplied\n"
"\tr: rect.Rect\n"
"\t// used in drawing\n"
"\ti: image.Image\n"
"\t// used to transform and translate the image and rect\n"
"\tt: th.Transform\n"
"\t// used as a color of the rect and a color filter for the image\n"
"\tc: uint32\n"
"}\n"
"\n"
"// Value returned by get coll. It contains a position where the collision\n"
"// happened and the index of the entity involved in said collision.\n"
"type Coll* = struct {\n"
"\tindex: th.uu\n"
"\tpos: th.Vf2\n"
"}\n"
"\n"
"fn umth_ent_draw(e: ^Ent, c: ^rect.Rect)\n"
"// Draws the entity onto the screen in relaction to camera c.\n"
"fn (e: ^Ent) draw*(c: rect.Rect) {\n"
"\tumth_ent_draw(e, &c)\n"
"}\n"
"\n"
"// ent\'s constructor\n"
"fn mk*(img: image.Image = image.Image{}, t: th.Transform = th.Transform{ s: th.Vf2{1, 1} }): Ent {\n"
"\tvar e: Ent\n"
"\te.i = img\n"
"\te.t = t\n"
"\tif img.validate() {\n"
"\t\tdm := img.getDims()\n"
"\t\te.r.w = dm.x\n"
"\t\te.r.h = dm.y\n"
"\t}\n"
"\te.c = th.white\n"
"\n"
"\tif t.s.x == 0 && t.s.y == 0 {\n"
"\t\tt.s = th.Vf2{ 1, 1 }\n"
"\t}\n"
"\n"
"\treturn e\n"
"}\n"
"\n"
"fn umth_ent_getcoll(coll: ^Coll, collC: ^int, maxCount: th.uu, count: int32,\n"
"\te: ^Ent, s: ^^Ent)\n"
"// Checks collisions of e with entities in s. Checks at max maxColl collisions.\n"
"// If s contains e, the collision won\'t be returned.\n"
"fn (e: ^Ent) getColl*(s: []^Ent, maxColls: th.uu): []Coll {\n"
"\tif len(s) == 0 {\n"
"\t\treturn []Coll{}\n"
"\t}\n"
"\n"
"\tif maxColls > len(s) {\n"
"\t\tmaxColls = len(s)\n"
"\t}\n"
"\n"
"\tif maxColls == 0 {\n"
"\t\tmaxColls = 1\n"
"\t}\n"
"\n"
"\tcolls := make([]Coll, maxColls)\n"
"\tcount := 0\n"
"\tumth_ent_getcoll(&colls[0], &count, maxColls, len(s), e, &s[0])\n"
"\n"
"\treturn slice(colls, 0, count)\n"
"}\n"
"\n"
"// Animates the entity\'s image with one of the `anim` array. <b>Won\'t</b> begin on\n"
"// the first frame. If you want that, use anim.Anim.\n"
"fn (e: ^Ent) animate*(fps: int, frames: ^[]image.Image, t: int) {\n"
"\te.i = frames^[(round(real(t)/(1000/fps)) % len(frames^))]\n"
"}\n"
"\n"
"fn umth_ent_ysort(e: ^Ent, count: int)\n"
"// Performs an y sort on entities.\n"
"fn ysort*(ents: ^[]Ent) {\n"
"\tif len(ents^) > 0 {\n"
"\t\tumth_ent_ysort(&ents[0], len(ents^))\n"
"\t}\n"
"}\n"
"",
"import (\n"
"\t\"rect.um\"\n"
"\t\"th.um\"\n"
")\n"
"\n"
"// Represents a drawable image. It is an opaque structure.\n"
"// Images support a color filter. It is applied by multiplying the color\n"
"// of each pixel with the filter.\n"
"type Image* = struct{ _: ^struct{} }\n"
"\n"
"\n"
"fn umth_image_load(ret: ^Image, path: str)\n"
"// Loads an image at path.\n"
"fn load*(path: str): Image {\n"
"\timg := Image{}\n"
"\tumth_image_load(&img, path)\n"
"\treturn img\n"
"}\n"
"\n"
"fn umth_image_flipv(i: Image, f: bool)\n"
"// Flips image on it\'s vertical axis.\n"
"fn (i: ^Image) flipv*(flip: bool) {\n"
"\tumth_image_flipv(i^, flip)\n"
"}\n"
"\n"
"fn umth_image_fliph(i: Image, f: bool)\n"
"// Flips image on it\'s horizontal axis.\n"
"fn (i: ^Image) fliph*(flip: bool) {\n"
"\tumth_image_fliph(i^, flip)\n"
"}\n"
"\n"
"fn umth_image_draw(img: Image, t: ^th.Transform, color: uint32)\n"
"// Draws the image in screen coordinates. It transforms it with t and\n"
"// applies color as a color filter.\n"
"fn (i: ^Image) draw*(t: th.Transform, color: uint32 = th.white) {\n"
"\tumth_image_draw(i^, &t, color)\n"
"}\n"
"\n"
"fn umth_image_draw_nine_patch(img: Image, outer, inner, dest: ^rect.Rect,\n"
"\tcolor: uint32)\n"
"// Draws \"nine-patch\" image. \n"
"// `outer` specifies the texture coordinates of the outer rect of source image,\n"
"// `inner` specifies coordinates of inner rect of source image, positioned relative to `outer`.\n"
"// You can tint with `color`.\n"
"fn (i: ^Image) drawNinepatch*(outer, inner, dest: rect.Rect, color: uint32 = th.white) {\n"
"\tumth_image_draw_nine_patch(i^, &outer, &inner, &dest, color)\n"
"}\n"
"\n"
"fn umth_image_draw_on_quad(img: Image, color: uint32, q: th.Quad)\n"
"// Draws the image on top of a quad with corners of the image positioned\n"
"// on the verticies of the quad.\n"
"fn (i: ^Image) drawOnQuad*(q: th.Quad, color: uint32 = th.white) {\n"
"\tumth_image_draw_on_quad(i^, color, q)\n"
"}\n"
"\n"
"// Returns true, if i\'s handle points to an image.\n"
"fn (i: ^Image) validate*(): bool {\n"
"\treturn i._ != null\n"
"}\n"
"\n"
"fn umth_image_get_dims(dm: ^th.Vf2, i: Image)\n"
"// Returns width and heigth.\n"
"fn (i: ^Image) getDims*(): th.Vf2 {\n"
"\tout := th.Vf2{}\n"
"\tumth_image_get_dims(&out, i^)\n"
"\n"
"\treturn out\n"
"}\n"
"\n"
"fn umth_image_crop(img: Image, tl, br: th.Vf2)\n"
"// Crops an image. Coordinates are between 0, 0 (top left) and\n"
"// 1, 1 (bottom right)\n"
"fn (i: ^Image) crop*(tl, br: th.Vf2) {\n"
"\tumth_image_crop(i^, tl, br)\n"
"}\n"
"\n"
"fn umth_image_crop_quad(img: Image, q: ^th.Quad)\n"
"// Crop an image using a quad.\n"
"fn (i: ^Image) cropQuad*(q: th.Quad) {\n"
"\tumth_image_crop_quad(i^, &q)\n"
"}\n"
"\n"
"fn umth_image_get_crop_quad(img: Image, q: ^th.Quad)\n"
"// Crop an image using a quad.\n"
"fn (i: ^Image) getCropQuad*(): th.Quad {\n"
"\tvar (q: th.Quad)\n"
"\tumth_image_get_crop_quad(i^, &q)\n"
"\treturn q\n"
"}\n"
"\n"
"fn umth_image_from_data(ret: ^Image, data: ^uint32, dm: th.Vf2)\n"
"// Creates an image from raw data.\n"
"fn mk*(data: []uint32, dm: th.Vf2): Image {\n"
"\timg := Image{}\n"
"\tumth_image_from_data(&img, &data[0], dm)\n"
"\n"
"\treturn img\n"
"}\n"
"\n"
"fn umth_image_copy(ret: ^Image, data: Image)\n"
"// Copies image into a new one.\n"
"fn (i: ^Image) copy*(): Image {\n"
"\timg := Image{}\n"
"\tumth_image_copy(&img, i^)\n"
"\t\n"
"\treturn img\n"
"}\n"
"\n"
"fn umth_image_set_filter(data: Image, filter: int)\n"
"// Sets a mag/min filter. 0 is linear, others are nearest.\n"
"// This function will regenerate the texture. This means it shouldn\'t be\n"
"// used in a loop.\n"
"// https://learnopengl.com/img/getting-started/texture_filtering.png\n"
"// left is nearest, right is linear.\n"
"fn (i: ^Image) setfilter*(filter: int) {\n"
"\tumth_image_set_filter(i^, filter)\n"
"}\n"
"\n"
"fn umth_image_update_data(img: Image, data: ^uint32, dm: th.Vf2)\n"
"// Updates the image data. dm are the dimensions of the new image.\n"
"// The new image doesn\'t have to be the same size as the old one.\n"
"fn (i: ^Image) setData*(data: []uint32, dm: th.Vf2) {\n"
"\tif dm.x * dm.y != len(data) {\n"
"\t\terror(\"setData: incorrect dimensions: \" + repr(dm.x * dm.y) + \"!= \" + repr(len(data)))\n"
"\t}\n"
"\n"
"\tif len(data) == 0 {\n"
"\t\terror(\"setData: can\'t set empty image\")\n"
"\t}\n"
"\n"
"\tumth_image_update_data(i^, &data[0], dm)\n"
"}\n"
"\n"
"fn umth_image_get_data(img: Image, data: ^uint32)\n"
"// Gets the image data. This downloads the data from the GPU on **each call**.\n"
"// Don\'t use in performance critical sections.\n"
"fn (i: ^Image) getData*(): []uint32 {\n"
"\tif i._ == null {\n"
"\t\treturn []uint32{}\n"
"\t}\n"
"\n"
"\tbuf := make([]uint32, trunc(i.getDims().x * i.getDims().y))\n"
"\tif len(buf) == 0 {\n"
"\t\treturn buf\n"
"\t}\n"
"\n"
"\tumth_image_get_data(i^, &buf[0])\n"
"\n"
"\treturn buf\n"
"}\n"
"\n"
"fn umth_image_make_render_target(img: Image)\n"
"// Sets the image a the render target. This means stuff won\'t be drawn onto the\n"
"// screen, but into the image. In this mode, the scaling is always 1. An the\n"
"// resolution of the screen are the image\'s dimensions.\n"
"fn (i: ^Image) makeRenderTarget*() {\n"
"\tumth_image_make_render_target(i^)\n"
"}\n"
"\n"
"fn umth_image_remove_render_target(img: Image, wp: th.Vf2)\n"
"// Returns to rendering onto the screen.\n"
"// `wp`\n"
"// : viewport to be set\n"
"fn (i: ^Image) removeRenderTarget*(wp: th.Vf2) {\n"
"\tumth_image_remove_render_target(i^, wp)\n"
"}\n"
"",
"// Module for getting keyboard and mouse input.\n"
"// Keycodes are ascii chars (lower case) and the constants below.\n"
"//   mouse1\n"
"//   mouse2\n"
"//   mouse3\n"
"//   key_shift\n"
"//   key_backspace\n"
"//   key_delete\n"
"//   key_left\n"
"//   key_right\n"
"//   key_up\n"
"//   key_down\n"
"//   key_escape\n"
"//   key_enter\n"
"// \n"
"// is* functions return info based on a us QWERTY layout. They are supposed to\n"
"// be used for game controls. For text input use getStr.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"rect.um\"\n"
")\n"
"\n"
"const (\n"
"\tmouse1* =        char(1)\n"
"\tmouse2* =        char(2)\n"
"\tmouse3* =        char(3)\n"
"\tmouse_up* =      char(4)\n"
"\tmouse_down* =    char(5)\n"
"\tkey_shift* =     char(16   + 0x7f)\n"
"\tkey_backspace* = char(8    + 0x7f)\n"
"\tkey_delete* =    char(46   + 0x7f)\n"
"\tkey_left* =      char(37   + 0x7f)\n"
"\tkey_right* =     char(39   + 0x7f)\n"
"\tkey_up* =        char(38   + 0x7f)\n"
"\tkey_down* =      char(40   + 0x7f)\n"
"\tkey_escape* =    char(27   + 0x7f)\n"
"\tkey_enter* =     char(13   + 0x7f)\t\n"
"\tkey_alt* =       char(0x12 + 0x7f)\n"
"\tkey_ctrl* =      char(0x11 + 0x7f)\n"
")\n"
"\n"
"fn umth_input_get_mouse(out: ^th.Vf2)\n"
"// Returns the position of mouse cursor in relation to the screen.\n"
"fn getMousePos*(): th.Vf2 {\n"
"\tout := th.Vf2{}\n"
"\tumth_input_get_mouse(&out)\n"
"\treturn out\n"
"}\n"
"\n"
"// Returns the position of mouse cursor in relation to cam.\n"
"fn getGlobalMousePos*(cam: rect.Rect): th.Vf2 {\n"
"\treturn cam.toWorld(getMousePos())\n"
"}\n"
"\n"
"fn umth_input_is_pressed(keycode: char): int32\n"
"// Returns true if key is pressed. Either use codes defined in the file above,\n"
"// or pass lower case char/number.\n"
"fn isPressed*(code: char): bool {\n"
"\tval := bool(umth_input_is_pressed(code))\n"
"\treturn val\n"
"}\n"
"\n"
"fn umth_input_is_just_pressed(key: char): int32\n"
"// Returns, whether code was just pressed this loop.\n"
"fn isJustPressed*(code: char): bool {\n"
"\treturn bool(umth_input_is_just_pressed(code))\n"
"}\n"
"\n"
"fn umth_input_is_just_released(key: char): int32\n"
"// Returns true if a key was just released.\n"
"fn isJustReleased*(code: char): bool {\n"
"\treturn bool(umth_input_is_just_released(code))\n"
"}\n"
"\n"
"fn umth_input_clear*(code: char)\n"
"// Clears both the pressed and justPressed state of a code.\n"
"fn clear*(code: char) {\n"
"\tumth_input_clear(code)\n"
"}\n"
"\n"
"fn umth_input_get_str(): str\n"
"// Returns a string entered by the user in the last cycle.\n"
"fn getStr*(): str {\n"
"\treturn umth_input_get_str()\n"
"}\n"
"",
"// Misc functions.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"std.um\"\t\t\t\t\t\t\t\n"
")\n"
"\n"
"// Reads file content into a string.\n"
"fn readall*(path: str): str {\n"
"\tf := std.fopen(path, \"r\")\n"
"\tconst blockSize = 16\n"
"\tres := \"\"\n"
"\n"
"\tfor ok := true; ok {\n"
"\t  var buff: [blockSize + 1]char\n"
"\t  ok = std.fread(f, ^[blockSize]char(&buff)) == 1\n"
"\t  res += str([]char(buff))\n"
"\t}\n"
"\n"
"\tstd.fclose(f)\n"
"\treturn res\n"
"}\n"
"\n"
"// Snaps a value to step.\n"
"fn stepify*(val, step: th.fu): th.fu {\n"
"\tif step != 0 {\n"
"\t\tval = floor(val / step + 0.5) * step\n"
"\t}\n"
"\treturn val\n"
"}\n"
"",
"// Canvas library allowing for drawing basic shapes. Coordinates are based on\n"
"// the screen.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"rect.um\"\n"
")\n"
"\n"
"fn umth_canvas_draw_text(text: str, pos: th.Vf2, color: uint32, size: th.fu)\n"
"// Draws a basic pixel text. Only ascii is supported.\n"
"fn drawText*(text: str, pos: th.Vf2, color: uint32, size: th.fu) {\n"
"\tumth_canvas_draw_text(text, pos, color, size)\n"
"}\n"
"\n"
"// Returns the size of text taken by an equivalent drawText call.\n"
"fn textSize*(text: str, scale: th.fu): th.Vf2 {\n"
"\tvar w, maxw, h: int\n"
"\tw = 0\n"
"\tmaxw = 0\n"
"\th = 1\n"
"\t\n"
"\tfor i in text {\n"
"\t\tif text[i] == \"\\n\" {\n"
"\t\t\th += 1\n"
"\t\t\tif w > maxw {\n"
"\t\t\t\tmaxw = w\n"
"\t\t\t}\n"
"\n"
"\t\t\tcontinue\n"
"\t\t}\n"
"\n"
"\t\tw++\n"
"\t}\n"
"\n"
"\tif w > maxw {\n"
"\t\tmaxw = w\n"
"\t}\n"
"\n"
"\treturn th.Vf2{maxw * scale * 6 - scale, h * 6 * scale}\n"
"}\n"
"\n"
"fn umth_canvas_draw_rect*(color: uint32, r: rect.Rect)\n"
"// Draws a Rectangle.\n"
"fn drawRect*(color: uint32, r: rect.Rect) {\n"
"\tumth_canvas_draw_rect(color, r)\n"
"}\n"
"\n"
"fn umth_canvas_draw_line*(color: uint32, b, e: th.Vf2, thickness: th.fu)\n"
"// Draws a line.\n"
"fn drawLine*(color: uint32, b, e: th.Vf2, thickness: th.fu) {\n"
"\tumth_canvas_draw_line(color, b, e, thickness)\n"
"}\n"
"",
"// This module will undergo changes.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"ent.um\"\n"
"\t\"rect.um\"\n"
"\t\"canvas.um\"\n"
"\t\"tilemap.um\"\n"
")\n"
"\n"
"// Ray type.\n"
"type Ray* = struct {\n"
"\tpos: th.Vf2\n"
"\tl: th.fu // length\n"
"\tr: th.fu // rotation\n"
"}\n"
"\n"
"// Makes a ray.\n"
"fn mk*(pos: th.Vf2, l: th.fu, r: th.fu = 0.0): Ray {\n"
"\treturn Ray{pos, l, r}\n"
"}\n"
"\n"
"fn umth_ray_getcoll(colls: ^ent.Coll, count: ^int, maxCount,\n"
"\tsceneLen: int, r: ^Ray, scene: ^^ent.Ent)\n"
"// Same as ent.getcoll. Same changes will apply.\n"
"fn (r: ^Ray) getColl*(s: []^ent.Ent, maxColls: th.uu): []ent.Coll {\n"
"\tif len(s) == 0 {\n"
"\t\treturn []ent.Coll{}\n"
"\t}\n"
"\n"
"\tif maxColls > len(s) {\n"
"\t\tmaxColls = len(s)\n"
"\t}\n"
"\n"
"\tcolls := make([]ent.Coll, maxColls)\n"
"\tcount := 0\n"
"\tumth_ray_getcoll(&colls[0], &count, maxColls, len(s), r, &s[0])\n"
"\treturn slice(colls, 0, count)\n"
"}\n"
"\n"
"fn umth_ray_get_tilemap_coll(r: ^Ray, t: ^tilemap.Tilemap, ic: ^th.Vf2): bool\n"
"// Gets ray\'s collision to a tilemap.\n"
"fn (r: ^Ray) getTilemapColl*(t: tilemap.Tilemap, ic: ^th.Vf2): bool {\n"
"\treturn umth_ray_get_tilemap_coll(r, &t, ic)\n"
"}\n"
"\n"
"fn (r: ^Ray) draw*(cam: rect.Rect, color: uint32, thickness: th.fu) {\n"
"\tp1 := cam.toScreen(r.pos)\n"
"\tp2 := cam.toScreen(r.pos.add(th.Vf2{0, r.l}.rotated(th.Vf2{}, r.r)))\n"
"\tcanvas.drawLine(color, p1, p2, thickness)\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\t\n"
")\n"
"\n"
"// A set of points representing a rectangle.\n"
"type Rect* = struct {\n"
"\tx, y, w, h: th.fu\n"
"}\n"
"\n"
"fn mk*(x, y, w, h: th.fu): Rect {\n"
"\tvar r: Rect\n"
"\n"
"\tr.x = x\n"
"\tr.y = y\n"
"\tr.w = w\n"
"\tr.h = h\n"
"\n"
"\treturn r\n"
"}\n"
"\n"
"// translates screen coordinates to world coordinates with cam r\n"
"fn (r: ^Rect) toWorld*(p: th.Vf2): th.Vf2 {\n"
"\treturn th.Vf2{ p.x + r.x - r.w/2, p.y + r.y - r.h/2 }\n"
"}\n"
"\n"
"// translates world coordinates to screen coordinates with cam r\n"
"fn (r: ^Rect) toScreen*(p: th.Vf2): th.Vf2 {\n"
"\treturn th.Vf2{ p.x - r.x + r.w/2, p.y - r.y + r.h/2 }\n"
"}\n"
"\n"
"fn (r: ^Rect) getPos*(): th.Vf2 {\n"
"\treturn th.Vf2{r.x, r.y}\n"
"}\n"
"\n"
"fn (r: ^Rect) getDims*(): th.Vf2 {\n"
"\treturn th.Vf2{r.w, r.h}\n"
"}\n"
"\n"
"// returns where the second point of the rectangle lies.\n"
"fn (r: ^Rect) getEnd*(): th.Vf2 {\n"
"\treturn th.Vf2{r.x+r.w, r.y+r.h}\n"
"}\n"
"\n"
"fn umth_transform_rect(ret: ^th.Quad, r: ^Rect, t: ^th.Transform)\n"
"// Transforms a rect into a quad.\n"
"// Order:\n"
"// \t1. scale\n"
"// \t2. rotation\n"
"// \t3. position\n"
"fn (r: ^Rect) transformed*(t: th.Transform): th.Quad {\n"
"\tvar ret: th.Quad\n"
"\tumth_transform_rect(&ret, r, &t)\n"
"\n"
"\treturn ret\n"
"}\n"
"",
"// Tilemaps allow for easy level construction and fast collisions. You can even\n"
"// use them for some games instead of entities (tetris comes to mind)\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"rect.um\"\n"
"\t\"ent.um\"\n"
"\t\"atlas.um\"\n"
")\n"
"\n"
"const (\n"
"\ttop* = 1\n"
"\tright* = 2\n"
"\tbot* = 4\n"
"\tleft* = 8\n"
")\n"
"\n"
"// Tilemap struct\n"
"type Tilemap* = struct {\n"
"\tatlas: atlas.Atlas\n"
"\tpos: th.Vf2\n"
"\tw: th.uu // width of tilemap\n"
"\tcells: []th.uu // all cells (this will draw the tile in tiles with number in cells - 1)\n"
"\tcollMask: []bool // if true, the tile collides\n"
"\tscale: th.fu\n"
"}\n"
"\n"
"fn mk*(cells: []th.uu, w: th.uu, at: atlas.Atlas, scale: th.fu = 1): Tilemap {\n"
"\tt := Tilemap{}\n"
"\tt.cells = cells\n"
"\tt.w = w\n"
"\tt.atlas = at\n"
"\tt.collMask = make([]bool, 10) //  TODO\n"
"\tt.scale = scale\n"
"\t\n"
"\treturn t\n"
"}\n"
"\n"
"// Sets tile at [x, y] to tile.\n"
"fn (t: ^Tilemap) edit*(x, y, tile: int) {\n"
"\tt.cells[y*t.w + x] = tile\n"
"}\n"
"\n"
"fn umth_tilemap_draw(ct: ^Tilemap, cam: ^rect.Rect)\n"
"// Draws the tilemap.\n"
"fn (t: ^Tilemap) draw*(cam: rect.Rect) {\n"
"\tif len(t.cells) == 0 { return }\n"
"\n"
"\tumth_tilemap_draw(t, &cam)\n"
"}\n"
"\n"
"fn umth_tilemap_getcoll(pos: ^th.Vf2, vert: ^th.uu, t: ^Tilemap, e: ^ent.Ent): int32\n"
"// Checks, if t collides with e.\n"
"// pos is the tile index where the collision happened\n"
"// vert is which index collided\n"
"// You need to pass a valid pointer (TODO)\n"
"fn (t: ^Tilemap) getColl*(e: ent.Ent, vert: ^th.uu, pos: ^th.Vf2): bool {\n"
"\tif len(t.cells) == 0 { return false }\n"
"\n"
"\tc := umth_tilemap_getcoll(pos, vert, t, &e)\n"
"\n"
"\treturn bool(c)\n"
"}\n"
"\n"
"fn umth_tilemap_autotile(tgt: ^th.uu, w, h: th.uu, src, cfg: ^th.uu, tile: th.uu)\n"
"// Autotile turns all `tile` tiles in `src` into tiles in `tileCfg`, so they\n"
"// follow up correctly. `tileCfg` is an array of 16 tiles. They are placed in\n"
"// a way where OR of all the places where the tile continues (top, right bot,\n"
"// right). The constants for them are defined in this file. Example:\n"
"// tileCfg[top | bot] = 21\n"
"// top | bot would look something like this: |\n"
"fn (t: ^Tilemap) autotile*(src, tileCfg: []th.uu, tile: th.uu) {\n"
"\tif len(tileCfg) < 16 {\n"
"\t\terror(\"autotile: tileCfg len isn\'t 16\'\")\n"
"\t}\n"
"\n"
"\tumth_tilemap_autotile(&t.cells[0], t.w, len(t.cells)/t.w, &src[0], &tileCfg[0], tile)\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"audio.um\"\n"
"\t\"canvas.um\"\n"
"\t\"image.um\"\n"
"\t\"placeholders.um\"\n"
"\t\"rect.um\"\n"
"\t\"std.um\"\n"
"\t\"th.um\"\n"
")\n"
"\n"
"var (\n"
"\tstart, end, clockOffset: real\n"
"\tw*, h*: int32\n"
"\tfpsLimit: int = 60\n"
"\n"
"\twp*: th.Vf2\n"
")\n"
"\n"
"fn umth_window_setup(title: str, w, h: int)\n"
"fn umth_window_clear_frame()\n"
"fn umth_window_get_dimensions(w, h: ^int32)\n"
"fn umth_window_swap_buffers()\n"
"fn umth_window_handle(): bool\n"
"fn umth_window_sleep(ms: int)\n"
"\n"
"fn umth_window_set_viewport(dm: th.Vf2)\n"
"// Sets the dimensions of the viewport. The dimensions are saved in the `wp`\n"
"// variable.\n"
"// \n"
"// `dm`\n"
"// : dimension of the viewport\n"
"fn setViewport*(dm: th.Vf2) {\n"
"\twp = dm\n"
"\tumth_window_set_viewport(dm)\n"
"}\n"
"\n"
"// Sets up the engine and opens a window.\n"
"fn setup*(title: str = \"tophat game\", width: int = 400, height: int32 = 400) {\n"
"\tw, h = width, height\n"
"\tumth_window_setup(title, width, height)\n"
"\tumth_window_clear_frame()\n"
"\n"
"\tif std.getenv(\"HOME\") == \"\" {\n"
"\t\tth.platform = \"windows\"\n"
"\t}\n"
"\n"
"\taudio.__setup()\n"
"\tplaceholders.__setup()\n"
"\n"
"\tclockOffset = std.clock() * 1000\n"
"\tstart = std.clock() * 1000\n"
"\n"
"\tsetViewport(th.Vf2{width, height})\n"
"}\n"
"\n"
"// Cycle needs to be called every cycle for the window to work. If the window\n"
"// was closed, it returns false.\n"
"fn cycle*(): bool {\n"
"\tumth_window_set_viewport(wp)\n"
"\tcanvas.drawRect(th.black, rect.mk(-4 * wp.x, 0, 4 * wp.x, wp.y))\n"
"\tcanvas.drawRect(th.black, rect.mk(0, -4 * wp.y, wp.x, 4 * wp.y))\n"
"\tcanvas.drawRect(th.black, rect.mk(wp.x, 0, 4 * wp.x, wp.y))\n"
"\tcanvas.drawRect(th.black, rect.mk(0, wp.y, wp.x, 4 * wp.y))\n"
"\n"
"\tumth_window_swap_buffers()\n"
"\n"
"\tend = std.clock()*1000\n"
"\tth.delta = round(end - start)\n"
"\tif 1000/fpsLimit - th.delta > 0 {\n"
"\t\tumth_window_sleep(1000/fpsLimit - th.delta)\n"
"\t\tth.delta = round(std.clock()*1000 - start)\n"
"\t}\n"
"\n"
"\tstart = std.clock()*1000\n"
"\tth.time = round(start - clockOffset)\n"
"\n"
"\trunning := umth_window_handle()\n"
"\tumth_window_clear_frame()\n"
"\tumth_window_get_dimensions(&w, &h)\n"
"\n"
"\taudio.__cycle()\n"
"\treturn running\n"
"}\n"
"\n"
"fn umth_window_begin_scissor(x, y: int, w, h: uint)\n"
"fn umth_window_end_scissor()\n"
"// Disable rendering outside of rect `r`\n"
"fn beginScissorRect*(r: rect.Rect) {\n"
"\tumth_window_begin_scissor(trunc(r.x), trunc(r.y), trunc(r.w), trunc(r.h))\n"
"}\n"
"\n"
"// Stops cropping\n"
"fn endScissor*() {\n"
"\tumth_window_end_scissor();\n"
"}\n"
"\n"
"// Returns dimensions of the window in screen pixels.\n"
"fn getDims*(): th.Vf2 {\n"
"\treturn th.Vf2{w, h}\n"
"}\n"
"\n"
"// Sets the fps limit.\n"
"// \n"
"// `fps`\n"
"// : amount of fps the limit should be set to\n"
"fn setTargetFps*(fps: int) {\n"
"\tfpsLimit = fps\n"
"}\n"
"\n"
"fn umth_window_set_dims(dm: th.Vf2)\n"
"// Sets the dimensions of the window, linux only.\n"
"// \n"
"// `dm`\n"
"// : the target dimensions in screen pixels\n"
"fn setDims*(dm: th.Vf2) {\n"
"\tumth_window_set_dims(dm)\n"
"}\n"
"\n"
"fn umth_window_set_icon(img: image.Image)\n"
"// Sets the window icon, linux only.\n"
"fn setIcon*(img: image.Image) {\n"
"\tumth_window_set_icon(img)\n"
"}\n"
"\n"
"fn umth_window_show_cursor(show: bool)\n"
"// Show or hide the cursor, linux only.\n"
"fn showCursor*(show: bool) {\n"
"\tumth_window_show_cursor(show)\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"utf8.um\"\n"
"\t\"rect.um\"\n"
"\t\"input.um\"\n"
"\t\"canvas.um\"\n"
")\n"
"\n"
"const (\n"
"\teventUnknown* = 0\n"
"\teventHover*\n"
"\teventPress*\n"
"\teventJustPress*\n"
"\teventRelease*\n"
")\n"
"\n"
"type Theme* = struct {\n"
"\tfg, bg: uint32\n"
"\n"
"\tborderColor: uint32\n"
"\tborderSize: th.fu\n"
"}\n"
"\n"
"// A structure all elements have to contain. t can be set manually by the user,\n"
"// s being the dimensions, or it can be set by another elements. onEvent is an\n"
"// event callback. It will pass whatever is set in the ctx field.\n"
"// Event types:\n"
"// eventUnknown\n"
"// eventHover\n"
"// eventPress\n"
"// eventJustPress\n"
"// eventRelease\n"
"type Generic* = struct {\n"
"\tr: rect.Rect\n"
"\tgridPos: th.Vf2\n"
"\tgridSpan: th.Vf2\n"
"\ttheme: Theme\n"
"\n"
"\tctx: interface{}\n"
"\tonEvent: fn(eventType: th.uu, ctx: interface{})\n"
"\tpressed: bool\n"
"\tselected: bool\n"
"}\n"
"\n"
"// An interface every ui element has to implements.\n"
"type Element* = interface {\n"
"\thandle()\n"
"\tdraw()\n"
"\tget(): ^Generic\n"
"}\n"
"\n"
"// Interface used anywhere, where text is rendered.\n"
"type TextRenderer* = interface {\n"
"\tdraw(text: str, pos: th.Vf2, color: uint32, scale: th.fu = 1.0)\n"
"\tmeasure(text: str): th.Vf2\n"
"}\n"
"\n"
"// Bindings around canvas\'s font rendering functions to make them usable\n"
"// with the TextRenderer interface.\n"
"type PixelFont* = struct { }\n"
"fn (pf: ^PixelFont) draw*(text: str, pos: th.Vf2, color: uint32, scale: th.fu = 1.0) {\n"
"\tcanvas.drawText(text, pos, color, scale)\n"
"}\n"
"fn (pf: ^PixelFont) measure*(text: str): th.Vf2 {\n"
"\treturn canvas.textSize(text, 1)\n"
"}\n"
"\n"
"fn mkGeneric*(): Generic {\n"
"\tg := Generic{}\n"
"\tg.onEvent = fn(eventType: th.uu, ctx: interface{}) { }\n"
"\treturn g\n"
"}\n"
"\n"
"// Functions that sets the grid pos of a Generic\n"
"fn (g: ^Generic) grid*(x, y: th.uu): ^Generic {\n"
"\tg.gridPos.x = x\n"
"\tg.gridPos.y = y\n"
"\treturn g\n"
"}\n"
"\n"
"// Function setting the grid span of a Generic\n"
"fn (g: ^Generic) span*(x, y: th.uu): ^Generic {\n"
"\tg.gridSpan.x = x\n"
"\tg.gridSpan.y = y\n"
"\treturn g\n"
"}\n"
"\n"
"// Generic\'s handle function. It checks for events. If you create your own\n"
"// ui element and want to have more control over how events are fired, you\n"
"// don\'t have to use it.\n"
"fn (g: ^Generic) handle*() {\n"
"\tm := input.getMousePos()\n"
"\tif m.x < g.r.x || m.y < g.r.y ||\n"
"\t\tm.x > g.r.x + g.r.w || m.y > g.r.y + g.r.h {\n"
"\t\tif g.pressed {\n"
"\t\t\tg.pressed = false\n"
"\t\t\tg.onEvent(eventRelease, g.ctx)\n"
"\t\t}\n"
"\t\treturn\n"
"\t}\n"
"\t\n"
"\tg.onEvent(eventHover, g.ctx)\n"
"\t\n"
"\tif input.isPressed(input.mouse1) {\n"
"\t\tinput.clear(input.mouse1)\n"
"\n"
"\t\tif !g.pressed {\n"
"\t\t\tg.onEvent(eventJustPress, g.ctx)\n"
"\t\t}\n"
"\n"
"\t\tg.onEvent(eventPress, g.ctx)\n"
"\t\tg.pressed = true\n"
"\t} else if g.pressed {\n"
"\t\tg.pressed = false\n"
"\t\tg.onEvent(eventRelease, g.ctx)\n"
"\t}\n"
"}\n"
"\n"
"fn drawBorder*(p, d: th.Vf2, t: Theme) {\n"
"\tcanvas.drawRect(t.borderColor, rect.mk(p.x, p.y, t.borderSize, d.y))\n"
"\tcanvas.drawRect(t.borderColor, rect.mk(p.x, p.y, d.x, t.borderSize))\n"
"\tcanvas.drawRect(t.borderColor, rect.mk(p.x + d.x - t.borderSize, p.y, t.borderSize, d.y))\n"
"\tcanvas.drawRect(t.borderColor, rect.mk(p.x, p.y + d.y - t.borderSize, d.x, t.borderSize))\n"
"}\n"
"",
"// Umka standard library\n"
"\n"
"// Memory\n"
"\n"
"fn rtlmemcpy(dest, src: ^void, count: int)\n"
"\n"
"fn tobytes*(buf: interface{}): []uint8 {\n"
"    if buf.__self == null {\n"
"        error(\"Buffer is null\")\n"
"    }\n"
"    if selfhasptr(buf) {\n"
"        error(\"Cannot access reference types\")\n"
"    }\n"
"    bytes := make([]uint8, sizeofself(buf))\n"
"    rtlmemcpy(&bytes[0], buf.__self, sizeofself(buf))\n"
"    return bytes\n"
"}\n"
"\n"
"fn frombytes*(buf: interface{}, bytes: []uint8) {\n"
"    if buf.__self == null {\n"
"        error(\"Buffer is null\")\n"
"    }    \n"
"    if selfhasptr(buf) {\n"
"        error(\"Cannot access reference types\")\n"
"    }\n"
"    if sizeofself(buf) != len(bytes) {\n"
"        error(\"Illegal buffer size\")\n"
"    }\n"
"    rtlmemcpy(buf.__self, &bytes[0], sizeofself(buf))    \n"
"}\n"
"\n"
"// File I/O\n"
"\n"
"type File* = ^struct {}\n"
"\n"
"const (\n"
"    seekBegin* = 0\n"
"    seekCur*   = 1\n"
"    seekEnd*   = 2\n"
")    \n"
"\n"
"fn rtlfopen  (name: str, mode: str): File;  \n"
"fn fopen*    (name: str, mode: str): File {return rtlfopen(name, mode)}\n"
"\n"
"fn rtlfclose (f: File): int\n"
"fn fclose*   (f: File): int {return rtlfclose(f)}\n"
"\n"
"fn rtlfread(buf: ^void, size, cnt: int, f: File): int\n"
"\n"
"fn fread*(f: File, buf: interface{}): int {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }\n"
"    if bytes := ^[]uint8(buf); bytes != null {\n"
"        return rtlfread(&bytes[0], len(bytes^), 1, f)\n"
"    }\n"
"    if selfhasptr(buf) {\n"
"        error(\"Cannot read reference types except ^[]uint8\")\n"
"    }\n"
"    return rtlfread(buf.__self, sizeofself(buf), 1, f)\n"
"}\n"
"\n"
"fn rtlfwrite(buf: ^void, size, cnt: int, f: File): int\n"
"\n"
"fn fwrite*(f: File, buf: interface{}): int {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }\n"
"    if bytes := ^[]uint8(buf); bytes != null {\n"
"        return rtlfwrite(&bytes[0], len(bytes^), 1, f)\n"
"    }    \n"
"    if selfhasptr(buf) {\n"
"        error(\"Cannot write reference types except ^[]uint8\")\n"
"    }\n"
"    return rtlfwrite(buf.__self, sizeofself(buf), 1, f)\n"
"}\n"
"\n"
"fn rtlfseek  (f: File, offset, origin: int): int\n"
"fn fseek*    (f: File, offset, origin: int): int {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }\n"
"    return rtlfseek(f, offset, origin)\n"
"}\n"
"\n"
"fn rtlftell (f: File): int\n"
"fn ftell*   (f: File): int {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }\n"
"    return rtlftell(f)\n"
"}\n"
"\n"
"fn rtlremove (name: str): int\n"
"fn remove*   (name: str): int {return rtlremove(name)}\n"
"\n"
"fn rtlfeof  (f: File): int\n"
"fn feof*    (f: File): bool {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }                \n"
"    return bool(rtlfeof(f))\n"
"}\n"
"\n"
"// I/O utilities\n"
"\n"
"fn println*(s: str): int {return printf(\"%s\\n\", s)}\n"
"fn fprintln*(f: File, s: str): int {return fprintf(f, \"%s\\n\", s)}\n"
"\n"
"fn getchar*(): char {\n"
"    var c: char\n"
"    scanf(\"%c\", &c)\n"
"    return c\n"
"}\n"
"\n"
"// Strings\n"
"\n"
"fn ltrim*(s: str): str {\n"
"    start := -1\n"
"    slen := len(s)\n"
"    for i := 0; i < slen; i++ {\n"
"        if s[i] != \' \' && s[i] != \'\\t\' {\n"
"            start = i\n"
"            break\n"
"        } \n"
"    }\n"
"    if start == -1 {return \"\"}\n"
"    return slice(s, start)\n"
"}\n"
"\n"
"fn rtrim*(s: str): str {\n"
"    stop := -1\n"
"    slen := len(s)\n"
"    for i := slen - 1; i >= 0; i-- {\n"
"        if s[i] != \' \' && s[i] != \'\\t\' {\n"
"            stop = i\n"
"            break\n"
"        } \n"
"    }\n"
"    if stop == -1 {return \"\"}\n"
"    return slice(s, 0, stop + 1)\n"
"}\n"
"\n"
"fn trim*(s: str): str {\n"
"    return ltrim(rtrim(s))\n"
"}\n"
"\n"
"// Conversions\n"
"\n"
"fn atoi*(s: str): int {\n"
"    var x: int\n"
"    sscanf(s, \"%lld\", &x)\n"
"    return x\n"
"}\n"
"\n"
"fn atof*(s: str): real {\n"
"    var x: real\n"
"    sscanf(s, \"%lf\", &x)\n"
"    return x\n"
"}\n"
"\n"
"fn itoa*(x: int): str {\n"
"    s := str(make([]char, 256))\n"
"    sprintf(s, \"%lld\", x)\n"
"    return s\n"
"}\n"
"\n"
"fn ftoa*(x: real, decimals: int): str {\n"
"    fmt := str(make([]char, 256))\n"
"    s := str(make([]char, 256))\n"
"    sprintf(fmt, \"%%.%dlf\", decimals)\n"
"    sprintf(s, fmt, x)\n"
"    return s\n"
"}\n"
"\n"
"// Math\n"
"\n"
"const pi* = 3.14159265358979323846\n"
"\n"
"// Random numbers\n"
"\n"
"const randMax* = 0x7FFFFFFF\n"
"randSeed := 0\n"
"\n"
"fn srand*(seed: int) {randSeed = seed}\n"
"\n"
"fn rand*(): int {\n"
"    randSeed = ((randSeed * 1103515245) + 12345) & 0x7FFFFFFF\n"
"    return randSeed\n"
"}\n"
"\n"
"fn frand*(): real {return real(rand()) / randMax}\n"
"\n"
"// Timer\n"
"\n"
"fn rtltime(): int\n"
"fn time*(): int {return rtltime()}\n"
"\n"
"fn rtlclock(): real\n"
"fn clock*(): real {return rtlclock()}\n"
"\n"
"// Command line and environment\n"
"\n"
"fn argc*(): int {return rtlargc}\n"
"\n"
"fn argv*(i: int): str {\n"
"    if i < 0 || i >= rtlargc {\n"
"        error(\"Command line parameter not found\")\n"
"    }\n"
"    return rtlargv[i]\n"
"}\n"
"\n"
"fn rtlgetenv(name: str): str\n"
"fn getenv*(name: str): str {\n"
"    return \"\" + rtlgetenv(name)\n"
"}\n"
"\n"
"",
"// Particles allow for <i>performant</i> and random particle systems.\n"
"// TODO: a better constructor\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"rect.um\"\n"
")\n"
"\n"
"// Particle struct. You can tweak the start_time for godot-like explossivness.\n"
"type Particle* = struct {\n"
"\tstart_time: uint\n"
"\tseed: int32\n"
"}\n"
"\n"
"// Emitter. This is where everything is configured.\n"
"type Emitter* = struct {\n"
"\tpos: th.Vf2 // position\n"
"\tdm: th.Vf2 // size of the emittion area\n"
"\tgravity: th.Vf2 // gravity\n"
"\trepeat: bool // if false, particle won\'t be renewed\n"
"\tactive: bool // false, if there aren\'t any active particles anymore\n"
"\t\n"
"\tangle: th.Vf2 // angle in which particles are emitted\n"
"\n"
"\tlifetime: th.uu // lifetime of particles\n"
"\tlifetimeRandomness: th.fu // randomness in %/100\n"
"\n"
"\tvelocity: th.fu // velocity\n"
"\tvelocityRandomness: th.fu // randomness in %/100\n"
"\n"
"\tsize: th.fu // size\n"
"\tsizeRandomness: th.fu // randomness in %/100\n"
"\tmaxSize: th.fu // size at the end of particles lifetime\n"
"\n"
"\trotation: th.fu\n"
"\trotationRandomness: th.fu\n"
"\tmaxRotation: th.fu\n"
"\n"
"\tcolors: []uint32 // array of colors, which are interpolated between\n"
"\t\n"
"\tparticles: []Particle // list of particles\n"
"}\n"
"\n"
"fn umth_particles_draw(p: ^Emitter, cam: ^rect.Rect, t: int32)\n"
"// Draws and updates the particles.\n"
"fn (e: ^Emitter) draw*(cam: rect.Rect, t: int32) {\n"
"\tif len(e.colors) <= 0 || len(e.particles) <= 0 {\n"
"\t\treturn\n"
"\t}\n"
"\n"
"\tumth_particles_draw(e, &cam, t)\n"
"}\n"
"",
"// Simple linear interpolation module.\n"
"\n"
"import (\n"
"\t\"th.um\"\t\t\t\t\t\t\t\t\n"
")\n"
"\n"
"type Any* = interface{}\n"
"\n"
"// Lerper queue item. It interpolates between start and end for the duration\n"
"// of length in ms. Additionally you can enable swap, which instead of\n"
"// dequeueing swaps start and end and resets the progress.\n"
"type Item* = struct {\n"
"\tstart, end: th.fu\n"
"\tlength: th.uu\n"
"\tprogress: th.fu\n"
"\tswap: bool\n"
"\tctx: Any\n"
"\tcallback: fn(ctx: Any)\n"
"}\n"
"\n"
"// Item\'s constructor\n"
"fn mk*(start, end: th.fu, length: th.uu, swap: bool = false): Item {\n"
"\treturn Item{\n"
"\t\tstart, end, length, 0, swap, null, fn(ctx: Any) {}}\n"
"}\n"
"\n"
"// Lerper is a queue of items. It will lerp the first one and if it ends\n"
"// and doesn\'t have swap enabled, it will dequeue it.\n"
"type Lerper* = []Item\n"
"\n"
"// Removes the first lerper item.\n"
"fn (l: ^Lerper) dequeue*() {\n"
"\tswitch len(l^) {\n"
"\tcase 0:\n"
"\t\treturn\n"
"\tcase 1:\n"
"\t\tl^ = Lerper{}\n"
"\tdefault:\n"
"\t\tl^ = slice(l^, 1)\n"
"\t}\n"
"}\n"
"\n"
"// Adds an item to l\'s queue\n"
"fn (l: ^Lerper) enqueue*(i: Item) {\n"
"\tl^ = append(l^, i)\n"
"}\n"
"\n"
"// Interpolates the front by delta. And returns it\'s value.\n"
"fn (l: ^Lerper) byDelta*(delta: th.uu): th.fu {\n"
"\tif len(l^) == 0 {\n"
"\t\treturn 0\n"
"\t}\n"
"\n"
"\t/*for l[0].progress >= 1.0 {\n"
"\t\tl[0].callback(l[0].ctx)\n"
"\n"
"\t\tif l[0].swap {\n"
"\t\t\ttmp := l[0].start\n"
"\t\t\tl[0].start = l[0].end\n"
"\t\t\tl[0].end = tmp\n"
"\n"
"\t\t\tl[0].progress = 0\n"
"\t\t\tbreak\n"
"\t\t}\n"
"\n"
"\t\tl.dequeue()\n"
"\t\tif len(l^) == 0 {\n"
"\t\t\treturn 0\n"
"\t\t}\n"
"\t}*/\n"
"\n"
"\tif l[0].progress >= 1 {\n"
"\t\tend := l[0].end\n"
"\t\tl.dequeue()\n"
"\t\treturn end\n"
"\t}\n"
"\n"
"\tl[0].progress += th.fu(delta)/l[0].length\n"
"\n"
"\treturn l[0].progress * (l[0].end-l[0].start) + l[0].start\n"
"}\n"
"",
"// UTF-8 utilities\n"
"\n"
"type (\n"
"\tRune* = int32\n"
")\n"
"\n"
"fn (r: ^Rune) size*(): int {\n"
"\tif r^ <= 0x7f {\n"
"\t\treturn 1\n"
"\t}\n"
"\n"
"\tif r^ <= 0x7ff {\n"
"\t\treturn 2\n"
"\t}\n"
"\n"
"\tif r^ <= 0xffff {\n"
"\t\treturn 3\n"
"\t}\n"
"\n"
"\tif r^ <= 0x10ffff {\n"
"\t\treturn 4\n"
"\t}\n"
"\n"
"\treturn 0\n"
"}\n"
"\n"
"fn (r: ^Rune) encode*(): str {\n"
"\ts := r.size()\n"
"\n"
"\tif s == 1 {\n"
"\t\treturn str(char(r^))\n"
"\t}\n"
"\n"
"\tout := make([]char, s + 1)\n"
"\n"
"\t// header is size amount of ones at the start\n"
"\theader := 0\n"
"\tfor i := 0; i < s; i++ {\n"
"\t\theader |= 1 << (7 - i)\n"
"\t}\n"
"\n"
"\tshift := (s - 1) * 6\n"
"\tout[0] = char(((r^ >> shift & 0xff) | header) & 0xff)\n"
"\n"
"\tfor i := 1; i < s; i++ {\n"
"\t\tshift -= 6\n"
"\t\tout[i] = char(r^ >> shift & 0x3f | 0x80)\n"
"\t}\n"
"\n"
"\treturn str(out)\n"
"}\n"
"\n"
"fn umth_utf8_get_next_rune*(a: str, pos: int): Rune\n"
"fn getNextRune*(a: str, pos: int): Rune {\n"
"\treturn umth_utf8_get_next_rune(a, pos)\n"
"}\n"
"\n"
"fn decode*(s: str): []Rune {\n"
"\trunes := make([]Rune, len(s))\n"
"\truneCount := 0\n"
"\n"
"\tl := len(s)\n"
"\t\n"
"\tfor i := 0; i < l; runeCount++ {\n"
"\t\trunes[runeCount] = getNextRune(s, i)\n"
"\t\ti += runes[runeCount].size()\n"
"\t}\n"
"\n"
"\treturn slice(runes, 0, runeCount)\n"
"}\n"
"\n"
"fn realLength*(s: str): int {\n"
"\trl := 0\n"
"\tl := len(s)\n"
"\tfor i := 0; i < l; rl++ {\n"
"\t\tr := getNextRune(s, i)\n"
"\t\ti += r.size()\n"
"\t}\n"
"\n"
"\treturn rl\n"
"}\n"
"",
"// Module for font rendering. Unicode is supported, but only left to right.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
")\n"
"\n"
"const (\n"
"\tfilterBilinear* = 0\n"
"\tfilterNearest* = 1\n"
")\n"
"\n"
"type Font* = struct { _: ^struct{} }\n"
"\n"
"\n"
"fn umth_font_load(path: str, size: th.fu, filter: uint32): ^struct{}\n"
"fn load*(path: str, size: th.fu, filter: uint32 = filterBilinear): Font {\n"
"\treturn Font{umth_font_load(path, size, filter)}\n"
"}\n"
"\n"
"fn umth_font_draw(font: Font, s: str, x: th.fu, y: th.fu, color: uint32, scale: th.fu)\n"
"fn (f: ^Font) draw*(text: str, pos: th.Vf2, color: uint32, scale: th.fu = 1.0) {\n"
"\tumth_font_draw(f^, text, pos.x, pos.y, color, scale)\n"
"}\n"
"\n"
"fn (f: ^Font) validate*(): bool {\n"
"\treturn f._ != null\n"
"}\n"
"\n"
"fn umth_font_measure(font: Font, s: str, o: ^th.Vf2)\n"
"fn (f: ^Font) measure*(text: str): th.Vf2 {\n"
"\tvar size: th.Vf2\n"
"\tumth_font_measure(f^, text, &size)\n"
"\treturn size\n"
"}\n"
"",
"// Module with useful variables and types.\n"
"// Variables: time, delta, platform\n"
"// Constants: black, white, red, green, blue, yellow, magenta, cyan.\n"
"\n"
"import (\n"
"\t\"std.um\"\n"
")\n"
"\n"
"// standard type for real values\n"
"type fu* = real32\n"
"// standard type for integer values\n"
"type iu* = int32\n"
"// standard type for unsigned values\n"
"type uu* = uint32\n"
"\n"
"// vector 2\n"
"type Vf2* = struct {\n"
"\tx, y: fu\n"
"}\n"
"\n"
"// Vf2 constructor\n"
"fn mkVf2*(x: fu = 0, y: fu = 0): Vf2 {\n"
"\treturn Vf2{x, y}\n"
"}\n"
"\n"
"// rotates `p` around `origin` with `rot` in degrees\n"
"fn (p: ^Vf2) rotated*(origin: Vf2, rot: fu): Vf2 {\n"
"\tangle := (rot * std.pi) / 180\n"
"\n"
"\tpos := p^\n"
"\tpos.x -= origin.x\n"
"\tpos.y -= origin.y\n"
"\n"
"\tx := pos.x * cos(angle) - pos.y * sin(angle)\n"
"\ty := pos.x * sin(angle) + pos.y * cos(angle)\n"
"\n"
"\tpos.x = x + origin.x\n"
"\tpos.y = y + origin.y\n"
"\n"
"\treturn pos\n"
"}\n"
"\n"
"// distance between p1 and p2\n"
"fn (p1: ^Vf2) distanceTo*(p2: Vf2): fu {\n"
"\treturn std.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y))\n"
"}\n"
"\n"
"// Angle between p1 and p2\n"
"fn (p1: ^Vf2) angleTo*(p2: Vf2): real {\n"
"\tif p1.x == p2.x && p1.y == p2.y { return 0 }\n"
"\treturn atan2(p2.y - p1.y, p2.x - p1.x) * 180 / std.pi + 180\n"
"}\n"
"\n"
"// Absolute value of a vector.\n"
"fn (p: ^Vf2) abs*(): Vf2 {\n"
"\treturn Vf2{fabs(p.x), fabs(p.y)}\n"
"}\n"
"\n"
"// Rounds a vector.\n"
"fn (p: ^Vf2) round*(): Vf2 {\n"
"\treturn Vf2{round(p.x), round(p.y)}\n"
"}\n"
"\n"
"// Truncates a vector.\n"
"fn (p: ^Vf2) trunc*(): Vf2 {\n"
"\treturn Vf2{trunc(p.x), trunc(p.y)}\n"
"}\n"
"\n"
"// Floors a vector.\n"
"fn (p: ^Vf2) floor*(): Vf2 {\n"
"\treturn Vf2{floor(p.x), floor(p.y)}\n"
"}\n"
"\n"
"// Ceils a vector.\n"
"fn (p: ^Vf2) ceil*(): Vf2 {\n"
"\treturn Vf2{ceil(p.x), ceil(p.y)}\n"
"}\n"
"\n"
"// Creates a vector with both x and y set to f\n"
"fn vf2f*(f: fu): Vf2 {\n"
"\treturn Vf2{f, f}\n"
"}\n"
"\n"
"// Subtracts a vector from another one.\n"
"fn (p: ^Vf2) sub*(p2: Vf2): Vf2 {\n"
"\treturn Vf2{p.x - p2.x, p.y - p2.y}\n"
"}\n"
"\n"
"// Subtracts a fu from a vector.\n"
"fn (p: ^Vf2) subf*(f: fu): Vf2 {\n"
"\treturn Vf2{p.x - f, p.y - f}\n"
"}\n"
"\n"
"// Adds a vector to another one.\n"
"fn (p: ^Vf2) add*(p2: Vf2): Vf2 {\n"
"\treturn Vf2{p.x + p2.x, p.y + p2.y}\n"
"}\n"
"\n"
"// Adds a fu to a vector.\n"
"fn (p: ^Vf2) addf*(f: fu): Vf2 {\n"
"\treturn Vf2{p.x + f, p.y + f}\n"
"}\n"
"\n"
"// Divides a vector by another one.\n"
"fn (p: ^Vf2) div*(p2: Vf2): Vf2 {\n"
"\treturn Vf2{p.x / p2.x, p.y / p2.y}\n"
"}\n"
"\n"
"// Divides a vector by a fu.\n"
"fn (p: ^Vf2) divf*(f: fu): Vf2 {\n"
"\treturn Vf2{p.x / f, p.y / f}\n"
"}\n"
"\n"
"// Multiplies a vector by another one.\n"
"fn (p: ^Vf2) mul*(p2: Vf2): Vf2 {\n"
"\treturn Vf2{p.x * p2.x, p.y * p2.y}\n"
"}\n"
"\n"
"// Multiplies a vector by a fu.\n"
"fn (p: ^Vf2) mulf*(f: fu): Vf2 {\n"
"\treturn Vf2{p.x * f, p.y * f}\n"
"}\n"
"\n"
"// Returns the magnitude of a vector p.\n"
"fn (p: ^Vf2) mag*(): fu {\n"
"\treturn sqrt(p.x * p.x + p.y * p.y)\n"
"}\n"
"\n"
"// Normalizes a vector.\n"
"fn (p: ^Vf2) norm*(): Vf2 {\n"
"\tif p.x == 0 && p.y == 0 {\n"
"\t\treturn p^\n"
"\t}\n"
"\n"
"\treturn p.divf(p.mag())\n"
"}\n"
"\n"
"// Calculates dot product between 2 vectors.\n"
"fn (p: ^Vf2) dot*(q: Vf2): fu {\n"
"\treturn p.x*q.x + p.y*q.y\n"
"}\n"
"\n"
"// Struct defining transformation. Used for example by entities.\n"
"type Transform* = struct {\n"
"\tp: Vf2 // position\n"
"\ts: Vf2 // scale\n"
"\to: Vf2 // origin\n"
"\tr: fu  // rotation\n"
"}\n"
"\n"
"// Transform constructor\n"
"fn mkTransform*(p: Vf2, s: Vf2 = Vf2{1, 1}, o: Vf2 = Vf2{0, 0}, r: fu = 0.0): Transform {\n"
"\treturn Transform{p: p, s: s, o: o, r: r}\n"
"}\n"
"\n"
"fn umth_transform_transform(o, t: ^Transform)\n"
"// Transforms a transform with another transform.\n"
"fn (o: ^Transform) transformed*(t: Transform): Transform {\n"
"\tret := o^\n"
"\tumth_transform_transform(&ret, &t)\n"
"\n"
"\treturn ret\n"
"}\n"
"\n"
"fn umth_transform_vf2(v: ^Vf2, t: ^Transform)\n"
"// Transforms a vf2 to another vf2.\n"
"// Order:\n"
"// \t1. scale\n"
"// \t2. rotation\n"
"// \t3. position\n"
"// \n"
"// This allows conversion from a relative to an absolute vf2.\n"
"fn (v: ^Vf2) transformed*(t: Transform): Vf2 {\n"
"\tret := v^\n"
"\tumth_transform_vf2(&ret, &t)\n"
"\treturn ret\n"
"}\n"
"\n"
"type Quad* = [4]Vf2\n"
"\n"
"fn umth_transform_quad(q: ^Quad, t: ^Transform)\n"
"// Transforms a quad into another quad.\n"
"// Order:\n"
"// \t1. scale\n"
"// \t2. rotation\n"
"// \t3. position\n"
"fn (q: ^Quad) transformed*(t: Transform): Quad {\n"
"\tret := q^\n"
"\tumth_transform_quad(&ret, &t)\n"
"\treturn ret\n"
"}\n"
"\n"
"fn umth_th_getglobal(): ^struct{}\n"
"// returns a pointer to the th_global. Set this as your extensions thg.\n"
"fn getGlobal*(): ^struct{} {\n"
"\treturn umth_th_getglobal()\n"
"}\n"
"\n"
"fn umth_th_getfuncs(): ^struct{}\n"
"// returns pointer to tophat functions. Pass this to th_ext_set.\n"
"fn getFuncs*(): ^struct{} {\n"
"\treturn umth_th_getfuncs()\n"
"}\n"
"\n"
"const (\n"
"\tblack* = 0xff\n"
"\twhite* = 0xffffffff\n"
"\tred* = 0xff0000ff\n"
"\tgreen* = 0x00ff00ff\n"
"\tblue* = 0x0000ffff\n"
"\tyellow* = 0xffff00ff\n"
"\tmagenta* = 0xff00ffff\n"
"\tcyan* = 0x00ffffff\n"
")\n"
"\n"
"var (\n"
"\ttime*: uint\n"
"\tdelta*: int\n"
"\tplatform*: str = \"linux\"\n"
")\n"
"",
"// A module for importless communication between modules. A signal is an array\n"
"// of callbacks with a name.\n"
"\n"
"type Any* = interface{}\n"
"type Callback* = fn(ctx: Any) \n"
"type Signal* = []Callback\n"
"\n"
"var signals: map[str]Signal\n"
"\n"
"// Registers a callback to a signal. There is no need to explicitely create\n"
"// signals.\n"
"fn register*(name: str, callback: Callback) {\n"
"\tif !valid(signals) {\n"
"\t\tsignals = make(map[str]Signal)\n"
"\t}\n"
"\n"
"\tif !validkey(signals, name) {\n"
"\t\tsignals[name] = Signal{callback}\n"
"\t} else {\n"
"\t\tsignals[name] = append(signals[name], callback)\n"
"\t}\n"
"}\n"
"\n"
"// Calls all callbacks associated with the passed name.\n"
"fn emit*(name: str, ctx: Any) {\n"
"\tif !valid(signals) {\n"
"\t\tsignals = make(map[str]Signal)\n"
"\t}\n"
"\n"
"\tfor i, c in signals[name] {\n"
"\t\tc(ctx)\n"
"\t}\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"image.um\"\n"
")\n"
"\n"
"// Atlas is an image containing tiles in a square grid.\n"
"type Atlas* = struct {\n"
"\ti: image.Image // source image\n"
"\tcs: th.Vf2 // size of a cell in pixels\n"
"\tdm: th.Vf2 // amount of cells in image\n"
"}\n"
"\n"
"// i: source image\n"
"// dm: amount of cells\n"
"fn mk*(i: image.Image, dm: th.Vf2): Atlas {\n"
"\ta := Atlas{}\n"
"\n"
"\ta.i = i\n"
"\ta.dm = dm\n"
"\ta.cs = i.getDims().div(dm)\n"
"\n"
"\treturn a\n"
"}\n"
"\n"
"// returns the coordinates of the nth tile\n"
"fn (a: ^Atlas) coords*(n: int): th.Vf2 {\n"
"\treturn th.Vf2{ n % trunc(a.dm.x), (n - n % trunc(a.dm.x)) / a.dm.x }\n"
"}\n"
"\n"
"// Crops the sourse image to only show a wanted tile\n"
"fn (a: ^Atlas) cropSource*(at: th.Vf2) {\n"
"\tif (at.x > a.dm.x || at.y > a.dm.y || at.x * at.y < 0) {\n"
"\t\treturn\n"
"\t}\n"
"\n"
"\ta.i.crop(\n"
"\t\tth.Vf2{at.x / a.dm.x, at.y / a.dm.y},\n"
"\t\tth.Vf2{(at.x+1) / a.dm.x, (at.y+1) / a.dm.y})\n"
"}\n"
"\n"
"// Draws the tile at `at`\n"
"fn (a: ^Atlas) draw*(at: th.Vf2, t: th.Transform) {\n"
"\ta.cropSource(at)\n"
"\ta.i.draw(t, th.white)\n"
"\ta.i.crop(th.Vf2{}, th.Vf2{1, 1})\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"utf8.um\"\n"
"\t\"rect.um\"\n"
"\t\"../ui.um\"\n"
"\t\"canvas.um\"\n"
")\n"
"\n"
"// An element containing a TextRenderer. The text renderer supports\n"
"// word-wrapping and centered text.\n"
"type Label* = struct {\n"
"\tg: ui.Generic\n"
"\ttext: str\n"
"\trenderer: ui.TextRenderer\n"
"\tcenter: bool\n"
"\twrapping: bool\n"
"\tscale: th.fu\n"
"}\n"
"\n"
"// Label constructor\n"
"fn mk*(f: ui.TextRenderer, text: str, theme: ui.Theme, scale: th.fu, center: bool = false, wrapping: bool = false): Label {\n"
"\tl := Label{}\n"
"\tl.g = ui.mkGeneric()\n"
"\tl.g.theme = theme\n"
"\tl.text = text\n"
"\tl.renderer = f\n"
"\tl.scale = scale\n"
"\tl.center = center\n"
"\tl.wrapping = wrapping\n"
"\n"
"\treturn l\n"
"}\n"
"\n"
"fn (l: ^Label) get*(): ^ui.Generic {\n"
"\treturn &l.g\n"
"}\n"
"\n"
"fn (l: ^Label) handle*() {\n"
"\tl.g.handle()\n"
"}\n"
"\n"
"fn (l: ^Label) draw*() {\n"
"\tif len(l.text) == 0 {\n"
"\t\treturn\n"
"\t}\n"
"\n"
"\tcanvas.drawRect(l.g.theme.bg, rect.Rect{l.g.r.x, l.g.r.y, l.g.r.w, l.g.r.h})\n"
"\tui.drawBorder(l.g.r.getPos(), l.g.r.getDims(), l.g.theme)\n"
"\n"
"\ttext := utf8.decode(l.text)\n"
"\t// hack to wrap the last word too\n"
"\ttext = append(text, uint32(\' \'))\n"
"\tlineCount := 1\n"
"\n"
"\tlines := [][]utf8.Rune{}\n"
"\n"
"\tif l.wrapping {\n"
"\t\tlimit := l.g.r.w - l.g.theme.borderSize * 2\n"
"\t\twordStart := 0\n"
"\t\tlineWidth := 0.0\n"
"\n"
"\t\tfor i:=0; i < len(text); i++ {\n"
"\t\t\tif text[i] == uint32(\' \') {\n"
"\t\t\t\tif lineWidth > limit {\n"
"\t\t\t\t\tlines = append(lines, slice(text, 0, wordStart - 1))\n"
"\t\t\t\t\ttext = slice(text, wordStart)\n"
"\n"
"\t\t\t\t\twordStart = 0\n"
"\t\t\t\t\tlineWidth = 0\n"
"\t\t\t\t\ti = -1\n"
"\t\t\t\t\tcontinue\n"
"\t\t\t\t}\n"
"\n"
"\t\t\t\twordStart = i + 1\n"
"\t\t\t\tlineWidth += l.renderer.measure(\" \").x * l.scale\n"
"\t\t\t} else if text[i] == uint32(\'\\n\') {\n"
"\t\t\t\tlines = append(lines, slice(text, 0, i))\n"
"\t\t\t\ttext = slice(text, i + 1)\n"
"\n"
"\t\t\t\twordStart = 0\n"
"\t\t\t\tlineWidth = 0\n"
"\t\t\t\ti = -1\n"
"\t\t\t} else {\n"
"\t\t\t\tlineWidth += l.renderer.measure(text[i].encode()).x * l.scale\n"
"\t\t\t}\n"
"\t\t}\n"
"\n"
"\t\t// we have to remove the space again to prevent alignment issues\n"
"\t\tlines = append(lines, slice(text, 0, len(text) - 1))\n"
"\t} else {\n"
"\t\tlines = append(lines, text)\n"
"\t}\n"
"\n"
"\tx := l.g.r.x + l.g.theme.borderSize\n"
"\ty := l.g.r.y\n"
"\tif l.center {\n"
"\t\ty += (l.g.r.h - len(lines) * l.renderer.measure(\"A\").y * l.scale) / 2\n"
"\t}\n"
"\n"
"\tfor i in lines {\n"
"\t\ts := \"\"\n"
"\t\tfor j in lines[i] {\n"
"\t\t\ts += lines[i][j].encode()\n"
"\t\t}\n"
"\n"
"\t\tp := th.Vf2{\n"
"\t\t\tx: x,\n"
"\t\t\ty: y }\n"
"\n"
"\t\tif l.center {\n"
"\t\t\tp.x += (l.g.r.w - l.renderer.measure(s).x * l.scale) / 2 + l.g.theme.borderSize / 2\n"
"\t\t}\n"
"\n"
"\t\tl.renderer.draw(s, p, l.g.theme.fg, l.scale)\n"
"\n"
"\t\ty += l.renderer.measure(s).y * l.scale\n"
"\t}\n"
"}\n"
"\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"ui.um\"\n"
")\n"
"\n"
"// A Grid container. The grid size is fixed, not dynamic like in Tk.\n"
"type Grid* = struct {\n"
"\tg: ui.Generic\n"
"\tw, h: th.uu\n"
"\tborder: th.fu\n"
"\telements: []ui.Element\n"
"}\n"
"\n"
"// Grid\'s constructor\n"
"fn mk*(w, h: th.uu, border: th.fu = 0): Grid {\n"
"\treturn Grid {\n"
"\t\tg: ui.mkGeneric(),\n"
"\t\tw: w, h: h, border: border}\n"
"}\n"
"\n"
"fn (g: ^Grid) get*(): ^ui.Generic {\n"
"\treturn &g.g\n"
"}\n"
"\n"
"fn (g: ^Grid) handle*() {\n"
"\tcellSize := th.Vf2{g.g.r.w/g.w, g.g.r.h/g.h}\n"
"\n"
"\tfor i:=0; i < len(g.elements); i++ {\n"
"\t\te := &g.elements[i]\n"
"\t\tge := e.get()\n"
"\n"
"\t\tif ge.gridPos.x > g.w || ge.gridPos.y > g.h {\n"
"\t\t\terror(\"ui.Grid: out of bounds.\")\n"
"\t\t}\n"
"\n"
"\t\tge.r.x = ge.gridPos.x * cellSize.x\n"
"\t\tge.r.y = ge.gridPos.y * cellSize.y\n"
"\t\t// divide by to as there are two borders\n"
"\t\tge.r.x += g.border/2 + g.g.r.x\n"
"\t\tge.r.y += g.border/2 + g.g.r.y\n"
"\n"
"\t\tif ge.gridPos.x + ge.gridSpan.x > g.w ||\n"
"\t\t\tge.gridPos.y + ge.gridSpan.y > g.h {\n"
"\t\t\terror(\"ui.Grid: out of bounds.\")\n"
"\t\t}\n"
"\n"
"\t\tif ge.gridSpan.x == 0 {\n"
"\t\t\tge.gridSpan.x = 1\n"
"\t\t}\n"
"\n"
"\t\tif ge.gridSpan.y == 0 {\n"
"\t\t\tge.gridSpan.y = 1\n"
"\t\t}\n"
"\n"
"\t\tge.r.w = ge.gridSpan.x * cellSize.x\n"
"\t\tge.r.h = ge.gridSpan.y * cellSize.y\n"
"\t\t// don\'t divide by two as size is relative to position\n"
"\t\tge.r.w -= g.border\n"
"\t\tge.r.h -= g.border\n"
"\n"
"\t\te.handle()\n"
"\t}\n"
"}\n"
"\n"
"fn (g: ^Grid) draw*() {\n"
"\tfor i, e in g.elements {\n"
"\t\te.draw()\n"
"\t}\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"ui.um\"\n"
"\t\"image.um\"\n"
")\n"
"\n"
"// An element containing an image\n"
"type Image* = struct {\n"
"\tg: ui.Generic\n"
"\timage: image.Image\n"
"\tstretch: bool\n"
"}\n"
"\n"
"fn mk*(i: image.Image, stretch: bool = false): Image {\n"
"\treturn Image {\n"
"\t\tg: ui.Generic{},\n"
"\t\timage: i,\n"
"\t\tstretch: stretch}\n"
"}\n"
"\n"
"fn (i: ^Image) get*(): ^ui.Generic {\n"
"\treturn &i.g\n"
"}\n"
"\n"
"fn (i: ^Image) handle*() {\n"
"\ti.g.handle()\n"
"}\n"
"\n"
"fn (i: ^Image) draw*() {\n"
"\tdm := i.image.getDims()\n"
"\ts := th.Vf2{}\n"
"\tif i.stretch {\n"
"\t\ts.x = i.g.r.w/dm.x\n"
"\t\ts.y = i.g.r.h/dm.y\n"
"\t} else {\n"
"\t\tif i.g.r.w < i.g.r.h {\n"
"\t\t\ts.x = i.g.r.w/dm.x\n"
"\t\t\ts.y = s.x\n"
"\t\t\ti.g.r.y += (i.g.r.h - s.y*dm.y)/2\n"
"\t\t} else {\n"
"\t\t\ts.y = i.g.r.h/dm.y\n"
"\t\t\ts.x = s.y\n"
"\t\t\ti.g.r.x += (i.g.r.w - s.x*dm.x)/2\n"
"\t\t}\n"
"\t}\n"
"\n"
"\ti.image.draw(th.Transform{p: i.g.r.getPos(), s: s}, th.white)\n"
"}\n"
"\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
")\n"
"\n"
"// Shader allows you to define your own vertex and fragment GLSL shaders. This\n"
"// is a low-level feature, so it\'s very easy to mess up.\n"
"//  \n"
"// In tophat, instead of a main function, shaders provide th_vertex and\n"
"// th_fragment. The signature of th_vertex is:\n"
"// \n"
"// ```\n"
"// vec2 th_vertex(vec2 vert);\n"
"// ```\n"
"// \n"
"// where vert is the position of the vertex taken from the vertex buffer.\n"
"// The output is the vertex shader output.\n"
"//  \n"
"// As for fragment shaders, there are two types of them. One for canvas\n"
"// and one for images. In canvas shaders, the fragment function is very simple:\n"
"// \n"
"// ```\n"
"// vec4 th_fragment(vec4 color);\n"
"// ```\n"
"//  \n"
"// Image fragment function looks like this:\n"
"//  \n"
"// ```\n"
"// vec4 th_fragment(sampler2D tex, vec2 coord);\n"
"// ```\n"
"//  \n"
"// where tex is the texture and coord are the texture coordinates. Be aware to\n"
"// swap the output of the `texture2D` function. Example:\n"
"// \n"
"// ```\n"
"// texture2D(tex, coord).abgr\n"
"// ```\n"
"type Shader* = struct {\n"
"\thandle: int\n"
"}\n"
"\n"
"const (\n"
"\tdefaultImageShader* = Shader{1}\n"
"\tdefaultCanvasShader* = Shader{2}\n"
")\n"
"\n"
"// Represents a GLSL uniform.\n"
"type Uniform* = struct {\n"
"\ts: Shader\n"
"\tl: uint\n"
"}\n"
"\n"
"fn umth_shader_compile_canvas(vertex, fragment: str): int\n"
"// Compiles a canvas shader from source. If there is a compilation error, it\n"
"// will print something to the console.\n"
"fn mkCanvas*(vertex, fragment: str): Shader {\n"
"\treturn Shader{umth_shader_compile_canvas(vertex, fragment)}\n"
"}\n"
"\n"
"fn umth_shader_compile_image(vertex, fragment: str): int\n"
"// Compiles an image shader from source. If there is a compilation error, it\n"
"// will print something to the console.\n"
"fn mkImage*(vertex, fragment: str): Shader {\n"
"\treturn Shader{umth_shader_compile_image(vertex, fragment)}\n"
"}\n"
"\n"
"fn umth_shader_pick_canvas(handle: int)\n"
"// Picks the shader to be used for canvas drawing. Flushes the canvas batch.\n"
"fn (s: ^Shader) pickForCanvas*() {\n"
"\tumth_shader_pick_canvas(s.handle)\n"
"}\n"
"\n"
"fn umth_shader_pick_image(handle: int)\n"
"// Picks the shader to be used for image drawing. Flushes the image batch.\n"
"fn (s: ^Shader) pickForImage*() {\n"
"\tumth_shader_pick_image(s.handle)\n"
"}\n"
"\n"
"fn umth_shader_get_uniform_location(handle: int, name: str): uint\n"
"// Retunrs a uniform by name.\n"
"fn (s: ^Shader) getUniformLocation*(name: str): Uniform {\n"
"\treturn Uniform{s^, umth_shader_get_uniform_location(s.handle, name)}\n"
"}\n"
"\n"
"fn umth_shader_set_uniform_int(shandle, uhandle: uint, value: int)\n"
"// Sets a uniform to an int value. Flushes both batches.\n"
"fn (u: ^Uniform) setInt*(value: int) {\n"
"\tumth_shader_set_uniform_int(u.s.handle, u.l, value)\n"
"}\n"
"\n"
"fn umth_shader_set_uniform_vf2(shandle, uhandle: uint, value: th.Vf2)\n"
"// Sets a uniform to a vf2. Flushes both batches.\n"
"fn (u: ^Uniform) setVf2*(value: th.Vf2) {\n"
"\tumth_shader_set_uniform_vf2(u.s.handle, u.l, value)\n"
"}\n"
"",
"// Color operations. Operate on RGBA uint32 values.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
")\n"
"\n"
"fn umth_hsv2rgb_uint32(h, s, v, a: th.fu): uint32\n"
"\n"
"// Now this is hard to decide, but in my opinion executing a C function,\n"
"//   for the current Umka VM would be much better than implementing it in umka itself.\n"
"// It\'s somewhat less trivial than most other operations like alpha.\n"
"fn umth_rgb_uint32(r, g, b, a: th.fu): uint32\n"
"\n"
"// Converts HSV values into RGBA uint32 color.\n"
"// NOTE: Hue is between 0 and 1\n"
"fn hsv*(h, s, v: th.fu, a: th.fu = 1.0): uint32 {\n"
"\treturn umth_hsv2rgb_uint32(h, s, v, a);\n"
"}\n"
"\n"
"// Sets alpha of the color c to a value in to.\n"
"fn alpha*(c: uint32, to: th.fu): uint32 {\n"
"\treturn (c & 0xFFFFFF00) | (trunc(to * 255) & 0xFF)\n"
"}\n"
"\n"
"// Constructs RGBA uint32 from RGBA of reals.\n"
"fn rgb*(r, g, b: th.fu, a: th.fu = 1.0): uint32 {\n"
"\treturn umth_rgb_uint32(r, g, b, a)\n"
"}\n"
"\n"
"",
"// Builtin collision functions. The ic argument stores the collision position.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"rect.um\"\n"
")\n"
"\n"
"fn umth_coll_line_to_line(b1, e1, b2, e2, ic: ^th.Vf2): bool\n"
"// Checks for a collision between 2 lines specified by their end points.\n"
"fn lineToLine*(b1, e1, b2, e2: th.Vf2, ic: ^th.Vf2): bool {\n"
"\treturn umth_coll_line_to_line(&b1, &e1, &b2, &e2, ic)\n"
"}\n"
"\n"
"fn umth_coll_point_to_quad(p: ^th.Vf2, q: ^th.Quad, ic: ^th.Vf2): bool\n"
"// Checks for a collision between a vf2 and a quad.\n"
"fn vf2ToQuad*(p: th.Vf2, q: th.Quad, ic: ^th.Vf2): bool {\n"
"\treturn umth_coll_point_to_quad(&p, &q, ic)\n"
"}\n"
"\n"
"fn umth_coll_line_to_quad(b, e: ^th.Vf2, q: ^th.Quad, ic: ^th.Vf2): bool\n"
"// Check for a collision between a line and quad edges.\n"
"fn lineToQuad*(b, e: th.Vf2, q: th.Quad, ic: ^th.Vf2): bool {\n"
"\treturn umth_coll_line_to_quad(&b, &e, &q, ic)\n"
"}\n"
"\n"
"fn umth_coll_quad_to_quad(q1, q2: ^th.Quad, ic: ^th.Vf2): bool\n"
"// Check for a collision between two quads.\n"
"fn quadToQuad*(q1, q2: th.Quad, ic: ^th.Vf2): bool {\n"
"\treturn umth_coll_quad_to_quad(&q1, &q2, ic)\n"
"}\n"
"\n"
"",
"import(\"image.um\"; \"th.um\")\n"
"var (\n"
"\ttest*: image.Image\n"
")\n"
"// **INTERNAL**\n"
"fn __setup*() {\n"
"\ttest = image.mk([]uint32{ 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0 }, th.Vf2{ 12, 12 })\n"
"}\n"
"",
};
const char *th_em_modulenames[] = { "anim.um", "audio.um", "csv.um", "ent.um", "image.um", "input.um", "misc.um", "canvas.um", "ray.um", "rect.um", "tilemap.um", "window.um", "ui.um", "std/std.um", "particles.um", "lerp.um", "utf8.um", "font.um", "th.um", "signal.um", "atlas.um", "ui/label.um", "ui/grid.um", "ui/imagebox.um", "shader.um", "color.um", "coll.um", "placeholders.um",  };
int th_em_modulenames_count = 28;
const char *th_em_misc[] = {
"BSD 3-Clause License\n"
"\n"
"Copyright (c) 2021, Marek Maskarinec\n"
"All rights reserved.\n"
"\n"
"Redistribution and use in source and binary forms, with or without\n"
"modification, are permitted provided that the following conditions are met:\n"
"\n"
"1. Redistributions of source code must retain the above copyright notice, this\n"
"   list of conditions and the following disclaimer.\n"
"\n"
"2. Redistributions in binary form must reproduce the above copyright notice,\n"
"   this list of conditions and the following disclaimer in the documentation\n"
"   and/or other materials provided with the distribution.\n"
"\n"
"3. Neither the name of the copyright holder nor the names of its\n"
"   contributors may be used to endorse or promote products derived from\n"
"   this software without specific prior written permission.\n"
"\n"
"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n"
"AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n"
"IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n"
"DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n"
"FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n"
"DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n"
"SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n"
"CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n"
"OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n"
"OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
"",
"v0.8\n"
"",
};
