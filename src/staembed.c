#include "tophat.h" 
const char *th_em_modulesrc[] = {
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"atlas.um\"\n"
")\n"
"\n"
"//~~struct Anim\n"
"// Anim allows you to animate between individual frames of an atlas.\n"
"type Anim* = struct {\n"
"\t// the source atlas\n"
"\tatl: atlas::Atlas\n"
"\t// the first cell of the animation\n"
"\tmin: int\n"
"\t// the last cell of the animation\n"
"\tmax: int\n"
"\tfps: real32\n"
"\t// offset in time\n"
"\toffset: int\n"
"}\n"
"//~~\n"
"\n"
"//~~fn mk\n"
"// `Anim` constructor\n"
"fn mk*(atl: atlas::Atlas, fps: int, min: int = 0, max: int = -1 /* len(atl) - 1 */, offset: int = -1 /* th.time */): Anim {\n"
"//~~\n"
"\tif !atl.i.validate() {\n"
"\t\tth::__error(\"invalid atlas image\")\n"
"\t}\n"
"\n"
"\ta := Anim{}\n"
"\n"
"\ta.atl = atl\n"
"\ta.fps = fps\n"
"\ta.min = min\n"
"\tif max == -1 {\n"
"\t\ta.max = trunc(atl.dm.x * atl.dm.y) - 1\n"
"\t} else {\n"
"\t\ta.max = max\n"
"\t}\n"
"\n"
"\tif offset == -1 {\n"
"\t\ta.offset = th::time\n"
"\t} else {\n"
"\t\ta.offset = offset\n"
"\t}\n"
"\n"
"\treturn a\n"
"}\n"
"\n"
"//~~fn Anim.animate\n"
"// Crops the base atlas to the cell that should be visible at `time`.\n"
"fn (anm: ^Anim) animate*(time: int) {\n"
"//~~\n"
"\tif anm.fps == 0 || anm.max == 0 {\n"
"\t\t\treturn\n"
"\t}\n"
"\n"
"\tn := (round(real(time-anm.offset)/round((1000.0/anm.fps))) % anm.max) + anm.min\n"
"\n"
"\tanm.atl.cropSource(anm.atl.coords(n).item0)\n"
"}\n"
"\n"
"//~~fn Anim.framesPlayed\n"
"// Returns how many frames were played at `time`.\n"
"fn (anm: ^Anim) framesPlayed*(time: int): int {\n"
"//~~\n"
"\treturn trunc((time - anm.offset) / 1000.0 * anm.fps)\n"
"}\n"
"",
"//~~\n"
"// Module for audio loading and playback.\n"
"//~~\n"
"\n"
"import (\n"
"\t\"std.um\"\n"
"\t\"th.um\"\n"
")\n"
"\n"
"//~~opaque Sound\n"
"// Represents an instance of a playable sound. It is an opaque structure.\n"
"type Sound* = struct { _: ^struct{} }\n"
"//~~\n"
"\n"
"var pool: []^Sound\n"
"\n"
"//~~enum LoadFlag\n"
"type LoadFlag* = enum (uint32) {\n"
"\tnone = 0\n"
"\t// Streams the audio, only saving 2 seconds into memory.\n"
"\tstream = 1\n"
"\t// Loads the sound in async. Use `audio.waitForLoad` to wait for the\n"
"\t// sounds to load.\n"
"\tasync = 4\n"
"}\n"
"//~~\n"
"\n"
"fn umth_sound_load(Sound: ^Sound, path: str, flags: LoadFlag): th::ErrCode\n"
"//~~fn load\n"
"// Loads a sounds at path, if there is an error, the underlying pointer\n"
"// will be `NULL` and `validate` will return false.\n"
"fn load*(path: str, flags: LoadFlag = LoadFlag.none): (Sound, std::Err) {\n"
"//~~\n"
"\tvar snd: Sound\n"
"\tec := umth_sound_load(&snd, path, flags)\n"
"\treturn snd, th::__errFromCode(ec)\n"
"}\n"
"\n"
"//~~fn Sound.validate\n"
"// Returns `true` if `s` loaded correctly.\n"
"fn (s: ^Sound) validate*(): bool {\n"
"//~~\n"
"\treturn s._ != null\n"
"}\n"
"\n"
"fn umth_sound_copy(out: ^Sound, s: Sound): th::ErrCode\n"
"//~~fn Sound.copy\n"
"// Copies the sound. This will create another sound which can be configured\n"
"// and played independently from the original sound.\n"
"fn (s: ^Sound) copy*(): (Sound, std::Err) {\n"
"//~~\n"
"\tif !s.validate() {\n"
"\t\tth::__error(\"invalid sound\")\n"
"\t}\n"
"\n"
"\tvar out: Sound\n"
"\tec := umth_sound_copy(&out, s^)\n"
"\treturn out, th::__errFromCode(ec)\n"
"}\n"
"\n"
"fn umth_sound_is_playing(s: Sound): bool\n"
"//~~fn Sound.isPlaying\n"
"// Returns true if the sound is still playing.\n"
"fn (s: ^Sound) isPlaying*(): bool {\n"
"//~~\n"
"\tif !s.validate() {\n"
"\t\tth::__error(\"invalid sound\")\n"
"\t}\n"
"\n"
"\treturn umth_sound_is_playing(s^)\n"
"}\n"
"\n"
"fn umth_sound_play(s: Sound)\n"
"//~~fn Sound.play\n"
"// Plays the sound.\n"
"fn (s: ^Sound) play*() {\n"
"//~~\n"
"\tif !s.validate() {\n"
"\t\tth::__error(\"invalid sound\")\n"
"\t}\n"
"\n"
"\tumth_sound_play(s^)\n"
"}\n"
"\n"
"//~~fn Sound.start\n"
"// The start function allows you to play a single sound multiple times.\n"
"// It will create a copy and return a pointer to it, so you can controll it\n"
"// while it is playing. The returned pointer can be discarded.\n"
"fn (s: ^Sound) start*(): (^Sound, std::Err) {\n"
"//~~\n"
"\tif !s.validate() {\n"
"\t\tth::__error(\"invalid sound\")\n"
"\t}\n"
"\n"
"\tcpyVal, err := s.copy()\n"
"\tif err.code != 0 {\n"
"\t\treturn null, err\n"
"\t}\n"
"\tcpy := new(Sound, cpyVal)\n"
"\tcpy.play()\n"
"\n"
"\tpool = append(pool, cpy)\n"
"\n"
"\treturn cpy, {}\n"
"}\n"
"\n"
"fn umth_sound_stop(s: Sound)\n"
"//~~fn Sound.stop\n"
"// Stops the sound, but keeps the progress. If you want to start from the\n"
"// begginning, use `audio.Sound.seekToFrame(0)`.\n"
"fn (s: ^Sound) stop*() {\n"
"//~~\n"
"\tif !s.validate() {\n"
"\t\tth::__error(\"invalid sound\")\n"
"\t}\n"
"\n"
"\tumth_sound_stop(s^)\n"
"}\n"
"\n"
"fn umth_sound_set_volume(s: Sound, vol: real32)\n"
"//~~fn Sound.setVol\n"
"// Sets the volume as a multiplier of the base volume.\n"
"fn (s: ^Sound) setVol*(vol: real32) {\n"
"//~~\n"
"\tif !s.validate() {\n"
"\t\tth::__error(\"invalid sound\")\n"
"\t}\n"
"\n"
"\tumth_sound_set_volume(s^, vol)\n"
"}\n"
"\n"
"fn umth_sound_set_pan(s: Sound, pan: real32)\n"
"//~~fn Sound.setPan\n"
"// Sets the pan of the sound.\n"
"fn (s: ^Sound) setPan*(pan: real32) {\n"
"//~~\n"
"\tif !s.validate() {\n"
"\t\tth::__error(\"invalid sound\")\n"
"\t}\n"
"\n"
"\tumth_sound_set_pan(s^, pan)\n"
"}\n"
"\n"
"fn umth_sound_set_pitch(s: Sound, pitch: real32)\n"
"//~~fn Sound.setPitch\n"
"// Sets the pitch of the sound.\n"
"fn (s: ^Sound) setPitch*(pitch: real32) {\n"
"//~~\n"
"\tif !s.validate() {\n"
"\t\tth::__error(\"invalid sound\")\n"
"\t}\n"
"\n"
"\tumth_sound_set_pitch(s^, pitch)\n"
"}\n"
"\n"
"fn umth_sound_set_looping(s: Sound, looping: bool)\n"
"//~~fn Sound.setLooping\n"
"// Sets whether the sound will loop upon finishing.\n"
"fn (s: ^Sound) setLooping*(looping: bool) {\n"
"//~~\n"
"\tif !s.validate() {\n"
"\t\tth::__error(\"invalid sound\")\n"
"\t}\n"
"\n"
"\tumth_sound_set_looping(s^, looping)\n"
"}\n"
"\n"
"fn umth_sound_seek_to_frame(s: Sound, frame: uint)\n"
"//~~fn Sound.seekToFrame\n"
"// Seeks to a specified PCM frame.\n"
"fn (s: ^Sound) seekToFrame*(frame: uint) {\n"
"//~~\n"
"\tif !s.validate() {\n"
"\t\tth::__error(\"invalid sound\")\n"
"\t}\n"
"\n"
"\tumth_sound_seek_to_frame(s^, frame)\n"
"}\n"
"\n"
"fn umth_sound_frame_count(s: Sound): uint\n"
"//~~fn Sound.frameCount\n"
"// Returns length of the sound in PCM frames.\n"
"fn (s: ^Sound) frameCount*(): uint {\n"
"//~~\n"
"\tif !s.validate() {\n"
"\t\tth::__error(\"invalid sound\")\n"
"\t}\n"
"\n"
"\treturn umth_sound_frame_count(s^)\n"
"}\n"
"\n"
"fn umth_sound_length_ms(s: Sound): uint\n"
"//~~fn Sound.lengthMs\n"
"// Returns length of the sound in ms.\n"
"fn (s: ^Sound) lengthMs*(): uint {\n"
"//~~\n"
"\tif !s.validate() {\n"
"\t\tth::__error(\"invalid sound\")\n"
"\t}\n"
"\n"
"\treturn umth_sound_length_ms(s^)\n"
"}\n"
"\n"
"fn umth_sound_set_start_time_ms(s: Sound, t: uint)\n"
"//~~fn Sound.setStartTimeMs\n"
"fn (s: ^Sound) setStartTimeMs*(t: uint) {\n"
"//~~\n"
"\tif !s.validate() {\n"
"\t\tth::__error(\"invalid sound\")\n"
"\t}\n"
"\n"
"\tumth_sound_set_start_time_ms(s^, t)\n"
"}\n"
"\n"
"fn umth_sound_set_stop_time_ms(s: Sound, t: uint)\n"
"//~~fn Sound.setStopTimeMs\n"
"fn (s: ^Sound) setStopTimeMs*(t: uint) {\n"
"//~~\n"
"\tif !s.validate() {\n"
"\t\tth::__error(\"invalid sound\")\n"
"\t}\n"
"\n"
"\tumth_sound_set_stop_time_ms(s^, t)\n"
"}\n"
"\n"
"// **INTERNAL**\n"
"fn __setup*() {\n"
"\tpool = []^Sound{}\n"
"}\n"
"\n"
"// **INTERNAL**\n"
"fn __cycle*() {\n"
"\tfor i:=0; i >= 0 && i < len(pool); i++ {\n"
"\t\tif !pool[i].isPlaying() {\n"
"\t\t\tpool = delete(pool, i)\n"
"\t\t\ti--\n"
"\t\t}\n"
"\t}\n"
"}\n"
"",
"//~~\n"
"// A CSV parser, which also works for similar formats. It doesn\'t support\n"
"// quotes, but you can escape characters using a backslash.\n"
"//~~\n"
"\n"
"//~~fn parse\n"
"// Parses input into a 2d string array.\n"
"fn parse*(inp: str, sep: char = \',\'): [][]str {\n"
"//~~\n"
"\tout := [][]str{}\n"
"\trow := []str{}\n"
"\tstart := 0\n"
"\tacc := \"\"\n"
"\tl := len(inp)\n"
"\tskipnext := false\n"
"\n"
"\tfor i,c in inp {\n"
"\t\tif skipnext { skipnext = false; continue }\n"
"\n"
"\t\tif c == \'\\\\\' {\n"
"\t\t\tacc += slice(inp, start, i)\n"
"\t\t\tstart = i + 1\n"
"\t\t\tskipnext = true\n"
"\t\t} else if c == \'\\r\' {\n"
"\t\t\tacc += slice(inp, start, i)\n"
"\t\t\tstart = i + 1\n"
"\t\t} else if c == \'\\n\' {\n"
"\t\t\tacc += slice(inp, start, i)\n"
"\t\t\tstart = i + 1\n"
"\n"
"\t\t\trow = append(row, acc)\n"
"\t\t\tout = append(out, row)\n"
"\n"
"\t\t\tacc = \"\"\n"
"\t\t\trow = []str{}\n"
"\n"
"\t\t} else if c == sep {\n"
"\t\t\tacc += slice(inp, start, i)\n"
"\t\t\tstart = i + 1\n"
"\n"
"\t\t\trow = append(row, acc)\n"
"\t\t\tacc = \"\"\n"
"\t\t}\n"
"\t}\n"
"\n"
"\tif start < l {\n"
"\t\trow = append(row, acc + slice(inp, start, l))\n"
"\t}\n"
"\n"
"\tif len(row) > 0 {\n"
"\t\tout = append(out, row)\n"
"\t}\n"
"\n"
"\treturn out\n"
"}\n"
"\n"
"fn escapeStr(s: str, sep: char): str {\n"
"\to := \"\"\n"
"\n"
"\tfor i,c in s {\n"
"\t\tif c == sep || c == \'\\n\' || c == \'\\\\\' {\n"
"\t\t\to += \"\\\\\"\n"
"\t\t}\n"
"\t\to += str(c)\n"
"\t}\n"
"\n"
"\treturn o\n"
"}\n"
"\n"
"//~~fn encode\n"
"// Converts 2d array to csv string.\n"
"fn encode*(inp: [][]str, sep: char = \',\'): str {\n"
"//~~\n"
"\to := \"\"\n"
"\n"
"\tfor i in inp {\n"
"\t\tfor j in inp[i] {\n"
"\t\t\to += escapeStr(inp[i][j], sep)\n"
"\t\t\tif j < len(inp[i]) - 1 { o += sep }\n"
"\t\t}\n"
"\t\to += \"\\n\"\n"
"\t}\n"
"\n"
"\treturn o\n"
"}\n"
"\n"
"",
"\n"
"import (\n"
"\t\"rect.um\"\n"
"\t\"image.um\"\n"
"\t\"th.um\"\n"
")\n"
"\n"
"//~~struct Ent\n"
"// Entity is the main game object. It features drawing and collisions.\n"
"// Every entity has an image used for drawing and a rectangle used\n"
"// for collisions. It also has a transform used for transforming it\'s image\n"
"// and rectangle.\n"
"type Ent* = struct {\n"
"\t// used as a collider, used as backup when invalid image is supplied\n"
"\tr: rect::Rect\n"
"\t// used in drawing\n"
"\ti: image::Image\n"
"\t// used to transform and translate the image and rect\n"
"\tt: th::Transform\n"
"\t// used as a color of the rect and a color filter for the image\n"
"\tc: uint32\n"
"}\n"
"//~~\n"
"\n"
"//~~struct Coll\n"
"// Value returned by get coll. It contains a position where the collision\n"
"// happened and the index of the entity involved in said collision.\n"
"type Coll* = struct {\n"
"\tindex: th::uu\n"
"\tpos: th::Vf2\n"
"}\n"
"//~~\n"
"\n"
"fn umth_ent_draw(e: ^Ent)\n"
"//~~fn Ent.draw\n"
"// Draws the entity onto the screen.\n"
"fn (e: ^Ent) draw*() {\n"
"//~~\n"
"\tumth_ent_draw(e)\n"
"}\n"
"\n"
"//~~fn mk\n"
"// ent\'s constructor\n"
"fn mk*(img: image::Image = image::Image{}, t: th::Transform = th::Transform{ s: {1, 1} }): Ent {\n"
"//~~\n"
"\tvar e: Ent\n"
"\te.i = img\n"
"\te.t = t\n"
"\tif img.validate() {\n"
"\t\tdm := img.getDims()\n"
"\t\te.r.w = dm.x\n"
"\t\te.r.h = dm.y\n"
"\t}\n"
"\te.c = th::white\n"
"\n"
"\tif t.s.x == 0 && t.s.y == 0 {\n"
"\t\tt.s = { 1, 1 }\n"
"\t}\n"
"\n"
"\treturn e\n"
"}\n"
"\n"
"fn umth_ent_getcoll(maxcolls: uint, e: ^Ent, s: ^[]^Ent, t: ^void): []Coll\n"
"//~~fn Ent.getColl\n"
"// Checks collisions of e with entities in s. Checks at max maxColl collisions.\n"
"// If s contains e, the collision won\'t be returned.\n"
"fn (e: ^Ent) getColl*(s: []^Ent, maxColls: th::uu): []Coll {\n"
"//~~\n"
"\tif len(s) == 0 {\n"
"\t\treturn []Coll{}\n"
"\t}\n"
"\n"
"\treturn umth_ent_getcoll(maxColls, e, &s, typeptr([]Coll))\n"
"}\n"
"\n"
"//~~fn Ent.animate\n"
"// Animates the entity\'s image with one of the `anim` array. <b>Won\'t</b> begin on\n"
"// the first frame. If you want that, use anim.Anim.\n"
"fn (e: ^Ent) animate*(fps: int, frames: ^[]image::Image, t: int) {\n"
"//~~\n"
"\tif len(frames^) == 0 {\n"
"\t\treturn\n"
"\t}\t\n"
"\n"
"\te.i = frames^[(round(real(t)/(1000/fps)) % len(frames^))]\n"
"}\n"
"\n"
"",
"import (\n"
"\t\"rect.um\"\n"
"\t\"std.um\"\n"
"\t\"th.um\"\n"
")\n"
"\n"
"//~~opaque Image\n"
"// Represents a drawable image. It is an opaque structure.\n"
"// Images support a color filter. It is applied by multiplying the color\n"
"// of each pixel with the filter.\n"
"type Image* = struct{ _: ^struct{} }\n"
"//~~\n"
"\n"
"//~~opaque RenderTarget\n"
"// An image you can render to.\n"
"type RenderTarget* = struct { _: ^struct{} }\n"
"//~~\n"
"\n"
"fn umth_image_create_render_target(ret: ^RenderTarget, width: int, height: int, filter: int): th::ErrCode\n"
"//~~fn createRenderTarget\n"
"// Creates a render target you can draw to, like to a window.\n"
"// Filter specifies specfifies filtering for resulting image.\n"
"// Image can be retrieved via `toImage`.\n"
"fn createRenderTarget*(size: th::Vf2, filter: int): (RenderTarget, std::Err) {\n"
"//~~\n"
"\trt := RenderTarget{}\n"
"\tec := umth_image_create_render_target(&rt, trunc(size.x), trunc(size.y), filter)\n"
"\treturn rt, th::__errFromCode(ec)\n"
"}\n"
"\n"
"fn umth_image_render_target_begin(rt: RenderTarget): th::ErrCode\n"
"//~~fn RenderTarget.end\n"
"// Begins the render target rendering pass.\n"
"fn (rt: ^RenderTarget) begin*(): std::Err {\n"
"//~~\n"
"\tec := umth_image_render_target_begin(rt^)\n"
"\treturn th::__errFromCode(ec)\n"
"}\n"
"\n"
"fn umth_image_render_target_end(rt: RenderTarget, wp: th::Vf2): th::ErrCode\n"
"//~~fn RenderTarget.end\n"
"// Ends the render target rendering pass.\n"
"fn (rt: ^RenderTarget) end*(wp: th::Vf2): std::Err {\n"
"//~~\n"
"\tec := umth_image_render_target_end(rt^, wp)\n"
"\treturn th::__errFromCode(ec)\n"
"}\n"
"\n"
"fn umth_image_render_target_to_image(rt: RenderTarget): Image\n"
"//~~fn RenderTarget.toImage\n"
"// Returns the image of the render target. The resulting image has the same\n"
"// lifetime as the base RenderTarget. If you need to use it past the lifetime\n"
"// of the RenderTarget, use the copy method.\n"
"// Do not call `setfilter` on the resulting image.\n"
"fn (rt: ^RenderTarget) toImage*(): Image {\n"
"//~~\n"
"\treturn umth_image_render_target_to_image(rt^)\n"
"}\n"
"\n"
"fn umth_image_load(ret: ^Image, path: str): th::ErrCode\n"
"//~~fn load\n"
"// Loads an image at path.\n"
"fn load*(path: str): (Image, std::Err) {\n"
"//~~\n"
"\timg := Image{}\n"
"\tec := umth_image_load(&img, path)\n"
"\treturn img, th::__errFromCode(ec)\n"
"}\n"
"\n"
"//~~fn Image.validate\n"
"// Returns true, if i\'s handle points to an image.\n"
"fn (i: ^Image) validate*(): bool {\n"
"//~~\n"
"\treturn i._ != null\n"
"}\n"
"\n"
"fn umth_image_flipv(i: Image, f: bool)\n"
"//~~fn Image.flipv\n"
"// Flips image on it\'s vertical axis.\n"
"fn (i: ^Image) flipv*(flip: bool) {\n"
"//~~\n"
"\tif !i.validate() {\n"
"\t\tth::__error(\"image is invalid\")\n"
"\t}\n"
"\n"
"\tumth_image_flipv(i^, flip)\n"
"}\n"
"\n"
"fn umth_image_fliph(i: Image, f: bool)\n"
"//~~fn Image.fliph\n"
"// Flips image on it\'s horizontal axis.\n"
"fn (i: ^Image) fliph*(flip: bool) {\n"
"//~~\n"
"\tif !i.validate() {\n"
"\t\tth::__error(\"image is invalid\")\n"
"\t}\n"
"\n"
"\tumth_image_fliph(i^, flip)\n"
"}\n"
"\n"
"fn umth_image_draw(img: Image, t: th::Transform, color: uint32)\n"
"//~~fn Image.draw\n"
"// Draws the image in screen coordinates. It transforms it with t and\n"
"// applies color as a color filter.\n"
"fn (i: ^Image) draw*(t: th::Transform, color: uint32 = th::white) {\n"
"//~~\n"
"\tif !i.validate() {\n"
"\t\tth::__error(\"image is invalid\")\n"
"\t}\n"
"\n"
"\tumth_image_draw(i^, t, color)\n"
"}\n"
"\n"
"fn umth_image_blit(img: Image, src, dest: rect::Rect, color: uint32, rot: th::fu, origin: th::Vf2)\n"
"//~~fn Image.blit\n"
"// Copies source rectangle (texture coordinates) to destination rectangle (screen coordinates).\n"
"fn (i: ^Image) blit*(src, dest: rect::Rect, color: uint32 = 0xFFFFFFFF, rot: th::fu = 0, origin: th::Vf2 = {0, 0}) {\n"
"//~~\n"
"\tumth_image_blit(i^, src, dest, color, rot, origin)\n"
"}\n"
"\n"
"fn umth_image_draw_nine_patch(img: Image, outer, inner, dest: rect::Rect,\n"
"\tcolor: uint32, scale: real)\n"
"//~~fn Image.drawNinepatch\n"
"// Draws \"nine-patch\" image.\n"
"// `outer` specifies the texture coordinates of the outer rect of source image,\n"
"// `inner` specifies coordinates of inner rect of source image, positioned relative to `outer`.\n"
"// You can tint with `color`.\n"
"//\n"
"// ![](img/ninepatch.png)\n"
"fn (i: ^Image) drawNinepatch*(outer, inner, dest: rect::Rect, color: uint32 = th::white, scale: real = 1.0) {\n"
"//~~\n"
"\tif !i.validate() {\n"
"\t\tth::__error(\"image is invalid\")\n"
"\t}\n"
"\n"
"\tumth_image_draw_nine_patch(i^, outer, inner, dest, color, scale)\n"
"}\n"
"\n"
"fn umth_image_draw_on_quad(img: Image, color: uint32, q: th::Quad)\n"
"//~~fn Image.drawOnQuad\n"
"// Draws the image on top of a quad with corners of the image positioned\n"
"// on the verticies of the quad.\n"
"fn (i: ^Image) drawOnQuad*(q: th::Quad, color: uint32 = th::white) {\n"
"//~~\n"
"\tif !i.validate() {\n"
"\t\tth::__error(\"image is invalid\")\n"
"\t}\n"
"\n"
"\tumth_image_draw_on_quad(i^, color, q)\n"
"}\n"
"\n"
"fn umth_image_get_dims(i: Image): th::Vf2\n"
"//~~fn Image.getDims\n"
"// Returns width and heigth.\n"
"fn (i: ^Image) getDims*(): th::Vf2 {\n"
"//~~\n"
"\tif !i.validate() {\n"
"\t\tth::__error(\"image is invalid\")\n"
"\t}\n"
"\n"
"\treturn umth_image_get_dims(i^)\n"
"}\n"
"\n"
"fn umth_image_crop(img: Image, tl, br: th::Vf2)\n"
"//~~fn Image.crop\n"
"// Crops an image. Coordinates are between 0, 0 (top left) and\n"
"// 1, 1 (bottom right)\n"
"fn (i: ^Image) crop*(tl, br: th::Vf2) {\n"
"//~~\n"
"\tif !i.validate() {\n"
"\t\tth::__error(\"image is invalid\")\n"
"\t}\n"
"\n"
"\tumth_image_crop(i^, tl, br)\n"
"}\n"
"\n"
"//~~fn Image.cropPx\n"
"// Same as `Image.crop`, but the positions are in pixels.\n"
"fn (i: ^Image) cropPx*(tr, br: th::Vf2) {\n"
"//~~\n"
"\tif !i.validate() {\n"
"\t\tth::__error(\"image is invalid\")\n"
"\t}\n"
"\n"
"\tdm := i.getDims()\n"
"\tumth_image_crop(i^, tr.div(dm), br.div(dm))\n"
"}\n"
"\n"
"//~~fn Image.cropRect\n"
"// Same as `Image.crop`, but uses a rect instead of two positions.\n"
"fn (i: ^Image) cropRect*(r: rect::Rect) {\n"
"//~~\n"
"\tif !i.validate() {\n"
"\t\tth::__error(\"image is invalid\")\n"
"\t}\n"
"\n"
"\tdm := i.getDims()\n"
"\tumth_image_crop(i^, r.getPos().div(dm), r.getEnd().div(dm))\n"
"}\n"
"\n"
"fn umth_image_crop_quad(img: Image, q: th::Quad)\n"
"//~~fn Image.cropQuad\n"
"// Crop an image using a quad.\n"
"fn (i: ^Image) cropQuad*(q: th::Quad) {\n"
"//~~\n"
"\tif !i.validate() {\n"
"\t\tth::__error(\"image is invalid\")\n"
"\t}\n"
"\n"
"\tumth_image_crop_quad(i^, q)\n"
"}\n"
"\n"
"fn umth_image_get_crop_quad(img: Image): th::Quad\n"
"//~~fn Image.getCropQuad\n"
"// Crop an image using a quad.\n"
"fn (i: ^Image) getCropQuad*(): th::Quad {\n"
"//~~\n"
"\tif !i.validate() {\n"
"\t\tth::__error(\"image is invalid\")\n"
"\t}\n"
"\n"
"\treturn umth_image_get_crop_quad(i^)\n"
"}\n"
"\n"
"fn umth_image_from_data(ret: ^Image, data: ^uint32, dm: th::Vf2): th::ErrCode\n"
"//~~fn mk\n"
"// Creates an image from raw data.\n"
"fn mk*(data: []uint32, dm: th::Vf2): (Image, std::Err) {\n"
"//~~\n"
"\timg := Image{}\n"
"\tec := umth_image_from_data(&img, &data[0], dm)\n"
"\n"
"\treturn img, th::__errFromCode(ec)\n"
"}\n"
"\n"
"fn umth_image_copy(ret: ^Image, data: Image): th::ErrCode\n"
"//~~fn Image.copy\n"
"// Copies image into a new one.\n"
"fn (i: ^Image) copy*(): (Image, std::Err) {\n"
"//~~\n"
"\tif !i.validate() {\n"
"\t\tth::__error(\"image is invalid\")\n"
"\t}\n"
"\n"
"\timg := Image{}\n"
"\tec := umth_image_copy(&img, i^)\n"
"\n"
"\treturn img, th::__errFromCode(ec)\n"
"}\n"
"\n"
"fn umth_image_set_filter(data: Image, filter: int): th::ErrCode\n"
"//~~fn Image.setfilter\n"
"// Sets a mag/min filter. 0 is nearest, others are linear.\n"
"// This function will regenerate the texture. This means it shouldn\'t be\n"
"// used in a loop.\n"
"// https://learnopengl.com/img/getting-started/texture_filtering.png\n"
"// left is nearest, right is linear.\n"
"fn (i: ^Image) setfilter*(filter: int): std::Err {\n"
"//~~\n"
"\tif !i.validate() {\n"
"\t\tth::__error(\"image is invalid\")\n"
"\t}\n"
"\n"
"\treturn th::__errFromCode(umth_image_set_filter(i^, filter))\n"
"}\n"
"\n"
"fn umth_image_update_data(img: Image, data: ^uint32, dm: th::Vf2): th::ErrCode\n"
"//~~fn Image.setData\n"
"// Updates the image data. dm are the dimensions of the new image.\n"
"// The new image doesn\'t have to be the same size as the old one.\n"
"fn (i: ^Image) setData*(data: []uint32, dm: th::Vf2): std::Err {\n"
"//~~\n"
"\tif !i.validate() {\n"
"\t\tth::__error(\"image is invalid\")\n"
"\t\treturn {}\n"
"\t}\n"
"\n"
"\tif dm.x * dm.y != len(data) {\n"
"\t\treturn th::__errFromCode(.bad_input, \"incorrect dimensions\")\n"
"\t}\n"
"\n"
"\treturn th::__errFromCode(umth_image_update_data(i^, &data[0], dm))\n"
"}\n"
"\n"
"fn umth_image_get_data(img: Image, data: ^uint32)\n"
"//~~fn Image.getData\n"
"// Gets the image data. This downloads the data from the GPU on **each call**.\n"
"// Don\'t use in performance critical sections.\n"
"fn (i: ^Image) getData*(): []uint32 {\n"
"//~~\n"
"\tif !i.validate() {\n"
"\t\tth::__error(\"image is invalid\")\n"
"\t}\n"
"\n"
"\tbuf := make([]uint32, trunc(i.getDims().x * i.getDims().y))\n"
"\tif len(buf) == 0 {\n"
"\t\treturn buf\n"
"\t}\n"
"\n"
"\tumth_image_get_data(i^, &buf[0])\n"
"\n"
"\treturn buf\n"
"}\n"
"",
"//~~\n"
"// Module for getting keyboard and mouse input.\n"
"// is* functions return info based on a us QWERTY layout. They are supposed to\n"
"// be used for game controls. For text input use getStr.\n"
"//~~\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"window.um\"\n"
")\n"
"\n"
"//~~Keycode constants\n"
"type Key* = enum {\n"
"\tmouse1         = 1   // NOTE: mouse 2 and 3 key codes are swapped\n"
"\tmouse2         = 3   //       because sokol uses 3 for middle mouse\n"
"\tmouse3         = 2   //       button.\n"
"\n"
"\tctrl           = 16\n"
"\tshift          = 17\n"
"\talt            = 18\n"
"\n"
"\tspace          = 32\n"
"\tapostrophe     = 39  /* \' */\n"
"\tcomma          = 44  /* , */\n"
"\tminus          = 45  /* - */\n"
"\tdot            = 46  /* . */\n"
"\tslash          = 47  /* / */\n"
"\tnum0           = 48\n"
"\tnum1           = 49\n"
"\tnum2           = 50\n"
"\tnum3           = 51\n"
"\tnum4           = 52\n"
"\tnum5           = 53\n"
"\tnum6           = 54\n"
"\tnum7           = 55\n"
"\tnum8           = 56\n"
"\tnum9           = 57\n"
"\tsemicolon      = 59  /* ; */\n"
"\tequal          = 61  /* = */\n"
"\ta              = 65\n"
"\tb              = 66\n"
"\tc              = 67\n"
"\td              = 68\n"
"\te              = 69\n"
"\tf              = 70\n"
"\tg              = 71\n"
"\th              = 72\n"
"\ti              = 73\n"
"\tj              = 74\n"
"\tk              = 75\n"
"\tl              = 76\n"
"\tm              = 77\n"
"\tn              = 78\n"
"\to              = 79\n"
"\tp              = 80\n"
"\tq              = 81\n"
"\tr              = 82\n"
"\ts              = 83\n"
"\tt              = 84\n"
"\tu              = 85\n"
"\tv              = 86\n"
"\tw              = 87\n"
"\tx              = 88\n"
"\ty              = 89\n"
"\tz              = 90\n"
"\tleftBracket    = 91  /* [ */\n"
"\tbackslash      = 92  /* \\ */\n"
"\trightBracket   = 93  /* ] */\n"
"\tgraveAccent    = 96  /* ` */\n"
"\tworld1         = 161 /* non-US #1 */\n"
"\tworld2         = 162 /* non-US #2 */\n"
"\tescape         = 256\n"
"\tenter          = 257\n"
"\ttab            = 258\n"
"\tbackspace      = 259\n"
"\tinsert         = 260\n"
"\tdelete         = 261\n"
"\tright          = 262\n"
"\tleft           = 263\n"
"\tdown           = 264\n"
"\tup             = 265\n"
"\tpageUp         = 266\n"
"\tpageDown       = 267\n"
"\thome           = 268\n"
"\tend            = 269\n"
"\tcapsLock       = 280\n"
"\tscrollLock     = 281\n"
"\tnumLock        = 282\n"
"\tprintScreen    = 283\n"
"\tpause          = 284\n"
"\tfn0            = 289\n"
"\tfn1            = 290\n"
"\tfn2            = 291\n"
"\tfn3            = 292\n"
"\tfn4            = 293\n"
"\tfn5            = 294\n"
"\tfn6            = 295\n"
"\tfn7            = 296\n"
"\tfn8            = 297\n"
"\tfn9            = 298\n"
"\tfn10           = 299\n"
"\tfn11           = 300\n"
"\tfn12           = 301\n"
"\tfn13           = 302\n"
"\tfn14           = 303\n"
"\tfn15           = 304\n"
"\tfn16           = 305\n"
"\tfn17           = 306\n"
"\tfn18           = 307\n"
"\tfn19           = 308\n"
"\tfn20           = 309\n"
"\tfn21           = 310\n"
"\tfn22           = 311\n"
"\tfn23           = 312\n"
"\tfn24           = 313\n"
"\tfn25           = 314\n"
"\tkp0            = 320\n"
"\tkp1            = 321\n"
"\tkp2            = 322\n"
"\tkp3            = 323\n"
"\tkp4            = 324\n"
"\tkp5            = 325\n"
"\tkp6            = 326\n"
"\tkp7            = 327\n"
"\tkp8            = 328\n"
"\tkp9            = 329\n"
"\tkpDecimal      = 330\n"
"\tkpDivide       = 331\n"
"\tkpMultiply     = 332\n"
"\tkpSubtract     = 333\n"
"\tkpAdd          = 334\n"
"\tkpEnter        = 335\n"
"\tkpEqual        = 336\n"
"\tleftShift      = 340\n"
"\tleftControl    = 341\n"
"\tleftAlt        = 342\n"
"\tleftSuper      = 343\n"
"\trightShift     = 344\n"
"\trightControl   = 345\n"
"\trightAlt       = 346\n"
"\trightSuper     = 347\n"
"\tmenu           = 348\n"
"}\n"
"//~~\n"
"\n"
"//~~Gamepad button number\n"
"type GamepadButton* = enum {\n"
"\ta\n"
"\tb\n"
"\tx\n"
"\ty\n"
"\tlt\n"
"\trt\n"
"\tlb\n"
"\trb\n"
"\tselect\n"
"\tstart\n"
"\tup\n"
"\tdown\n"
"\tleft\n"
"\tright\n"
"\tlstick\n"
"\trstick\n"
"\t_count\n"
"}\n"
"//~~\n"
"\n"
"//~~Gamepad stick number\n"
"type GamepadStick* = enum {\n"
"\tleft\n"
"\tright\n"
"}\n"
"//~~\n"
"\n"
"type Gamepad* = struct {\n"
"\tid: int\n"
"}\n"
"\n"
"fn toupper(c: char): int {\n"
"\tif c >= \'a\' && c <= \'z\' {\n"
"\t\treturn int(c) - 32;\n"
"\t}\n"
"\treturn int(c);\n"
"}\n"
"\n"
"fn umth_input_get_mouse(): th::Vf2\n"
"//~~fn getMousePos\n"
"// Returns the position of mouse cursor in relation to the screen.\n"
"fn getMousePos*(): th::Vf2 {\n"
"//~~\n"
"\treturn umth_input_get_mouse()\n"
"}\n"
"\n"
"//~~fn getGlobalMousePos\n"
"// Returns the position of mouse cursor in relation to cam.\n"
"fn getGlobalMousePos*(): th::Vf2 {\n"
"//~~\n"
"\treturn getMousePos().add(window::getViewportOffset())\n"
"}\n"
"\n"
"fn umth_input_is_pressed(key: Key): bool\n"
"//~~fn isPressed\n"
"// Returns true if key is pressed. Either use codes defined in the file above,\n"
"// or pass lower case char/number.\n"
"fn isPressed*(code: Key): bool {\n"
"//~~\n"
"\treturn umth_input_is_pressed(code)\n"
"}\n"
"\n"
"//~~fn isPressedc\n"
"// Like `isPressed`, but you can pass char as the code.\n"
"fn isPressedc*(code: char): bool {\n"
"//~~\n"
"\treturn isPressed(Key(toupper(code)))\n"
"}\n"
"\n"
"fn umth_input_is_just_pressed(key: Key): bool\n"
"//~~fn isJustPressed\n"
"// Returns, whether code was just pressed this loop.\n"
"fn isJustPressed*(code: Key): bool {\n"
"//~~\n"
"\treturn umth_input_is_just_pressed(code)\n"
"}\n"
"\n"
"//~~fn isJustPressedc\n"
"// Like `isJustPressed`, but you can pass char as the code.\n"
"fn isJustPressedc*(code: char): bool {\n"
"//~~\n"
"\treturn isJustPressed(Key(toupper(code)))\n"
"}\n"
"\n"
"fn umth_input_is_pressed_repeat(key: Key): bool\n"
"//~~fn isPressedRepeat\n"
"// Returns, whether code was just pressed this loop, with key repeat.\n"
"fn isPressedRepeat*(code: Key): bool {\n"
"//~~\n"
"\treturn umth_input_is_pressed_repeat(code)\n"
"}\n"
"\n"
"//~~fn isPressedRepeatc\n"
"// Like `isPressedRepeat`, but you can pass char as the code.\n"
"fn isPressedRepeatc*(code: char): bool {\n"
"//~~\n"
"\treturn isPressedRepeat(Key(toupper(code)))\n"
"}\n"
"\n"
"fn umth_input_is_just_released(key: Key): bool\n"
"//~~fn isJustReleased\n"
"// Returns true if a key was just released.\n"
"fn isJustReleased*(code: Key): bool {\n"
"//~~\n"
"\treturn umth_input_is_just_released(code)\n"
"}\n"
"\n"
"//~~fn isJustReleasedc\n"
"// Like `isJustReleased`, but you can pass char as the code.\n"
"fn isJustReleasedc*(code: char): bool {\n"
"//~~\n"
"\treturn isJustReleased(Key(toupper(code)))\n"
"}\n"
"\n"
"fn umth_input_clear*(code: Key)\n"
"//~~fn clear\n"
"// Clears both the pressed and justPressed state of a code.\n"
"fn clear*(code: Key) {\n"
"//~~\n"
"\tumth_input_clear(code)\n"
"}\n"
"\n"
"//~~fn clearc\n"
"// Like `clear`, but you can pass char as the code.\n"
"fn clearc*(code: char) {\n"
"//~~\n"
"\tumth_input_clear(Key(toupper(code)))\n"
"}\n"
"\n"
"fn umth_input_get_str(): str\n"
"//~~fn getStr\n"
"// Returns a string entered by the user in the last cycle.\n"
"fn getStr*(): str {\n"
"//~~\n"
"\treturn umth_input_get_str()\n"
"}\n"
"\n"
"fn umth_input_get_mouse_delta(): th::Vf2\n"
"//~~fn getMouseDelta\n"
"// Returns the difference between mouse positions in the last cycle. Will work\n"
"// even if `window.freezeCursor` is enabled.\n"
"fn getMouseDelta*(): th::Vf2 {\n"
"//~~\n"
"\treturn umth_input_get_mouse_delta()\n"
"}\n"
"\n"
"fn umth_input_get_mouse_scroll(): th::Vf2\n"
"//~~fn getMouseScroll\n"
"// Returns the scroll wheel value\n"
"fn getMouseScroll*(): th::Vf2 {\n"
"//~~\n"
"\treturn umth_input_get_mouse_scroll()\n"
"}\n"
"\n"
"fn umth_input_gamepad_get_gamepads*(): [4]int\n"
"\n"
"//~~fn gamepads\n"
"// Returns a list of gamepads that are currently connected.\n"
"fn gamepads*(): []Gamepad {\n"
"//~~\n"
"\tgamepads := umth_input_gamepad_get_gamepads()\n"
"\n"
"\tresult := []Gamepad{}\n"
"\n"
"\tfor i, p in gamepads {\n"
"\t\tif p >= 0 {\n"
"\t\t\tresult = append(result, Gamepad{p})\n"
"\t\t}\n"
"\t}\n"
"\n"
"\treturn result\n"
"}\n"
"\n"
"fn umth_input_gamepad_get_gamepad*(): int\n"
"\n"
"//~~fn gamepad\n"
"// Returns the connected gamepad.\n"
"fn gamepad*(): Gamepad {\n"
"//~~\n"
"\treturn Gamepad{umth_input_gamepad_get_gamepad()}\n"
"}\n"
"\n"
"fn umth_input_gamepad_is_pressed(gamepad: int, button: GamepadButton): bool\n"
"\n"
"//~~fn isPressed\n"
"// Returns true if the gamepad button is pressed.\n"
"fn (g: ^Gamepad) isPressed*(button: GamepadButton): bool {\n"
"//~~\n"
"\treturn umth_input_gamepad_is_pressed(g.id, button)\n"
"}\n"
"\n"
"fn umth_input_gamepad_is_just_pressed(gamepad: int, button: GamepadButton): bool\n"
"\n"
"//~~fn isJustPressed\n"
"// Returns true if the gamepad button was just pressed.\n"
"fn (g: ^Gamepad) isJustPressed*(button: GamepadButton): bool {\n"
"//~~\n"
"\treturn umth_input_gamepad_is_just_pressed(g.id, button)\n"
"}\n"
"\n"
"fn umth_input_gamepad_is_just_released(gamepad: int, button: GamepadButton): bool\n"
"\n"
"//~~fn isJustReleased\n"
"// Returns true if the gamepad button was just released.\n"
"fn (g: ^Gamepad) isJustReleased*(button: GamepadButton): bool {\n"
"//~~\n"
"\treturn umth_input_gamepad_is_just_released(g.id, button)\n"
"}\n"
"\n"
"fn umth_input_gamepad_pressure(gamepad: int, button: GamepadButton): th::fu\n"
"\n"
"//~~fn pressure\n"
"// Returns the pressure of the gamepad button in the range [0, 1].\n"
"fn (g: ^Gamepad) pressure*(button: GamepadButton): th::fu {\n"
"//~~\n"
"\treturn umth_input_gamepad_pressure(g.id, button)\n"
"}\n"
"\n"
"fn umth_input_gamepad_stick(gamepad: int, stick: GamepadStick): th::Vf2\n"
"\n"
"//~~fn stick\n"
"// Returns the movement of the gamepad stick in the range [-1, 1] for each axis.\n"
"fn (g: ^Gamepad) stick*(stick: GamepadStick): th::Vf2 {\n"
"//~~\n"
"\treturn umth_input_gamepad_stick(g.id, stick)\n"
"}\n"
"\n"
"fn umth_input_gamepad_rumble(gamepad: int, left, right: th::fu)\n"
"\n"
"//~~fn rumble\n"
"// Rumbles/vibrates the gamepad.\n"
"fn (g: ^Gamepad) rumble*(left, right: th::fu) {\n"
"//~~\n"
"\tumth_input_gamepad_rumble(g.id, left, right)\n"
"}\n"
"",
"//~~\n"
"// Misc functions.\n"
"//~~\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"std.um\"\n"
")\n"
"\n"
"//~~fn readall **DEPRECATED**\n"
"// Use std.freadall instaed.\n"
"fn readall*(path: str): str {\n"
"//~~\n"
"\treturn std::freadall(std::fopen(path, \"rb\").item0).item0\n"
"}\n"
"\n"
"//~~fn stepify\n"
"// Snaps a value to step.\n"
"fn stepify*(val, step: th::fu): th::fu {\n"
"//~~\n"
"\tif step != 0 {\n"
"\t\tval = floor(val / step + 0.5) * step\n"
"\t}\n"
"\treturn val\n"
"}\n"
"\n"
"//~~fn maxf\n"
"fn maxf*(a, b: th::fu): th::fu {\n"
"//~~\n"
"\tif a > b { return a }\n"
"\treturn b\n"
"}\n"
"\n"
"//~~fn minf\n"
"fn minf*(a, b: th::fu): th::fu {\n"
"//~~\n"
"\tif a > b { return b }\n"
"\treturn a\n"
"}\n"
"",
"//~~\n"
"// Canvas library allowing for drawing basic shapes. Coordinates are based on\n"
"// the screen.\n"
"//~~\n"
"\n"
"import (\n"
"\t\"misc.um\"\n"
"\t\"rect.um\"\n"
"\t\"th.um\"\n"
")\n"
"\n"
"fn umth_canvas_draw_text(text: str, pos: th::Vf2, color: uint32, size: th::fu)\n"
"//~~fn drawText\n"
"// Draws a basic pixel text. Only ascii is supported.\n"
"fn drawText*(text: str, pos: th::Vf2, color: uint32, size: th::fu) {\n"
"//~~\n"
"\tumth_canvas_draw_text(text, pos, color, size)\n"
"}\n"
"\n"
"//~~fn textSize\n"
"// Returns the size of text taken by an equivalent drawText call.\n"
"fn textSize*(text: str, scale: th::fu): th::Vf2 {\n"
"//~~\n"
"\tvar w, maxw, h: int\n"
"\tw = 0\n"
"\tmaxw = 0\n"
"\th = 1\n"
"\n"
"\tfor i in text {\n"
"\t\tif text[i] == \"\\n\" {\n"
"\t\t\th += 1\n"
"\t\t\tif w > maxw {\n"
"\t\t\t\tmaxw = w\n"
"\t\t\t}\n"
"\t\t\tw = 0\n"
"\n"
"\t\t\tcontinue\n"
"\t\t}\n"
"\n"
"\t\tw++\n"
"\t}\n"
"\n"
"\tif w > maxw {\n"
"\t\tmaxw = w\n"
"\t}\n"
"\n"
"\treturn {maxw * scale * 6 - scale, h * 6 * scale}\n"
"}\n"
"\n"
"type PixelFont = struct { }\n"
"\n"
"fn (p: ^PixelFont) draw*(text: str, pos: th::Vf2, color: uint32, scale: th::fu = 1.0) {\n"
"\tdrawText(text, pos, color, scale)\n"
"}\n"
"\n"
"fn (p: ^PixelFont) measure*(text: str): th::Vf2 {\n"
"\treturn textSize(text, 1)\n"
"}\n"
"\n"
"fn (p: ^PixelFont) validate*(): bool {\n"
"\treturn true\n"
"}\n"
"\n"
"//~~Pixel Font\n"
"// The `pixelFont` variable exposes the canvas pixel font as a generic font.\n"
"var pixelFont*: PixelFont\n"
"//~~\n"
"\n"
"fn umth_canvas_draw_rect(color: uint32, r: rect::Rect)\n"
"//~~fn drawRect\n"
"// Draws a Rectangle.\n"
"fn drawRect*(color: uint32, r: rect::Rect) {\n"
"//~~\n"
"\tumth_canvas_draw_rect(color, r)\n"
"}\n"
"\n"
"fn umth_canvas_draw_line(color: uint32, b, e: th::Vf2, thickness: th::fu)\n"
"//~~fn drawLine\n"
"// Draws a line.\n"
"fn drawLine*(color: uint32, b, e: th::Vf2, thickness: th::fu) {\n"
"//~~\n"
"\tumth_canvas_draw_line(color, b, e, thickness)\n"
"}\n"
"\n"
"fn umth_canvas_draw_rect_lines(color: uint32, r: rect::Rect, thickness: real32)\n"
"//~~fn drawRectLines\n"
"// Draws rect border.\n"
"fn drawRectLines*(color: uint32, r: rect::Rect, thickness: real32 = 1.0) {\n"
"//~~\n"
"\tumth_canvas_draw_rect_lines(color, r, thickness)\n"
"}\n"
"\n"
"fn umth_canvas_draw_quad(color: uint32, q: th::Quad)\n"
"//~~fn drawQuad\n"
"// Draws a convex quad.\n"
"fn drawQuad*(color: uint32, q: th::Quad) {\n"
"//~~\n"
"\tumth_canvas_draw_quad(color, q)\n"
"}\n"
"\n"
"var scissor: []rect::Rect\n"
"\n"
"fn umth_canvas_begin_scissor_rect(r: rect::Rect)\n"
"fn umth_canvas_end_scissor()\n"
"\n"
"fn rectDiff(a, b: rect::Rect): rect::Rect {\n"
"\tx := misc::maxf(a.x, b.x);\n"
"\ty := misc::maxf(a.y, b.y);\n"
"\treturn rect::Rect{\n"
"\t\tx,y,\n"
"\t\tmisc::minf(a.x + a.w, b.x + b.w) - x,\n"
"\t\tmisc::minf(a.y + a.h, b.y + b.h) - y};\n"
"}\n"
"\n"
"//~~fn beginScissorRect\n"
"// Disable rendering outside of rect `r`\n"
"fn beginScissorRect*(r: rect::Rect, debug: bool = false) {\n"
"//~~\n"
"\tr2 := r\n"
"\tif len(scissor) == 0 {\n"
"\t\tscissor = { r }\n"
"\t} else {\n"
"\t\ts := scissor[len(scissor) - 1]\n"
"\t\tr2 = rectDiff(s, r)\n"
"\t\tscissor = append(scissor, r2)\n"
"\t}\n"
"\n"
"\tif debug {\n"
"\t\tdrawRectLines(th::red, r2, 0.1)\n"
"\t}\n"
"\n"
"\tumth_canvas_begin_scissor_rect(r2)\n"
"}\n"
"\n"
"//~~fn endScissor\n"
"// Stops cropping\n"
"fn endScissor*() {\n"
"//~~\n"
"\tif len(scissor) > 0 {\n"
"\t\tscissor = delete(scissor, len(scissor) - 1)\n"
"\t\tif len(scissor) > 0 {\n"
"\t\t\tlast := scissor[len(scissor)-1]\n"
"\t\t\tumth_canvas_begin_scissor_rect(last)\n"
"\t\t} else {\n"
"\t\t\tumth_canvas_end_scissor();\n"
"\t\t}\n"
"\t}\n"
"}\n"
"",
"import (\n"
"\t\"th.um\"\n"
")\n"
"\n"
"//~~struct Rect\n"
"// A set of points representing a rectangle.\n"
"type Rect* = struct {\n"
"\tx, y, w, h: th::fu\n"
"}\n"
"//~~\n"
"\n"
"//~~fn mk\n"
"fn mk*(x, y, w, h: th::fu): Rect {\n"
"//~~\n"
"\tvar r: Rect\n"
"\n"
"\tr.x = x\n"
"\tr.y = y\n"
"\tr.w = w\n"
"\tr.h = h\n"
"\n"
"\treturn r\n"
"}\n"
"\n"
"//~~fn mk\n"
"// Creates a rect from two Vf2s - the position and the dimensions.\n"
"fn fromVf2*(p: th::Vf2, dm: th::Vf2): Rect {\n"
"//~~\n"
"\treturn mk(p.x, p.y, dm.x, dm.y)\n"
"}\n"
"\n"
"//~~fn Rect.getPos\n"
"fn (r: ^Rect) getPos*(): th::Vf2 {\n"
"//~~\n"
"\treturn {r.x, r.y}\n"
"}\n"
"\n"
"//~~fn Rect.getDims\n"
"fn (r: ^Rect) getDims*(): th::Vf2 {\n"
"//~~\n"
"\treturn {r.w, r.h}\n"
"}\n"
"\n"
"//~~fn Rect.getEnd\n"
"// returns where the second point of the rectangle lies.\n"
"fn (r: ^Rect) getEnd*(): th::Vf2 {\n"
"//~~\n"
"\treturn {r.x+r.w, r.y+r.h}\n"
"}\n"
"\n"
"fn umth_transform_rect(r: Rect, t: th::Transform): th::Quad\n"
"//~~fn Rect.transformed\n"
"// Transforms a rect into a quad.\n"
"// Order:\n"
"// \t1. scale\n"
"// \t2. rotation\n"
"// \t3. position\n"
"fn (r: ^Rect) transformed*(t: th::Transform): th::Quad {\n"
"//~~\n"
"\treturn umth_transform_rect(r^, t)\n"
"}\n"
"\n"
"//~~fn Rect.shrink\n"
"// Shrink the rectangle by `p` pixels from all sides.\n"
"fn (r: ^Rect) shrink*(p: th::Vf2): Rect {\n"
"//~~\n"
"\treturn Rect{ r.x + p.x, r.y + p.y, r.w - 2*p.x, r.h - 2*p.y }\n"
"}\n"
"\n"
"//~~fn Rect.shift\n"
"// Shift the rectangle by `p` pixels.\n"
"fn (r: ^Rect) shift*(p: th::Vf2): Rect {\n"
"//~~\n"
"\treturn Rect{ r.x + p.x, r.y + p.y, r.w, r.h }\n"
"}\n"
"\n"
"//~~fn Rect.scale\n"
"// Multiply the dimensions by `p`\n"
"fn (r: ^Rect) scale*(p: th::Vf2): Rect {\n"
"//~~\n"
"\treturn Rect{ r.x, r.y, r.w * p.x, r.h * p.y }\n"
"}\n"
"\n"
"//~~fn Rect.center\n"
"// Returns the position, which is the center of the rect.\n"
"fn (r: ^Rect) center*(): th::Vf2 {\n"
"//~~\n"
"\treturn r.getPos().add(r.getDims().divf(2))\n"
"}\n"
"\n"
"//~~fn Rect.centerWithinRect\n"
"// Centers `child` with the rect `r`.\n"
"fn (r: ^Rect) centerWithinRect*(child: Rect): Rect {\n"
"//~~\n"
"\tchild.x = r.x + (r.w - child.w)/2\n"
"\tchild.y = r.y + (r.h - child.h)/2\n"
"\treturn child\n"
"}\n"
"\n"
"",
"//~~\n"
"// Tilemaps allow for easy level construction and fast collisions. You can even\n"
"// use them for some games instead of entities (tetris comes to mind)\n"
"//~~\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"ent.um\"\n"
"\t\"atlas.um\"\n"
")\n"
"\n"
"//~~Direction constants used for autotile\n"
"const (\n"
"\ttop* = 1\n"
"\tright* = 2\n"
"\tbot* = 4\n"
"\tleft* = 8\n"
")\n"
"//~~\n"
"\n"
"//~~struct Tilemap\n"
"// Tilemap struct\n"
"type Tilemap* = struct {\n"
"\tatlas: atlas::Atlas\n"
"\tpos: th::Vf2\n"
"\tw: th::uu // width of tilemap\n"
"\tcells: []th::uu // all cells (this will draw the tile in tiles with number in cells - 1)\n"
"\tcollMask: []bool // if true, the tile collides\n"
"\tscale: th::fu\n"
"}\n"
"//~~\n"
"\n"
"//~~fn mk\n"
"// Make a tilemap with all cells set to 0.\n"
"fn mk*(w, h: th::uu, at: atlas::Atlas, scale: th::fu = 1): Tilemap {\n"
"//~~\n"
"\tif !at.i.validate() {\n"
"\t\tth::__error(\"invalid atlas\")\n"
"\t}\n"
"\n"
"\tt := Tilemap{}\n"
"\tt.cells = make([]th::uu, w*h)\n"
"\tt.w = w\n"
"\tt.atlas = at\n"
"\tt.collMask = make([]bool, 10) //  TODO\n"
"\tt.scale = scale\n"
"\n"
"\treturn t\n"
"}\n"
"\n"
"//~~fn mk2\n"
"// Make a tilemap from a list of cells.\n"
"fn mk2*(cells: []th::uu, w: th::uu, at: atlas::Atlas, scale: th::fu = 1): Tilemap {\n"
"//~~\n"
"\tif !at.i.validate() {\n"
"\t\tth::__error(\"invalid atlas\")\n"
"\t}\n"
"\n"
"\tt := Tilemap{}\n"
"\tt.cells = cells\n"
"\tt.w = w\n"
"\tt.atlas = at\n"
"\tt.collMask = make([]bool, 10) //  TODO\n"
"\tt.scale = scale\n"
"\n"
"\treturn t\n"
"}\n"
"\n"
"//~~fn Tilemap.has\n"
"// Check if a tile exists at the given coordinates.\n"
"fn (t: ^Tilemap) has*(x, y: int): bool {\n"
"//~~\n"
"\treturn x >= 0 && x < t.w && y >= 0 && y < len(t.cells)/t.w\n"
"}\n"
"\n"
"//~~fn Tilemap.edit\n"
"// Edit a tile in the tilemap.\n"
"fn (t: ^Tilemap) edit*(x, y, tile: int){\n"
"//~~\n"
"\tt.cells[y*t.w + x] = tile\n"
"}\n"
"\n"
"//~~fn Tilemap.get\n"
"// Get a tile from the tilemap.\n"
"fn (t: ^Tilemap) get*(x, y: int): int {\n"
"//~~\n"
"\treturn t.cells[y*t.w + x]\n"
"}\n"
"\n"
"\n"
"fn umth_tilemap_draw(ct: ^Tilemap, tr: th::Transform)\n"
"//~~fn Tilemap.draw\n"
"// Draws the tilemap.\n"
"fn (t: ^Tilemap) draw*(tr: th::Transform) {\n"
"//~~\n"
"\tif len(t.cells) == 0 { return }\n"
"\n"
"\tumth_tilemap_draw(t, tr)\n"
"}\n"
"\n"
"fn umth_tilemap_getcoll(pos: ^th::Vf2, vert: ^th::Vf2, t: ^Tilemap, e: ^ent::Ent): bool\n"
"//~~fn Tilemap.getColl\n"
"// Checks whether `e` collides with any of the tiles in `t`, which are in the\n"
"// collmask.\n"
"//\n"
"// * `ic`[out] - the position where a collision occured\n"
"// * `pos`[out] - coordinates of a tile where a collision occured\n"
"//\n"
"// Note: While there may be multiple collisions with a tilemap, this function\n"
"// will only return one.\n"
"fn (t: ^Tilemap) getColl*(e: ent::Ent, ic: ^th::Vf2, pos: ^th::Vf2): bool {\n"
"//~~\n"
"\tif len(t.cells) == 0 { return false }\n"
"\n"
"\t_ := th::Vf2{}\n"
"\tif ic == null { ic = &_ }\n"
"\tif pos == null { pos = &_ }\n"
"\n"
"\treturn umth_tilemap_getcoll(pos, ic, t, &e)\n"
"}\n"
"\n"
"fn umth_tilemap_getcoll_line(b, e: th::Vf2, t: ^Tilemap, ic: ^th::Vf2): bool\n"
"//~~fn Tilemap.getCollLine\n"
"// Check for a collision between a tilemap and a line. `ic` will be a point of\n"
"// an intersection, if there is one.\n"
"fn (t: ^Tilemap) getCollLine*(b, e: th::Vf2, ic: ^th::Vf2): bool {\n"
"//~~\n"
"\treturn umth_tilemap_getcoll_line(b, e, t, ic)\n"
"}\n"
"\n"
"fn umth_tilemap_autotile(tgt: ^th::uu, w, h: th::uu, src, cfg: ^th::uu, tile: th::uu)\n"
"//~~fn Tilemap.autotile\n"
"// Autotile turns all `tile` tiles in `src` into tiles in `tileCfg`, so they\n"
"// follow up correctly. `tileCfg` is an array of 16 tiles. They are placed in\n"
"// a way where OR of all the places where the tile continues (top, right bot,\n"
"// right). The constants for them are defined in this file. Example:\n"
"// tileCfg[top | bot] = 21\n"
"// top | bot would look something like this: |\n"
"fn (t: ^Tilemap) autotile*(src, tileCfg: []th::uu, tile: th::uu) {\n"
"//~~\n"
"\tif len(tileCfg) < 16 {\n"
"\t\tth::__error(\"autotile: tileCfg len isn\'t 16\")\n"
"\t}\n"
"\n"
"\tumth_tilemap_autotile(&t.cells[0], t.w, len(t.cells)/t.w, &src[0], &tileCfg[0], tile)\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"audio.um\"\n"
"\t\"canvas.um\"\n"
"\t\"image.um\"\n"
"\t\"placeholders.um\"\n"
"\t\"rect.um\"\n"
"\t\"signal.um\"\n"
"\t\"std.um\"\n"
"\t\"th.um\"\n"
")\n"
"\n"
"var (\n"
"\tstart, clockOffset: real\n"
"\tfpsLimit: int = 60\n"
")\n"
"\n"
"//~~Cursor types\n"
"type Cursor* = enum {\n"
"\tsystem = 0\t\t// Default system cursor\n"
"\tarrow\t\t\t// Normal cursor; Arrow cursor\n"
"\tiBeam\t\t\t// \'I\' text cursor; I-Beam\n"
"\tcrosshair\t\t// \'+\' cursor; Select region cursor\n"
"\tfinger\t\t\t// Index finger pointing cursor; Click cursor\n"
"\tsizeEW\t\t\t// \'<->\' cursor; Resize width cursor; Resize horizontally cursor; East-West resize cursor\n"
"\tsizeNS\t\t\t// Resize height cursor; Resize vertically cursor; North-South resize cursor\n"
"\tsizeNWSE\t\t\t// Resize width and height from the right side cursor; Northwest-Southeast resize cursor\n"
"\tsizeSWNE\t\t\t// Resize width and height from the left side cursor; Southwest-Northeast resize cursor\n"
"\tsizeAll\t\t\t// Resize all cursor; Move cursor\n"
"\tno\t\t\t// \'(/)\' cursor; Disabled cursor; Disallowed cursor\n"
"\tcount_\n"
"}\n"
"//~~\n"
"\n"
"//~~Window dimensions\n"
"var (\n"
"\tw*, h*: int32\n"
")\n"
"//~~\n"
"\n"
"//~~Viewport size\n"
"var wp*: th::Vf2\n"
"//~~\n"
"\n"
"//~~signal OnFrame\n"
"var onFrame*: signal::Signal\n"
"//~~\n"
"//~~signal OnDestroy\n"
"var onDestroy*: signal::Signal\n"
"//~~\n"
"\n"
"fn umth_window_setup(title: str, w, h: int)\n"
"fn umth_window_get_dimensions(w, h: ^int32)\n"
"\n"
"fn umth_window_set_viewport(dm: th::Vf2)\n"
"//~~fn setViewport\n"
"// Sets the dimensions of the viewport. The dimensions are saved in the `wp`\n"
"// variable.\n"
"//\n"
"// `dm`\n"
"// : dimension of the viewport\n"
"fn setViewport*(dm: th::Vf2) {\n"
"//~~\n"
"\twp = dm\n"
"\tumth_window_set_viewport(dm)\n"
"}\n"
"\n"
"fn setIcon*(img: image::Image)\n"
"\n"
"fn umth_window_is_dpi_enabled(): bool\n"
"\n"
"//~~fn isDpiEnabled\n"
"// Returns true if DPI awareness was enabled\n"
"fn isDpiEnabled*(): bool {\n"
"//~~\n"
"\treturn umth_window_is_dpi_enabled()\n"
"}\n"
"\n"
"fn umth_window_get_dpi_scale(): th::fu\n"
"\n"
"//~~fn getDpiScaleFactor\n"
"// Returns the DPI scaling of the current window.\n"
"// If `dpiAware` was not enabled in window setup, this function will return 1.0 (default scaling).\n"
"fn getDpiScaleFactor*(): th::fu {\n"
"//~~\n"
"\treturn umth_window_get_dpi_scale()\n"
"}\n"
"\n"
"// 0 = other/unknown\n"
"// 1 = linux\n"
"// 2 = windows\n"
"// 3 = macos (unsupported currently)\n"
"// 4 = emscripten\n"
"fn umth_window_get_platform_id(): th::Platform\n"
"\n"
"//~~fn setup\n"
"// Sets up the engine and opens a window.\n"
"fn setup*(title: str = \"tophat game\", width: int = 400, height: int32 = 400) {\n"
"//~~\n"
"\tw, h = width, height\n"
"\tumth_window_setup(title, width, height)\n"
"\n"
"\tth::platform = umth_window_get_platform_id()\n"
"\n"
"\taudio::__setup()\n"
"\tplaceholders::__setup()\n"
"\n"
"\tsetIcon(placeholders::icon)\n"
"\n"
"\tclockOffset = std::clock() * 1000\n"
"\tstart = std::clock() * 1000\n"
"\n"
"\tsetViewport({width, height})\n"
"}\n"
"\n"
"fn cycle(delta: real) {\n"
"\tumth_window_set_viewport(wp)\n"
"\n"
"\tth::delta = trunc(delta*1000.0)\n"
"\tif th::delta == 0 {\n"
"\t\tth::delta = 1\n"
"\t}\n"
"\n"
"\tstart = std::clock()*1000\n"
"\tth::time = round(start - clockOffset)\n"
"\n"
"\tumth_window_get_dimensions(&w, &h)\n"
"\n"
"\taudio::__cycle()\n"
"\tcanvas::drawRect(th::white, rect::mk(0, 0, wp.x, wp.y))\n"
"}\n"
"\n"
"fn setViewportOffset*(s: th::Vf2)\n"
"fn getViewportOffset*(): th::Vf2\n"
"\n"
"fn drawClear() {\n"
"\tof := getViewportOffset()\n"
"\tsetViewportOffset({})\n"
"\tcanvas::drawRect(th::black, rect::mk(-4 * wp.x, 0, 4 * wp.x, wp.y))\n"
"\tcanvas::drawRect(th::black, rect::mk(0, -4 * wp.y, wp.x, 4 * wp.y))\n"
"\tcanvas::drawRect(th::black, rect::mk(wp.x, 0, 4 * wp.x, wp.y))\n"
"\tcanvas::drawRect(th::black, rect::mk(0, wp.y, wp.x, 4 * wp.y))\n"
"\tsetViewportOffset(of)\n"
"}\n"
"\n"
"fn umth_frame_callback*(delta: real) {\n"
"\tcycle(delta)\n"
"\tonFrame.emit(null)\n"
"\tdrawClear()\n"
"}\n"
"\n"
"fn umth_destroy_callback*() {\n"
"  onDestroy.emit(null)\n"
"}\n"
"\n"
"fn umth_window_set_fullscreen(fullscreen: bool)\n"
"fn umth_window_get_fullscreen(): bool\n"
"\n"
"//~~fn setFullscreen\n"
"// Makes window go full screen\n"
"fn setFullscreen*(fullscreen: bool) {\n"
"//~~\n"
"\tumth_window_set_fullscreen(fullscreen)\n"
"}\n"
"\n"
"//~~fn isFullscreen\n"
"// Returns true if window is fullscreen\n"
"fn isFullscreen*(): bool {\n"
"//~~\n"
"\treturn umth_window_get_fullscreen()\n"
"}\n"
"\n"
"//~~fn getDims\n"
"// Returns dimensions of the window in screen pixels.\n"
"fn getDims*(): th::Vf2 {\n"
"//~~\n"
"\treturn {w, h}\n"
"}\n"
"\n"
"fn umth_window_set_target_fps(fps: int)\n"
"\n"
"//~~fn setTargetFps\n"
"// Sets the fps limit.\n"
"//\n"
"// `fps`\n"
"// : amount of fps the limit should be set to\n"
"//\n"
"fn setTargetFps*(fps: int) {\n"
"//~~\n"
"\tfpsLimit = fps\n"
"\tumth_window_set_target_fps(fps)\n"
"}\n"
"\n"
"fn umth_window_set_title(title: str)\n"
"\n"
"//~~fn setTitle\n"
"// Sets the title of the window.\n"
"fn setTitle*(title: str) {\n"
"//~~\n"
"\tumth_window_set_title(title)\n"
"}\n"
"\n"
"fn umth_window_set_dims(dm: th::Vf2)\n"
"\n"
"//~~fn setDims\n"
"// Sets the dimensions of the window.\n"
"//\n"
"// `dm`\n"
"// : the target dimensions in screen pixels\n"
"fn setDims*(dm: th::Vf2) {\n"
"//~~\n"
"\tumth_window_set_dims(dm)\n"
"}\n"
"\n"
"fn umth_window_set_icon(img: image::Image)\n"
"//~~fn setIcon\n"
"// Sets the window icon.\n"
"fn setIcon*(img: image::Image) {\n"
"//~~\n"
"\tif !img.validate() {\n"
"\t\tth::__error(\"invalid image\")\n"
"\t}\n"
"\n"
"\tumth_window_set_icon(img)\n"
"}\n"
"\n"
"fn umth_window_show_cursor(show: bool)\n"
"//~~fn showCursor\n"
"// Show or hide the cursor, linux only.\n"
"fn showCursor*(show: bool) {\n"
"//~~\n"
"\tumth_window_show_cursor(show)\n"
"}\n"
"\n"
"fn umth_window_freeze_cursor(freeze: bool)\n"
"//~~fn freezeCursor\n"
"// Freezes the cursor in place. `input.getMouseDelta` will still report mouse\n"
"// movements.  The cursor will be automatically hidden.\n"
"fn freezeCursor*(freeze: bool) {\n"
"//~~\n"
"\tshowCursor(freeze)\n"
"\tumth_window_freeze_cursor(freeze)\n"
"}\n"
"\n"
"fn umth_window_set_cursor(cursor: Cursor)\n"
"//~~fn setCursor\n"
"// Allows you to set the displaying cursor. Refer to the cursors section for available cursors.\n"
"fn setCursor*(cursor: Cursor) {\n"
"//~~\n"
"\tumth_window_set_cursor(cursor);\n"
"}\n"
"\n"
"fn umth_window_request_exit()\n"
"//~~fn requestExit\n"
"// Requests the window to close.\n"
"fn requestExit*() {\n"
"//~~\n"
"\tumth_window_request_exit()\n"
"}\n"
"\n"
"fn umth_window_set_clipboard(s: str)\n"
"//~~fn setClipboard\n"
"// Puts a string to the system clipboard.\n"
"fn setClipboard*(s: str) {\n"
"//~~\n"
"\tumth_window_set_clipboard(s)\n"
"}\n"
"\n"
"fn umth_window_get_clipboard(): str\n"
"//~~fn getClipboard\n"
"// Gets a string from the system clipboard.\n"
"fn getClipboard*(): str {\n"
"//~~\n"
"\treturn umth_window_get_clipboard()\n"
"}\n"
"\n"
"fn umth_window_set_viewport_offset(s: th::Vf2)\n"
"//~~fn setViewportOffset\n"
"// Sets the offset of the viewport.\n"
"fn setViewportOffset*(s: th::Vf2) {\n"
"//~~\n"
"\tumth_window_set_viewport_offset(s)\n"
"}\n"
"\n"
"fn umth_window_get_viewport_offset(): th::Vf2\n"
"//~~fn getViewportOffset\n"
"// Gets the offset of the viewport (as set by `setViewportShift`)\n"
"fn getViewportOffset*(): th::Vf2 {\n"
"//~~\n"
"\treturn umth_window_get_viewport_offset()\n"
"}\n"
"",
"//~~\n"
"// Particles allow for *performant* and random particle systems.\n"
"//~~\n"
"\n"
"import (\n"
"\t\"std.um\"\n"
"\t\"th.um\"\n"
")\n"
"\n"
"//~~struct Particle\n"
"// Particle struct. You can tweak the start_time for godot-like explossivness.\n"
"type Particle* = struct {\n"
"//~~\n"
"\tstart_time: uint\n"
"\tseed: int32\n"
"}\n"
"\n"
"//~~struct Emitter\n"
"// Emitter. This is where everything is configured.\n"
"type Emitter* = struct {\n"
"\tpos: th::Vf2 // position\n"
"\tdm: th::Vf2 // size of the emittion area\n"
"\tgravity: th::Vf2 // gravity\n"
"\trepeat: bool // if false, particle won\'t be renewed\n"
"\tactive: bool // false, if there aren\'t any active particles anymore\n"
"\n"
"\tangle: th::Vf2 // angle in which particles are emitted\n"
"\n"
"\tlifetime: th::uu // lifetime of particles\n"
"\tlifetimeRandomness: th::fu // randomness in %/100\n"
"\n"
"\tvelocity: th::fu // velocity\n"
"\tvelocityRandomness: th::fu // randomness in %/100\n"
"\n"
"\tsize: th::fu // size\n"
"\tsizeRandomness: th::fu // randomness in %/100\n"
"\tmaxSize: th::fu // size at the end of particles lifetime\n"
"\n"
"\trotation: th::fu\n"
"\trotationRandomness: th::fu\n"
"\tmaxRotation: th::fu\n"
"\n"
"\tcolors: []uint32 // array of colors, which are interpolated between\n"
"\n"
"\tparticles: []Particle // list of particles\n"
"}\n"
"//~~\n"
"\n"
"fn umth_particles_draw(p: ^Emitter, t: int32)\n"
"//~~fn Emitter.draw\n"
"// Draws and updates the particles.\n"
"fn (e: ^Emitter) draw*(t: int32) {\n"
"//~~\n"
"\tif len(e.colors) <= 0 || len(e.particles) <= 0 {\n"
"\t\treturn\n"
"\t}\n"
"\n"
"\tumth_particles_draw(e, t)\n"
"}\n"
"\n"
"//~~fn Emitter.genParticles\n"
"// Generates particles for an emitter. The time specifies the time the first\n"
"// particles is emitted. The explosiveness argument specifies the interval at\n"
"// which particles are emitted using this formula:\n"
"/// ```umka\n"
"/// e.lifetime / count * explosiveness\n"
"/// ```\n"
"fn (e: ^Emitter) genParticles*(time, count: uint, explosiveness: th::fu = 0.0) {\n"
"//~~\n"
"\tp := make([]Particle, count)\n"
"\n"
"\tstep := real32(e.lifetime) / count * explosiveness\n"
"\tt := real32(time)\n"
"\n"
"\tfor i in p {\n"
"\t\tp[i] = { trunc(t), std::rand() }\n"
"\t\tt += step\n"
"\t}\n"
"\n"
"\te.particles = p\n"
"}\n"
"",
"//~~\n"
"// Simple linear interpolation module.\n"
"//~~\n"
"\n"
"import (\n"
"\t\"th.um\"\t\t\t\t\t\t\t\t\n"
")\n"
"\n"
"// Lerper queue item. It interpolates between start and end for the duration\n"
"// of length in ms. Additionally you can enable swap, which instead of\n"
"// dequeueing swaps start and end and resets the progress.\n"
"type Item* = struct {\n"
"\tstart, end: th::fu\n"
"\tlength: th::uu\n"
"\tprogress: th::fu\n"
"\tswap: bool\n"
"\tctx: any\n"
"\tcallback: fn(ctx: any)\n"
"}\n"
"\n"
"// Item\'s constructor\n"
"fn mk*(start, end: th::fu, length: th::uu, swap: bool = false): Item {\n"
"\treturn Item{\n"
"\t\tstart, end, length, 0, swap, null, fn(ctx: any) {}}\n"
"}\n"
"\n"
"// Lerper is a queue of items. It will lerp the first one and if it ends\n"
"// and doesn\'t have swap enabled, it will dequeue it.\n"
"type Lerper* = []Item\n"
"\n"
"// Removes the first lerper item.\n"
"fn (l: ^Lerper) dequeue*() {\n"
"\tswitch len(l^) {\n"
"\tcase 0:\n"
"\t\treturn\n"
"\tcase 1:\n"
"\t\tl^ = Lerper{}\n"
"\tdefault:\n"
"\t\tl^ = slice(l^, 1)\n"
"\t}\n"
"}\n"
"\n"
"// Adds an item to l\'s queue\n"
"fn (l: ^Lerper) enqueue*(i: Item) {\n"
"\tl^ = append(l^, i)\n"
"}\n"
"\n"
"// Interpolates the front by delta. And returns it\'s value.\n"
"fn (l: ^Lerper) byDelta*(delta: th::uu): th::fu {\n"
"\tif len(l^) == 0 {\n"
"\t\treturn 0\n"
"\t}\n"
"\n"
"\t/*for l[0].progress >= 1.0 {\n"
"\t\tl[0].callback(l[0].ctx)\n"
"\n"
"\t\tif l[0].swap {\n"
"\t\t\ttmp := l[0].start\n"
"\t\t\tl[0].start = l[0].end\n"
"\t\t\tl[0].end = tmp\n"
"\n"
"\t\t\tl[0].progress = 0\n"
"\t\t\tbreak\n"
"\t\t}\n"
"\n"
"\t\tl.dequeue()\n"
"\t\tif len(l^) == 0 {\n"
"\t\t\treturn 0\n"
"\t\t}\n"
"\t}*/\n"
"\n"
"\tif l[0].progress >= 1 {\n"
"\t\tend := l[0].end\n"
"\t\tl.dequeue()\n"
"\t\treturn end\n"
"\t}\n"
"\n"
"\tl[0].progress += th::fu(delta)/l[0].length\n"
"\n"
"\treturn l[0].progress * (l[0].end-l[0].start) + l[0].start\n"
"}\n"
"",
"//~~\n"
"// Module for font rendering. Unicode is supported, but only left to right.\n"
"//~~\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"std.um\"\n"
")\n"
"\n"
"//~~Filtering constants\n"
"type Filter* = enum {\n"
"\tnearest = 0\n"
"\tlinear = 1\n"
"}\n"
"//~~\n"
"\n"
"// TODO: should this be exported and documented?\n"
"type TrueType* = struct { _: ^struct{} }\n"
"\n"
"fn umth_ttf_font_load(f: ^TrueType, path: str, size: th::fu, filter: Filter): th::ErrCode\n"
"fn umth_ttf_font_draw(font: TrueType, s: str, x: th::fu, y: th::fu, color: uint32, scale: th::fu)\n"
"fn umth_ttf_font_measure(font: TrueType, s: str): th::Vf2\n"
"\n"
"fn (f: ^TrueType) validate*(): bool {\n"
"\treturn f._ != null\n"
"}\n"
"\n"
"fn (f: ^TrueType) draw*(text: str, pos: th::Vf2, color: uint32, scale: th::fu = 1.0) {\n"
"\tif !f.validate() {\n"
"\t\tth::__error(\"Invalid font\")\n"
"\t}\n"
"\tumth_ttf_font_draw(f^, text, pos.x, pos.y, color, scale)\n"
"}\n"
"\n"
"fn (f: ^TrueType) measure*(text: str): th::Vf2 {\n"
"\tif !f.validate() {\n"
"\t\tth::__error(\"Invalid font\")\n"
"\t\treturn {}\n"
"\t}\n"
"\n"
"\treturn umth_ttf_font_measure(f^, text)\n"
"}\n"
"\n"
"//~~interface Font\n"
"// A generic interface for fonts. Fonts can be loaded from file using\n"
"// `font::load`, or a built in canvas can be used from `canvas::pixelFont`.\n"
"type Font* = interface {\n"
"\t// Draw text to the viewport\n"
"\tdraw(text: str, pos: th::Vf2, color: uint32, scale: th::fu = 1.0)\n"
"\t// Return the dimensions of the text at scale 1\n"
"\tmeasure(text: str): th::Vf2\n"
"\t// Return true if the font is valid\n"
"\tvalidate(): bool\n"
"}\n"
"//~~\n"
"\n"
"//~~fn load\n"
"// Loads a font from a path and returns it.\n"
"fn load*(path: str, size: th::fu, filter: Filter = Filter.linear): (Font, std::Err) {\n"
"//~~\n"
"\tvar f: TrueType\n"
"\tec := umth_ttf_font_load(&f, path, size, filter)\n"
"\treturn f, th::__errFromCode(ec)\n"
"}\n"
"",
"//~~\n"
"// Module with useful variables and types.\n"
"// Variables: time, delta, platform\n"
"// Constants: black, white, red, green, blue, yellow, magenta, cyan.\n"
"//~~\n"
"\n"
"import (\n"
"\t\"std.um\"\n"
")\n"
"\n"
"//~~Tophat type aliases\n"
"// standard type for real values\n"
"type fu* = real32\n"
"// standard type for integer values\n"
"type iu* = int32\n"
"// standard type for unsigned values\n"
"type uu* = uint32\n"
"//~~\n"
"\n"
"//~~enum ErrCode\n"
"type ErrCode* = enum (int32) {\n"
"\tok = 0\n"
"\tfailure = 1\n"
"\tio\n"
"\tbad_enum\n"
"\tbad_action\n"
"\tbad_input\n"
"\talloc\n"
"\talready\n"
"\tout_of_bounds\n"
"}\n"
"//~~\n"
"\n"
"fn (e: ^ErrCode) toStr*(): str {\n"
"\tswitch e^ {\n"
"\tcase .ok:\n"
"\t\treturn \"ok\"\n"
"\tcase .io:\n"
"\t\treturn \"input/output error\"\n"
"\tcase .bad_enum:\n"
"\t\treturn \"invalid enum value\"\n"
"\tcase .bad_action:\n"
"\t\treturn \"invalid action\"\n"
"\tcase .bad_input:\n"
"\t\treturn \"invalid input value\"\n"
"\tcase .alloc:\n"
"\t\treturn \"failed allocation\"\n"
"\tcase .already:\n"
"\t\treturn \"action already performet\"\n"
"\tcase .out_of_bounds:\n"
"\t\treturn \"index out of bounds\"\n"
"\t}\n"
"\n"
"\treturn \"unknown error\"\n"
"}\n"
"\n"
"fn __errFromCode*(ec: ErrCode, msg: str = \"\"): std::Err {\n"
"\tif msg != \"\" {\n"
"\t\treturn std::error(int(ec), ec.toStr() + \": \" + msg, \"tophat\")\n"
"\t}\n"
"\n"
"\treturn std::error(int(ec), ec.toStr(), \"tophat\")\n"
"}\n"
"\n"
"//~~struct Vf2\n"
"// vector 2\n"
"type Vf2* = struct {\n"
"\tx, y: fu\n"
"}\n"
"//~~\n"
"\n"
"//~~fn mkVf2\n"
"// Vf2 constructor\n"
"fn mkVf2*(x: fu = 0, y: fu = 0): Vf2 {\n"
"\treturn Vf2{x, y}\n"
"}\n"
"//~~\n"
"\n"
"//~~fn Vf2.rotated\n"
"// rotates `p` around `origin` with `rot` in degrees\n"
"fn (p: ^Vf2) rotated*(origin: Vf2, rot: fu): Vf2 {\n"
"//~~\n"
"\tangle := (rot * std::pi) / 180\n"
"\n"
"\tpos := p^\n"
"\tpos.x -= origin.x\n"
"\tpos.y -= origin.y\n"
"\n"
"\tx := pos.x * cos(angle) - pos.y * sin(angle)\n"
"\ty := pos.x * sin(angle) + pos.y * cos(angle)\n"
"\n"
"\tpos.x = x + origin.x\n"
"\tpos.y = y + origin.y\n"
"\n"
"\treturn pos\n"
"}\n"
"\n"
"//~~fn Vf2.distanceTo\n"
"// distance between p1 and p2\n"
"fn (p1: ^Vf2) distanceTo*(p2: Vf2): fu {\n"
"//~~\n"
"\treturn sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y))\n"
"}\n"
"\n"
"//~~fn Vf2.angleTo\n"
"// Angle between p1 and p2\n"
"fn (p1: ^Vf2) angleTo*(p2: Vf2): real {\n"
"//~~\n"
"\tif p1.x == p2.x && p1.y == p2.y { return 0 }\n"
"\treturn atan2(p2.y - p1.y, p2.x - p1.x) * 180 / std::pi + 180\n"
"}\n"
"\n"
"//~~fn Vf2.abs\n"
"// Absolute value of a vector.\n"
"fn (p: ^Vf2) abs*(): Vf2 {\n"
"//~~\n"
"\treturn Vf2{fabs(p.x), fabs(p.y)}\n"
"}\n"
"\n"
"//~~fn Vf2.round\n"
"// Rounds a vector.\n"
"fn (p: ^Vf2) round*(): Vf2 {\n"
"//~~\n"
"\treturn Vf2{round(p.x), round(p.y)}\n"
"}\n"
"\n"
"//~~fn Vf2.trunc\n"
"// Truncates a vector.\n"
"fn (p: ^Vf2) trunc*(): Vf2 {\n"
"//~~\n"
"\treturn Vf2{trunc(p.x), trunc(p.y)}\n"
"}\n"
"\n"
"//~~fn Vf2.floor\n"
"// Floors a vector.\n"
"fn (p: ^Vf2) floor*(): Vf2 {\n"
"//~~\n"
"\treturn Vf2{floor(p.x), floor(p.y)}\n"
"}\n"
"\n"
"//~~fn Vf2.ceil\n"
"// Ceils a vector.\n"
"fn (p: ^Vf2) ceil*(): Vf2 {\n"
"//~~\n"
"\treturn Vf2{ceil(p.x), ceil(p.y)}\n"
"}\n"
"\n"
"//~~fn vf2f\n"
"// Creates a vector with both x and y set to f\n"
"fn vf2f*(f: fu): Vf2 {\n"
"//~~\n"
"\treturn Vf2{f, f}\n"
"}\n"
"\n"
"//~~fn Vf2.sub\n"
"// Subtracts a vector from another one.\n"
"fn (p: ^Vf2) sub*(p2: Vf2): Vf2 {\n"
"//~~\n"
"\treturn Vf2{p.x - p2.x, p.y - p2.y}\n"
"}\n"
"\n"
"//~~fn Vf2.subf\n"
"// Subtracts a fu from a vector.\n"
"fn (p: ^Vf2) subf*(f: fu): Vf2 {\n"
"//~~\n"
"\treturn Vf2{p.x - f, p.y - f}\n"
"}\n"
"\n"
"//~~fn Vf2.add\n"
"// Adds a vector to another one.\n"
"fn (p: ^Vf2) add*(p2: Vf2): Vf2 {\n"
"//~~\n"
"\treturn Vf2{p.x + p2.x, p.y + p2.y}\n"
"}\n"
"\n"
"//~~fn Vf2.addf\n"
"// Adds a fu to a vector.\n"
"fn (p: ^Vf2) addf*(f: fu): Vf2 {\n"
"//~~\n"
"\treturn Vf2{p.x + f, p.y + f}\n"
"}\n"
"\n"
"//~~fn Vf2.div\n"
"// Divides a vector by another one.\n"
"fn (p: ^Vf2) div*(p2: Vf2): Vf2 {\n"
"//~~\n"
"\treturn Vf2{p.x / p2.x, p.y / p2.y}\n"
"}\n"
"\n"
"//~~fn Vf2.divf\n"
"// Divides a vector by a fu.\n"
"fn (p: ^Vf2) divf*(f: fu): Vf2 {\n"
"//~~\n"
"\treturn Vf2{p.x / f, p.y / f}\n"
"}\n"
"\n"
"//~~fn Vf2.mul\n"
"// Multiplies a vector by another one.\n"
"fn (p: ^Vf2) mul*(p2: Vf2): Vf2 {\n"
"//~~\n"
"\treturn Vf2{p.x * p2.x, p.y * p2.y}\n"
"}\n"
"\n"
"//~~fn Vf2.mulf\n"
"// Multiplies a vector by a fu.\n"
"fn (p: ^Vf2) mulf*(f: fu): Vf2 {\n"
"//~~\n"
"\treturn Vf2{p.x * f, p.y * f}\n"
"}\n"
"\n"
"//~~fn Vf2.mag\n"
"// Returns the magnitude of a vector p.\n"
"fn (p: ^Vf2) mag*(): fu {\n"
"//~~\n"
"\treturn sqrt(p.x * p.x + p.y * p.y)\n"
"}\n"
"\n"
"//~~fn Vf2.norm\n"
"// Normalizes a vector.\n"
"fn (p: ^Vf2) norm*(): Vf2 {\n"
"//~~\n"
"\tif p.x == 0 && p.y == 0 {\n"
"\t\treturn p^\n"
"\t}\n"
"\n"
"\treturn p.divf(p.mag())\n"
"}\n"
"\n"
"//~~fn Vf2.dot\n"
"// Calculates dot product between 2 vectors.\n"
"fn (p: ^Vf2) dot*(q: Vf2): fu {\n"
"//~~\n"
"\treturn p.x*q.x + p.y*q.y\n"
"}\n"
"\n"
"//~~struct Transform\n"
"// Struct defining transformation. Used for example by entities.\n"
"type Transform* = struct {\n"
"\tp: Vf2 // position\n"
"\ts: Vf2 // scale\n"
"\to: Vf2 // origin\n"
"\tr: fu  // rotation\n"
"}\n"
"//~~\n"
"\n"
"//~~fn mkTransform\n"
"// Transform constructor\n"
"fn mkTransform*(p: Vf2, s: Vf2 = Vf2{1, 1}, o: Vf2 = Vf2{0, 0}, r: fu = 0.0): Transform {\n"
"//~~\n"
"\treturn Transform{p: p, s: s, o: o, r: r}\n"
"}\n"
"\n"
"fn umth_transform_transform(o, t: Transform): Transform\n"
"//~~fn Transform.transformed\n"
"// Transforms a transform with another transform.\n"
"fn (o: ^Transform) transformed*(t: Transform): Transform {\n"
"//~~\n"
"\treturn umth_transform_transform(o^, t)\n"
"}\n"
"\n"
"fn umth_transform_vf2(v: Vf2, t: Transform): Vf2\n"
"//~~fn Vf2.transformed\n"
"// Transforms a vf2 to another vf2.\n"
"// Order:\n"
"// \t1. scale\n"
"// \t2. rotation\n"
"// \t3. position\n"
"//\n"
"// This allows conversion from a relative to an absolute vf2.\n"
"fn (v: ^Vf2) transformed*(t: Transform): Vf2 {\n"
"//~~\n"
"\treturn umth_transform_vf2(v^, t)\n"
"}\n"
"\n"
"//~~type Quad\n"
"type Quad* = [4]Vf2\n"
"//~~\n"
"\n"
"fn umth_transform_quad(q: Quad, t: Transform): Quad\n"
"\n"
"//~~fn Quad.transformed\n"
"// Transforms a quad with a transform.\n"
"fn (q: ^Quad) transformed*(t: Transform): Quad {\n"
"//~~\n"
"\treturn umth_transform_quad(q^, t)\n"
"}\n"
"\n"
"fn umth_quad_max(q: Quad): Vf2\n"
"//~~fn Quad.getMax\n"
"// Gets the maximum coordinate.\n"
"fn (q: ^Quad) getMax*(): Vf2 {\n"
"//~~\n"
"\treturn umth_quad_max(q^)\n"
"}\n"
"\n"
"fn umth_quad_min(q: Quad): Vf2\n"
"//~~fn Quad.getMin\n"
"// Gets the minimum coordinate.\n"
"fn (q: ^Quad) getMin*(): Vf2 {\n"
"//~~\n"
"\treturn umth_quad_min(q^)\n"
"}\n"
"\n"
"//~~fn Quad.getDims\n"
"// Returns the dimensions of the quad\'s bounding box\n"
"fn (q: ^Quad) getDims*(): Vf2 {\n"
"//~~\n"
"\tmax := q[0]\n"
"\tmin := q[0]\n"
"\n"
"\tmaxmag := max.mag()\n"
"\tminmag := min.mag()\n"
"\n"
"\tfor i:=1; i < len(q^); i++ {\n"
"\t\tqmag := q[i].mag()\n"
"\n"
"\t\tif maxmag < qmag {\n"
"\t\t\tmax = q[i]\n"
"\t\t\tmaxmag = qmag\n"
"\t\t}\n"
"\n"
"\t\tif minmag > qmag {\n"
"\t\t\tmin = q[i]\n"
"\t\t\tminmag = qmag\n"
"\t\t}\n"
"\t}\n"
"\n"
"\treturn max.sub(min).abs()\n"
"}\n"
"\n"
"fn umth_th_getglobal(): ^struct{}\n"
"//~~fn getGlobal\n"
"// returns a pointer to the th_global. Set this as your extensions thg.\n"
"fn getGlobal*(): ^struct{} {\n"
"//~~\n"
"\treturn umth_th_getglobal()\n"
"}\n"
"\n"
"fn umth_th_getfuncs(): ^struct{}\n"
"//~~fn getFuncs\n"
"// returns pointer to tophat functions. Pass this to th_ext_set.\n"
"fn getFuncs*(): ^struct{} {\n"
"//~~\n"
"\treturn umth_th_getfuncs()\n"
"}\n"
"\n"
"//~~var enableErrrors\n"
"// If true, errors will result in a call to exit(255), otherwise printf is used.\n"
"var enableErrors*: bool = true\n"
"//~~\n"
"fn __error*(msg: str) {\n"
"\tif enableErrors {\n"
"\t\texit(255, msg)\n"
"\t} else {\n"
"\t\tprintf(\"error: %s\\n\", msg)\n"
"\t}\n"
"}\n"
"\n"
"//~~Color constants\n"
"const (\n"
"\tblack* = 0xff\n"
"\twhite* = 0xffffffff\n"
"\tred* = 0xff0000ff\n"
"\tgreen* = 0x00ff00ff\n"
"\tblue* = 0x0000ffff\n"
"\tyellow* = 0xffff00ff\n"
"\tmagenta* = 0xff00ffff\n"
"\tcyan* = 0x00ffffff\n"
")\n"
"//~~\n"
"\n"
"//~~enum Platform\n"
"type Platform* = enum {\n"
"\tunknown\n"
"\tlinux\n"
"\twindows\n"
"\tmacOs\n"
"\tweb\n"
"}\n"
"//~~\n"
"\n"
"//~~Misc variables\n"
"var (\n"
"\t// time in ms from start of the game\n"
"\ttime*: uint\n"
"\t// length of the last frame in ms\n"
"\tdelta*: int\n"
"\t// platform tophat is running on\n"
"\tplatform*: Platform\n"
")\n"
"//~~\n"
"",
"//~~\n"
"// A module for importless communication between modules. A signal is a set of\n"
"// callbacks.  You can use signals directly in your own structs if you want\n"
"// them to be instance specific, of you can use global signals which are\n"
"// adressed by a string name.\n"
"//~~\n"
"\n"
"import (\n"
"\t\"std.um\"\n"
"\t\"th.um\"\n"
")\n"
"\n"
"//~~type Callback\n"
"// `args` is a list of arguments passed to the `emit` method.\n"
"type Callback* = fn(args: []any)\n"
"//~~\n"
"\n"
"//~~type Id\n"
"type Id* = uint\n"
"//~~\n"
"\n"
"//~~type Signal\n"
"type Signal* = map[Id]Callback\n"
"//~~\n"
"\n"
"var signals: map[str]Signal\n"
"var idCounter: Id\n"
"\n"
"//~~fn mk\n"
"// `Signal` constructor\n"
"fn mk*(): Signal {\n"
"//~~\n"
"\treturn make(Signal)\n"
"}\n"
"\n"
"//~~fn Signal.register\n"
"// Registers a callback to a signal and returns the callback id.\n"
"fn (this: ^Signal) register*(callback: Callback): Id {\n"
"//~~\n"
"\tidCounter++\n"
"\tthis[idCounter] = callback\n"
"\n"
"\treturn idCounter\n"
"}\n"
"\n"
"//~~fn Signal.remove\n"
"// Removes a callback by id.\n"
"fn (this: ^Signal) remove*(id: Id) {\n"
"//~~\n"
"\tdelete(this^, id)\n"
"}\n"
"\n"
"//~~fn Signal.emit\n"
"// Emits a signal.\n"
"fn (this: ^Signal) emit*(args: ..any) {\n"
"//~~\n"
"\tfor _,c in this {\n"
"\t\tc(args)\n"
"\t}\n"
"}\n"
"\n"
"//~~fn Signal.clear\n"
"// Removes all signal handlers.\n"
"fn (this: ^Signal) clear*() {\n"
"//~~\n"
"\tks := keys(this^)\n"
"\n"
"\tfor i, k in ks {\n"
"\t\tthis ^= delete(this^, k)\n"
"\t}\n"
"}\n"
"\n"
"//~~fn register\n"
"// Registers a callback to a global signal.  There is no need to explicitly\n"
"// create global signals.  Returns id of the added callback\n"
"fn register*(name: str, callback: Callback): Id {\n"
"//~~\n"
"\tif !valid(signals) {\n"
"\t\tsignals = make(map[str]Signal)\n"
"\t}\n"
"\n"
"\treturn signals[name].register(callback)\n"
"}\n"
"\n"
"//~~fn remove\n"
"// Removes a callback from a global signal by id.\n"
"fn remove*(name: str, id: Id) {\n"
"//~~\n"
"\tsignals[name].remove(id)\n"
"}\n"
"\n"
"//~~fn remove\n"
"// Removes all signal handlers from a global signal.\n"
"fn clear*(name: str) {\n"
"//~~\n"
"\tsignals[name].clear()\n"
"}\n"
"\n"
"//~~fn emit\n"
"// Calls all callbacks associated with the passed global signal name.\n"
"fn emit*(name: str, args: ..any): std::Err {\n"
"//~~\n"
"\tif !valid(signals) {\n"
"\t\tsignals = make(map[str]Signal)\n"
"\t}\n"
"\n"
"\tif !validkey(signals, name) {\n"
"\t\treturn th::__errFromCode(.bad_input, \"unknown signal\")\n"
"\t}\n"
"\n"
"\tsignals[name].emit(args)\n"
"\n"
"\treturn {}\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"std.um\"\n"
"\t\"image.um\"\n"
"\t\"rect.um\"\n"
")\n"
"\n"
"//~~struct Atlas\n"
"// Atlas is an image containing tiles in a square grid.\n"
"type Atlas* = struct {\n"
"\ti: image::Image // source image\n"
"\tcs: th::Vf2 // size of a cell in pixels\n"
"\tdm: th::Vf2 // amount of cells in image\n"
"}\n"
"//~~\n"
"\n"
"//~~fn mk\n"
"// i: source image\n"
"// dm: amount of cells\n"
"fn mk*(i: image::Image, dm: th::Vf2): Atlas {\n"
"//~~\n"
"\tif !i.validate() {\n"
"\t\tth::__error(\"Image is not valid\")\n"
"\t}\n"
"\n"
"\ta := Atlas{}\n"
"\n"
"\ta.i = i\n"
"\ta.dm = dm\n"
"\ta.cs = i.getDims().div(dm)\n"
"\n"
"\treturn a\n"
"}\n"
"\n"
"//~~fn mk2\n"
"// i: source image\n"
"// cs: size of a cell in pixels\n"
"fn mk2*(i: image::Image, cs: th::Vf2): Atlas {\n"
"//~~\n"
"\tif !i.validate() {\n"
"\t\tth::__error(\"Image is not valid\")\n"
"\t}\n"
"\n"
"\ta := Atlas{}\n"
"\n"
"\ta.i = i\n"
"\ta.cs = cs\n"
"\ta.dm = i.getDims().div(cs)\n"
"\n"
"\treturn a\n"
"}\n"
"\n"
"//~~fn Atlas.coords\n"
"// returns the coordinates of the nth tile\n"
"fn (a: ^Atlas) coords*(n: int): th::Vf2 {\n"
"//~~\n"
"\tn--\n"
"\treturn th::Vf2{ n % trunc(a.dm.x), (n - n % trunc(a.dm.x)) / a.dm.x }\n"
"}\n"
"\n"
"//~~fn Atlas.rect\n"
"// returns the rectangle of the nth tile\n"
"fn (a: ^Atlas) rect*(n: int): rect::Rect {\n"
"//~~\n"
"\tn--\n"
"\treturn {(n % trunc(a.dm.x))*a.cs.x, ((n - n % trunc(a.dm.x)) / a.dm.x)*a.cs.y, a.cs.x, a.cs.y}\n"
"}\n"
"\n"
"//~~fn Atlas.index\n"
"// returns the index of the tile at the given coordinates\n"
"fn (a: ^Atlas) index*(at: th::Vf2): int {\n"
"//~~\n"
"\treturn int(trunc(at.x) + trunc(at.y) * trunc(a.dm.x)) - 1\n"
"}\n"
"\n"
"//~~fn Atlas.has\n"
"// returns true if the tile at the given coordinates exists\n"
"fn (a: ^Atlas) has*(at: th::Vf2): bool {\n"
"//~~\n"
"\treturn at.x >= 0 && at.y >= 0 && at.x < a.dm.x && at.y < a.dm.y\n"
"}\n"
"\n"
"//~~fn Atlas.hasIndex\n"
"// returns true if the tile at the given index exists\n"
"fn (a: ^Atlas) hasIndex*(n: int): bool {\n"
"//~~\n"
"\treturn n > 0 && n <= trunc(a.dm.x * a.dm.y)\n"
"}\n"
"\n"
"//~~fn Atlas.cropSource\n"
"// Crops the sourse image to only show a wanted tile\n"
"fn (a: ^Atlas) cropSource*(at: th::Vf2) {\n"
"//~~\n"
"\ta.i.crop(\n"
"\t\t{at.x / a.dm.x, at.y / a.dm.y},\n"
"\t\t{(at.x+1) / a.dm.x, (at.y+1) / a.dm.y}\n"
"\t)\n"
"}\n"
"\n"
"//~~enum PackStrategy\n"
"type PackStrategy = enum {\n"
"\tsquare\n"
"\trow\n"
"\tcolumn\n"
"}\n"
"//~~\n"
"\n"
"fn umth_atlas_pack(a: ^Atlas, images: ^[]image::Image, strategy: PackStrategy): th::ErrCode\n"
"\n"
"//~~fn pack\n"
"// Packs an array of images into an atlas\n"
"fn pack*(images: []image::Image, strategy: PackStrategy): (Atlas, std::Err) {\n"
"//~~\n"
"\tvar a: Atlas\n"
"\tec := umth_atlas_pack(&a, &images, strategy)\n"
"\treturn a, th::__errFromCode(ec)\n"
"}\n"
"\n"
"//~~fn Atlas.draw\n"
"// Draws the tile at `at`\n"
"fn (a: ^Atlas) draw*(at: th::Vf2, t: th::Transform) {\n"
"//~~\n"
"\ta.cropSource(at)\n"
"\ta.i.draw(t, th::white)\n"
"\ta.i.crop({}, {1, 1})\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
")\n"
"\n"
"//~~opaque Shader\n"
"// Shader allows you to define your own vertex and fragment GLSL shaders. This\n"
"// is a low-level feature, so it\'s very easy to mess up.\n"
"//\n"
"// In tophat, instead of a main function, shaders provide th_vertex and\n"
"// th_fragment. The signature of th_vertex is:\n"
"//\n"
"// ```\n"
"// vec2 th_vertex(vec2 vert);\n"
"// ```\n"
"//\n"
"// where vert is the position of the vertex taken from the vertex buffer.\n"
"// The output is the vertex shader output.\n"
"//\n"
"// As for fragment shaders, there are two types of them. One for canvas\n"
"// and one for images. In canvas shaders, the fragment function is very simple:\n"
"//\n"
"// ```\n"
"// vec4 th_fragment(vec4 color);\n"
"// ```\n"
"//\n"
"// Image fragment function looks like this:\n"
"//\n"
"// ```\n"
"// vec4 th_fragment(sampler2D tex, vec2 coord);\n"
"// ```\n"
"//\n"
"// where tex is the texture and coord are the texture coordinates. Be aware to\n"
"// swap the output of the `texture2D` function. Example:\n"
"//\n"
"// ```\n"
"// texture2D(tex, coord).abgr\n"
"// ```\n"
"type Shader* = struct {\n"
"//~~\n"
"\thandle: int\n"
"}\n"
"\n"
"\n"
"//~~Default shader constants\n"
"const (\n"
"\tdefaultImageShader* = Shader{1}\n"
"\tdefaultCanvasShader* = Shader{2}\n"
")\n"
"//~~\n"
"\n"
"//~~struct Uniform\n"
"// Represents a GLSL uniform.\n"
"type Uniform* = struct {\n"
"\ts: Shader\n"
"\tl: uint\n"
"}\n"
"//~~\n"
"\n"
"fn umth_shader_compile_canvas(vertex, fragment: str): int\n"
"//~~fn mkCanvas\n"
"// Compiles a canvas shader from source. If there is a compilation error, it\n"
"// will print something to the console.\n"
"fn mkCanvas*(vertex, fragment: str): Shader {\n"
"//~~\n"
"\treturn Shader{umth_shader_compile_canvas(vertex, fragment)}\n"
"}\n"
"\n"
"fn umth_shader_compile_image(vertex, fragment: str): int\n"
"//~~fn mkImage\n"
"// Compiles an image shader from source. If there is a compilation error, it\n"
"// will print something to the console.\n"
"fn mkImage*(vertex, fragment: str): Shader {\n"
"//~~\n"
"\treturn Shader{umth_shader_compile_image(vertex, fragment)}\n"
"}\n"
"\n"
"fn umth_shader_pick_canvas(handle: int)\n"
"//~~fn Shader.pickForCanvas\n"
"// Picks the shader to be used for canvas drawing. Flushes the canvas batch.\n"
"fn (s: ^Shader) pickForCanvas*() {\n"
"//~~\n"
"\tumth_shader_pick_canvas(s.handle)\n"
"}\n"
"\n"
"fn umth_shader_pick_image(handle: int)\n"
"//~~fn Shader.pickForImage\n"
"// Picks the shader to be used for image drawing. Flushes the image batch.\n"
"fn (s: ^Shader) pickForImage*() {\n"
"//~~\n"
"\tumth_shader_pick_image(s.handle)\n"
"}\n"
"\n"
"fn umth_shader_get_uniform_location(handle: int, name: str): uint\n"
"//~~fn Shader.getUniformLocation\n"
"// Retunrs a uniform by name.\n"
"fn (s: ^Shader) getUniformLocation*(name: str): Uniform {\n"
"//~~\n"
"\treturn Uniform{s^, umth_shader_get_uniform_location(s.handle, name)}\n"
"}\n"
"\n"
"fn umth_shader_set_uniform_int(shandle, uhandle: uint, value: int)\n"
"//~~fn Uniform.setInt\n"
"// Sets a uniform to an int value. Flushes both batches.\n"
"fn (u: ^Uniform) setInt*(value: int) {\n"
"//~~\n"
"\tumth_shader_set_uniform_int(u.s.handle, u.l, value)\n"
"}\n"
"\n"
"fn umth_shader_set_uniform_vf2(shandle, uhandle: uint, value: th::Vf2)\n"
"//~~fn Uniform.setVf2\n"
"// Sets a uniform to a vf2. Flushes both batches.\n"
"fn (u: ^Uniform) setVf2*(value: th::Vf2) {\n"
"//~~\n"
"\tumth_shader_set_uniform_vf2(u.s.handle, u.l, value)\n"
"}\n"
"",
"//~~\n"
"// Color operations. Operate on RGBA uint32 values.\n"
"//~~\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
")\n"
"\n"
"fn umth_hsv2rgb_uint32(h, s, v, a: th::fu): uint32\n"
"\n"
"// Now this is hard to decide, but in my opinion executing a C function,\n"
"//   for the current Umka VM would be much better than implementing it in umka itself.\n"
"// It\'s somewhat less trivial than most other operations like alpha.\n"
"fn umth_rgb_uint32(r, g, b, a: th::fu): uint32\n"
"\n"
"//~~fn hsv\n"
"// Converts HSV values into RGBA uint32 color.\n"
"// NOTE: Hue is between 0 and 1\n"
"fn hsv*(h, s, v: th::fu, a: th::fu = 1.0): uint32 {\n"
"//~~\n"
"\treturn umth_hsv2rgb_uint32(h, s, v, a);\n"
"}\n"
"\n"
"//~~fn alpha\n"
"// Sets alpha of the color c to a value in to.\n"
"fn alpha*(c: uint32, to: th::fu): uint32 {\n"
"//~~\n"
"\treturn (c & 0xFFFFFF00) | (trunc(to * 255) & 0xFF)\n"
"}\n"
"\n"
"//~~fn rgb\n"
"// Constructs RGBA uint32 from RGBA of reals.\n"
"fn rgb*(r, g, b: th::fu, a: th::fu = 1.0): uint32 {\n"
"//~~\n"
"\treturn umth_rgb_uint32(r, g, b, a)\n"
"}\n"
"\n"
"",
"//~~\n"
"// Builtin collision functions. The ic argument stores the collision position.\n"
"//~~\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"rect.um\"\n"
")\n"
"\n"
"fn umth_coll_line_to_line(b1, e1, b2, e2: th::Vf2, ic: ^th::Vf2): bool\n"
"//~~fn lineToLine\n"
"// Checks for a collision between 2 lines specified by their end points.\n"
"fn lineToLine*(b1, e1, b2, e2: th::Vf2, ic: ^th::Vf2): bool {\n"
"//~~\n"
"\treturn umth_coll_line_to_line(b1, e1, b2, e2, ic)\n"
"}\n"
"\n"
"fn umth_coll_point_to_quad(p: th::Vf2, q: th::Quad, ic: ^th::Vf2): bool\n"
"//~~fn vf2ToQuad\n"
"// Checks for a collision between a vf2 and a quad.\n"
"fn vf2ToQuad*(p: th::Vf2, q: th::Quad, ic: ^th::Vf2): bool {\n"
"//~~\n"
"\treturn umth_coll_point_to_quad(p, q, ic)\n"
"}\n"
"\n"
"fn umth_coll_line_to_quad(b, e: th::Vf2, q: th::Quad, ic1, ic2: ^th::Vf2): bool\n"
"//~~fn lineToQuad\n"
"// Check for a collision between a line and quad edges.\n"
"fn lineToQuad*(b, e: th::Vf2, q: th::Quad, ic1, ic2: ^th::Vf2): bool {\n"
"//~~\n"
"\treturn umth_coll_line_to_quad(b, e, q, ic1, ic2)\n"
"}\n"
"\n"
"fn umth_coll_quad_to_quad(q1, q2: th::Quad, ic: ^th::Vf2): bool\n"
"//~~fn quadToQuad\n"
"// Check for a collision between two quads.\n"
"fn quadToQuad*(q1, q2: th::Quad, ic: ^th::Vf2): bool {\n"
"//~~\n"
"\treturn umth_coll_quad_to_quad(q1, q2, ic)\n"
"}\n"
"\n"
"fn umth_coll_point_to_rect(p: th::Vf2, r: rect::Rect): bool\n"
"//~~fn vf2ToRect\n"
"// Check for a collision between a vf2 and a rectangle.\n"
"fn vf2ToRect*(p: th::Vf2, r: rect::Rect): bool {\n"
"//~~\n"
"\treturn umth_coll_point_to_rect(p, r)\n"
"}\n"
"\n"
"fn umth_coll_rect_to_rect(r1, r2: rect::Rect): bool\n"
"//~~fn rectToRect\n"
"// Check for a collision between two rects\n"
"fn rectToRect*(r1, r2: rect::Rect): bool {\n"
"//~~\n"
"\treturn umth_coll_rect_to_rect(r1, r2)\n"
"}\n"
"\n"
"fn umth_coll_rect_intersect(r1, r2: rect::Rect): rect::Rect\n"
"//~~fn rectIntersect\n"
"// Get the intersection of two rects.\n"
"fn rectIntersect*(r1, r2: rect::Rect): rect::Rect {\n"
"//~~\n"
"\treturn umth_coll_rect_intersect(r1, r2)\n"
"}\n"
"\n"
"",
"import(\"image.um\")\n"
"\n"
"//~~Placeholder images\n"
"// These images are included with tophat and don\'t have to be loaded.\n"
"var (\n"
"\t// an image useful for testing\n"
"\ttest*: image::Image\n"
"\t// the image used for the app icon\n"
"\ticon*: image::Image\n"
"\t// Windows 95 style button, to be used with ninepatch (image.um)\n"
"\tbutton*: image::Image\n"
")\n"
"//~~\n"
"\n"
"fn umth_placeholder_fetch(id: uint32): ^struct{}\n"
"\n"
"// **INTERNAL**\n"
"fn __setup*() {\n"
"\ttest = image::Image{umth_placeholder_fetch(0)}\n"
"\ticon = image::Image{umth_placeholder_fetch(1)}\n"
"\tbutton = image::Image{umth_placeholder_fetch(2)}\n"
"}\n"
"\n"
"",
"\n"
"import (\n"
"\t\"canvas.um\"\n"
"\t\"coll.um\"\n"
"\t\"color.um\"\n"
"\t\"rect.um\"\n"
"\t\"th.um\"\n"
")\n"
"\n"
"//~~struct Mesh\n"
"// Mesh is a 2d array of bool cells.  If a cell is true, the cell can be used\n"
"// in a path.  The mesh is located in a world using the `r` field.  A cell can\n"
"// have an arbitrary size as specified by `s`.\n"
"//\n"
"// The mesh can be edited using the `addQuad` method, but it should be trivial\n"
"// to add your own, similar methods.\n"
"//\n"
"// Please use the `mk` constructor to construct a `Mesh`, unless you really\n"
"// know what you\'re doing.\n"
"type Mesh* = struct {\n"
"\t// The mesh data.\n"
"\td: []bool\n"
"\t// The dimensions and position of the mesh, r.w == w * s\n"
"\tr: rect::Rect\n"
"\t// Width of the mesh.  Used to adress the mesh data.\n"
"\tw: th::uu\n"
"\t// Scale of one cell (cell is a square)\n"
"\ts: th::fu\n"
"}\n"
"//~~\n"
"\n"
"//~~fn mk\n"
"// Creates a new nav mesh.\n"
"// `r`\n"
"// : the rectangle of the mask\n"
"// \'s\'\n"
"// : the scale of the mask\n"
"fn mk*(r: rect::Rect, s: th::fu): Mesh {\n"
"//~~\n"
"\tm := Mesh{}\n"
"\n"
"\tm.d = make([]bool, ceil(r.w/s) * ceil(r.h/s))\n"
"\tfor i in m.d {\n"
"\t\tm.d[i] = true\n"
"\t}\n"
"\n"
"\tm.w = trunc(r.w/s)\n"
"\tm.s = s\n"
"\tm.r = r\n"
"\n"
"\treturn m\n"
"}\n"
"\n"
"fn umth_nav_mesh_add_quad(m: ^Mesh, q: th::Quad)\n"
"//~~fn Mesh.addQuad\n"
"// Sets mask\'s fields overlapping `q` to `false`.\n"
"fn (m: ^Mesh) addQuad*(q: th::Quad) {\n"
"//~~\n"
"\tumth_nav_mesh_add_quad(m, q)\n"
"}\n"
"\n"
"fn umth_nav_mesh_nav(t: ^void, m: ^Mesh, p1, p2: th::Vf2): []th::Vf2\n"
"//~~fn Mesh.nav\n"
"// Navigates between `p1` and `p2`. Returns the path as an array of `th.Vf2`s.\n"
"// If it doesn\'t find any path, or one of the points is outside of the mask,\n"
"// returns an empty array.\n"
"fn (m: ^Mesh) nav*(p1, p2: th::Vf2): []th::Vf2 {\n"
"//~~\n"
"\tif !coll::vf2ToRect(p1, m.r) || !coll::vf2ToRect(p2, m.r) {\n"
"\t\treturn {}\n"
"\t}\n"
"\n"
"\tcameFrom := umth_nav_mesh_nav(typeptr([]th::Vf2), m, p1, p2)\n"
"\n"
"\tpath := []th::Vf2{p2}\n"
"\tp := p2\n"
"\tp.x = trunc((p.x - m.r.x) / m.s)\n"
"\tp.y = trunc((p.y - m.r.y) / m.s)\n"
"\n"
"\tp1.x = trunc((p1.x - m.r.x) / m.s)\n"
"\tp1.y = trunc((p1.y - m.r.y) / m.s)\n"
"\tfor (p.x != p1.x || p.y != p1.y) && p.x >= 0 && p.y >= 0 {\n"
"\t\tp = cameFrom[trunc(p.x + p.y*m.w)]\n"
"\n"
"\t\tpath = append(path, th::Vf2{\n"
"\t\t\tp.x * m.s + m.r.x + m.s/2,\n"
"\t\t\tp.y * m.s + m.r.y + m.s/2 })\n"
"\t}\n"
"\n"
"\tfor i:=0; i < len(path)/2; i++ {\n"
"\t\tt := path[i]\n"
"\t\tpath[i] = path[len(path) - i - 1]\n"
"\t\tpath[len(path) - i - 1] = t\n"
"\t}\n"
"\n"
"\t// path not found is the first element is [-1; -1]\n"
"\tif len(path) > 0 && path[0].x < m.r.x {\n"
"\t\treturn []th::Vf2{}\n"
"\t}\n"
"\n"
"\treturn path\n"
"}\n"
"\n"
"//~~fn Mesh.draw\n"
"// Draws the mesh for debugging purposes.\n"
"fn (m: ^Mesh) draw*(alpha: real32 = 1.0) {\n"
"//~~\n"
"\tfor x:=0; x < m.w; x++ {\n"
"\t\tfor y:=0; y < len(m.d)/m.w; y += 1 {\n"
"\t\t\tc := th::cyan\n"
"\t\t\tif m.d[x + y*m.w] {\n"
"\t\t\t\tc = th::black\n"
"\t\t\t}\n"
"\t\t\tc = color::alpha(c, alpha)\n"
"\t\t\tcanvas::drawRect(c, rect::mk(m.r.x + x*m.s, m.r.y + y*m.s, m.s, m.s))\n"
"\t\t}\n"
"\t}\n"
"}\n"
"",
"//~~\n"
"// `ui.um` offers an immediate GUI library suitable both for simple game menus\n"
"// and more complex applications.\n"
"//~~\n"
"\n"
"import (\n"
"\t\"canvas.um\"\n"
"\t\"coll.um\"\n"
"\t\"image.um\"\n"
"\t\"input.um\"\n"
"\t\"placeholders.um\"\n"
"\t\"rect.um\"\n"
"\t\"th.um\"\n"
"\t\"utf8.um\"\n"
"\t\"window.um\"\n"
")\n"
"\n"
"//~~struct BoxStyle\n"
"// `BoxStyle` describes how a box within the GUI is styled.  In this case box\n"
"// can be anything, ranging from a button to a container.  By default the box\n"
"// is drawn using the `image.Image.drawNinepatch` method.  However if the image\n"
"// is invalid, a rectangle with color `color` is drawn.\n"
"type BoxStyle* = struct {\n"
"\timg: image::Image\n"
"\touter, inner: rect::Rect\n"
"\tscale: th::fu\n"
"\tcolor: uint32\n"
"}\n"
"//~~\n"
"\n"
"//~~interface Font\n"
"// This interface is used by all elements that draw text. A `font.Font`\n"
"// implements this interface.\n"
"type Font* = interface {\n"
"\tdraw(text: str, pos: th::Vf2, color: uint32, scale: th::fu = 1.0)\n"
"\tmeasure(test: str): th::Vf2\n"
"}\n"
"//~~\n"
"\n"
"//~~struct PixelFont\n"
"// This struct implement the `Font` interface using the `canvas.um` pixel font.\n"
"type PixelFont* = struct { }\n"
"//~~\n"
"\n"
"fn (this: ^PixelFont) draw*(t: str, p: th::Vf2, c: uint32, s: th::fu = 1.0) {\n"
"\tcanvas::drawText(t, p, c, s)\n"
"}\n"
"\n"
"fn (this: ^PixelFont) measure*(t: str): th::Vf2 {\n"
"\treturn canvas::textSize(t, 1)\n"
"}\n"
"\n"
"//~~struct Style\n"
"// `Style` is used as a global state for styling the GUI.\n"
"type Style* = struct {\n"
"\t// current font\n"
"\tft: Font\n"
"\t// font scale\n"
"\tftScale: th::fu\n"
"\t// text color\n"
"\tftColor: uint32\n"
"\n"
"\t// Positive box - i. e. unpressed button\n"
"\tposBox: BoxStyle\n"
"\t// Negative box - i. e. pressed button, text box\n"
"\tnegBox: BoxStyle\n"
"\t// Used to draw containers\n"
"\tcontainerBox: BoxStyle\n"
"}\n"
"//~~\n"
"\n"
"//~~interface Container\n"
"// Containers are used to layout elements or other containers.\n"
"type Container* = interface {\n"
"\t// This adds a rectangle to the container, and returns the rectangle\n"
"\t// which was actually added (the container can modify the rectangle).\n"
"\t// See individual containers for further documentation.\n"
"\tpushRect(r: rect::Rect): rect::Rect\n"
"\tgetDims(): rect::Rect\n"
"}\n"
"//~~\n"
"\n"
"//~~struct Gui\n"
"// This is the main struct of any UI.  Styles and containers are in a stack.\n"
"type Gui* = struct {\n"
"\t// user context passed to layout functions\n"
"\tctx: any\n"
"\n"
"\t// the index of the current selection. TODO implement properly\n"
"\tselection: int\n"
"\t// true, if the layout is being evaluated, not drawn\n"
"\tisEval: bool\n"
"\t// contains more unexported fields\n"
"//~~\n"
"\tidx: int\n"
"\n"
"\tm1Pressed: bool\n"
"\tm2Pressed: bool\n"
"\tm3Pressed: bool\n"
"\n"
"\tstyle: []Style\n"
"\tcontainer: []Container\n"
"}\n"
"\n"
"//~~fn mk\n"
"// Creates a new gui spanning `r`, with style `s`.\n"
"fn mk*(r: rect::Rect, s: Style): Gui\n"
"//~~\n"
"\n"
"//~~type LayoutFn\n"
"// The layout function calls different element or container methods to create\n"
"// the user interface itself.  It is called in the `eval` and `draw`.\n"
"type LayoutFn* = fn(gui: ^Gui)\n"
"//~~\n"
"\n"
"//~~fn BoxStyle.draw\n"
"// Draws a rectangle using a BoxStyle\n"
"fn (this: ^BoxStyle) draw*(r: rect::Rect) {\n"
"//~~\n"
"\tif !this.img.validate() {\n"
"\t\tcanvas::drawRect(this.color, r)\n"
"\t\treturn\n"
"\t}\n"
"\n"
"\tthis.img.drawNinepatch(this.outer, this.inner, r, this.color,\n"
"\t\tthis.scale)\n"
"}\n"
"\n"
"//~~fn Gui.pushStyle\n"
"// Pushes a style onto the style stack.\n"
"fn (this: ^Gui) pushStyle*(s: Style) {\n"
"//~~\n"
"\tthis.style = append(this.style, s)\n"
"}\n"
"\n"
"//~~fn Gui.popStyle\n"
"// Pops a style from the style stack.\n"
"fn (this: ^Gui) popStyle*() {\n"
"//~~\n"
"\tif len(this.style) > 1 {\n"
"\t\tthis.style = slice(this.style, 0, len(this.style) - 1)\n"
"\t}\n"
"}\n"
"\n"
"//~~fn Gui.getStyle\n"
"// Returns a pointer to the style atop the style stack.\n"
"fn (this: ^Gui) getStyle*(): ^Style {\n"
"//~~\n"
"\treturn &this.style[len(this.style) - 1]\n"
"}\n"
"\n"
"//~~fn Gui.getContainer\n"
"// Returns the container atop the container stack.\n"
"fn (this: ^Gui) getContainer*(): Container {\n"
"//~~\n"
"\treturn this.container[len(this.container) - 1]\n"
"}\n"
"\n"
"//~~fn Gui.pushRect\n"
"// Shortcut to `this.getContainer().pushRect(r)`\n"
"fn (this: ^Gui) pushRect*(r: rect::Rect): rect::Rect {\n"
"//~~\n"
"\treturn this.getContainer().pushRect(r)\n"
"}\n"
"\n"
"//~~fn Gui.getDims\n"
"// Shortcut to `this.getContainer().getDims(r)`\n"
"fn (this: ^Gui) getDims*(): rect::Rect {\n"
"//~~\n"
"\treturn this.getContainer().getDims()\n"
"}\n"
"\n"
"//~~fn Gui.dupStyle\n"
"// Duplicates the current style.\n"
"fn (this: ^Gui) dupStyle*() {\n"
"//~~\n"
"\tthis.pushStyle(this.getStyle()^)\n"
"}\n"
"\n"
"//~~fn Gui.pushContainer\n"
"// Pushes a container onto the container stack.\n"
"fn (this: ^Gui) pushContainer*(c: Container) {\n"
"//~~\n"
"\tthis.container = append(this.container, c)\n"
"}\n"
"\n"
"//~~fn Gui.popContainer\n"
"// Pops a container from the container stack.\n"
"fn (this: ^Gui) popContainer*() {\n"
"//~~\n"
"\tif len(this.container) > 1 {\n"
"\t\tthis.container =\n"
"\t\t\tslice(this.container, 0, len(this.container) - 1)\n"
"\t}\n"
"}\n"
"\n"
"fn (this: ^Gui) hover(r: rect::Rect): bool {\n"
"\treturn coll::vf2ToRect(input::getMousePos(), r)\n"
"}\n"
"\n"
"//~~fn Gui.eval\n"
"// Runs the evaluation phase on `layout`.\n"
"fn (this: ^Gui) eval*(layout: LayoutFn) {\n"
"//~~\n"
"\tif input::isJustPressed(input::Key.mouse1) { this.m1Pressed = true }\n"
"\tif input::isJustReleased(input::Key.mouse1) { this.m1Pressed = false }\n"
"\tif input::isJustPressed(input::Key.mouse2) { this.m2Pressed = true }\n"
"\tif input::isJustReleased(input::Key.mouse2) { this.m2Pressed = false }\n"
"\tif input::isJustPressed(input::Key.mouse3) { this.m3Pressed = true }\n"
"\tif input::isJustReleased(input::Key.mouse3) { this.m3Pressed = false }\n"
"\n"
"\tthis.idx = 0\n"
"\tthis.isEval = true\n"
"\tlayout(this)\n"
"\n"
"\tif this.hover(this.container[0].getDims()) {\n"
"\t\tinput::clear(input::Key.mouse1)\n"
"\t\tinput::clear(input::Key.mouse2)\n"
"\t\tinput::clear(input::Key.mouse3)\n"
"\t}\n"
"}\n"
"\n"
"//~~fn Gui.draw\n"
"// Runs the draw phase on `layout`.\n"
"fn (this: ^Gui) draw*(layout: LayoutFn) {\n"
"//~~\n"
"\tthis.idx = 0\n"
"\tthis.isEval = false\n"
"\tlayout(this)\n"
"}\n"
"\n"
"//~~enum BoxGrow\n"
"// The different types of \"growing\" the box can do.\n"
"type BoxGrow* = enum {\n"
"\tdimension\n"
"\tsubdiv\n"
"\tspan\n"
"\tpxSpan\n"
"}\n"
"//~~\n"
"\n"
"//~~enum BoxDirection\n"
"// Direction in which the box will grow.\n"
"type BoxDir* = enum {\n"
"\tdown\n"
"\tright\n"
"\tup\n"
"\tleft\n"
"}\n"
"//~~\n"
"\n"
"//~~struct BoxConfig\n"
"// Configuration of the `Box` container.\n"
"type BoxConfig* = struct {\n"
"\t// dimension to grow by if `BoxGrowDimension` is used\n"
"\tdimension: th::fu\n"
"\t// number of subdivisions if `BoxGrowSubdivisions` is used\n"
"\tsubdivisions: uint\n"
"\t// the grow type\n"
"\tgrowType: BoxGrow\n"
"\t// the grow direction\n"
"\tdir: BoxDir\n"
"\t// Specifies the values used with BoxGrowSpan nad BoxGrowPxSpan.\n"
"\t// If BoxGrowSpan is used, 1 equals the size of the box divided by the sum\n"
"\t// of all spans.\n"
"\t// If BoxGrowPxSpan is used, 1 equals one pixel.\n"
"\tspan: []th::fu\n"
"\t// rect passed to the current container\n"
"\trect: rect::Rect\n"
"\t// padding inserted after each element\n"
"\tpadding: th::fu\n"
"}\n"
"//~~\n"
"\n"
"//~~struct Box\n"
"// `Box` is the main layout.  It puts the elements next to each other,\n"
"// according to the config.\n"
"//\n"
"// If the dimensions of the rect passed to `pushRect` are non zero, they will\n"
"// be kept. Position is always forced.\n"
"type Box* = struct {\n"
"\tgrow: th::fu\n"
"\tspanCursor: int\n"
"\tdm: rect::Rect\n"
"\tcfg: BoxConfig\n"
"}\n"
"//~~\n"
"\n"
"fn (this: ^Box) getGrow(): th::fu {\n"
"\tswitch this.cfg.growType {\n"
"\t// These values are constant and can therefore be only calculated once.\n"
"\tcase BoxGrow.dimension:\n"
"\t\treturn this.grow\n"
"\tcase BoxGrow.subdiv:\n"
"\t\treturn this.grow\n"
"\tcase BoxGrow.span:\n"
"\t\t// We store the amount of pixels per a span in the grow array.\n"
"\t\tsp := this.cfg.span[this.spanCursor]\n"
"\t\tthis.spanCursor = (this.spanCursor + 1) % len(this.cfg.span)\n"
"\t\treturn sp * this.grow\n"
"\tcase BoxGrow.pxSpan:\n"
"\t\tsp := this.cfg.span[this.spanCursor]\n"
"\t\tthis.spanCursor = (this.spanCursor + 1) % len(this.cfg.span)\n"
"\t\treturn sp\n"
"\t}\n"
"\n"
"\treturn 0\n"
"}\n"
"\n"
"fn (this: ^Box) pushRect(r: rect::Rect): rect::Rect {\n"
"\tswitch this.cfg.dir {\n"
"\tcase BoxDir.down:\n"
"\t\tr.x = this.dm.x\n"
"\t\tr.y = this.dm.y\n"
"\n"
"\t\tif r.h == 0 {\n"
"\t\t\tr.h = this.getGrow()\n"
"\t\t}\n"
"\n"
"\t\tif r.w == 0 {\n"
"\t\t\tr.w = this.dm.w\n"
"\t\t}\n"
"\n"
"\t\tthis.dm.y += r.h + this.cfg.padding\n"
"\tcase BoxDir.right:\n"
"\t\tr.x = this.dm.x\n"
"\t\tr.y = this.dm.y\n"
"\n"
"\t\tif r.h == 0 {\n"
"\t\t\tr.h = this.dm.h\n"
"\t\t}\n"
"\n"
"\t\tif r.w == 0 {\n"
"\t\t\tr.w = this.getGrow()\n"
"\t\t}\n"
"\n"
"\t\tthis.dm.x += r.w + this.cfg.padding\n"
"\tcase BoxDir.up:\n"
"\t\tif r.h == 0 {\n"
"\t\t\tr.h = this.getGrow()\n"
"\t\t}\n"
"\n"
"\t\tif r.w == 0 {\n"
"\t\t\tr.w = this.dm.w\n"
"\t\t}\n"
"\n"
"\t\tthis.dm.h -= r.h + this.cfg.padding\n"
"\t\tr.x = this.dm.x\n"
"\t\tr.y = this.dm.y + this.dm.h\n"
"\tcase BoxDir.left:\n"
"\t\tif r.h == 0 {\n"
"\t\t\tr.h = this.dm.h\n"
"\t\t}\n"
"\n"
"\t\tif r.w == 0 {\n"
"\t\t\tr.w = this.getGrow()\n"
"\t\t}\n"
"\n"
"\t\tthis.dm.w -= r.w + this.cfg.padding\n"
"\t\tr.x = this.dm.x + this.dm.w\n"
"\t\tr.y = this.dm.y\n"
"\t}\n"
"\n"
"\treturn r\n"
"}\n"
"\n"
"fn (this: ^Box) getDims(): rect::Rect {\n"
"\treturn this.dm\n"
"}\n"
"\n"
"//~~fn Gui.box\n"
"// Adds the `Box` container to the gui.\n"
"fn (gui: ^Gui) box*(cfg: BoxConfig = {\n"
"\tdimension: 30,\n"
"\tgrowType: BoxGrow.dimension,\n"
"\tdir: BoxDir.down }) {\n"
"//~~\n"
"\n"
"\tb := Box{}\n"
"\tb.dm = gui.pushRect(cfg.rect)\n"
"\tb.cfg = cfg\n"
"\n"
"\tdm := b.dm.h\n"
"\tif cfg.dir == BoxDir.right || cfg.dir == BoxDir.left {\n"
"\t\tdm = b.dm.w\n"
"\t}\n"
"\tdm += b.cfg.padding\n"
"\n"
"\tswitch cfg.growType {\n"
"\tcase BoxGrow.dimension:\n"
"\t\tb.grow = cfg.dimension\n"
"\tcase BoxGrow.subdiv:\n"
"\t\tif cfg.subdivisions == 0 {\n"
"\t\t\tth::__error(\"Invalid subdivision count\")\n"
"\t\t}\n"
"\n"
"\t\tb.grow = dm / cfg.subdivisions\n"
"\tcase BoxGrow.span:\n"
"\t\ts := th::fu(0)\n"
"\t\tfor _,v in b.cfg.span {\n"
"\t\t\ts += v\n"
"\t\t}\n"
"\n"
"\t\tb.grow = dm / s\n"
"\t}\n"
"\n"
"\tif !gui.isEval {\n"
"\t\tgui.getStyle().containerBox.draw(b.dm)\n"
"\t}\n"
"\n"
"\tgui.pushContainer(b)\n"
"}\n"
"\n"
"//~~struct StackConfig\n"
"// Configuration for the `Stack` container.\n"
"type StackConfig* = struct {\n"
"\trect: rect::Rect\n"
"\tpadding: th::fu\n"
"}\n"
"//~~\n"
"\n"
"//~~struct Stack\n"
"// The stack container puts elements on top of each other.\n"
"// If a property of the rect passed to `pushRect` is zero, it will be changed\n"
"// to an equivalent property of the containers\' dimensions (minus the padding),\n"
"// else it will stay the same.  This means stack can be used either to put\n"
"// multiple elements/containers on top of each other, or for absolutely\n"
"// positioned elements.\n"
"type Stack* = struct {\n"
"\tdm: rect::Rect\n"
"\tcfg: StackConfig\n"
"}\n"
"//~~\n"
"\n"
"fn (this: ^Stack) pushRect(r: rect::Rect): rect::Rect {\n"
"\tr.x += this.dm.x + this.cfg.padding\n"
"\tr.y += this.dm.y + this.cfg.padding\n"
"\tif r.w == 0 { r.w = this.dm.w - 2*this.cfg.padding }\n"
"\tif r.h == 0 { r.h = this.dm.h - 2*this.cfg.padding }\n"
"\n"
"\treturn r\n"
"}\n"
"\n"
"fn (this: ^Stack) getDims(): rect::Rect {\n"
"\treturn this.dm\n"
"}\n"
"\n"
"//~~fn Gui.stack\n"
"// Adds the `Stack` container to the gui.\n"
"fn (gui: ^Gui) stack*(cfg: StackConfig = {}) {\n"
"//~~\n"
"\tgui.pushContainer(Stack{\n"
"\t\tdm: gui.pushRect(cfg.rect),\n"
"\t\tcfg: cfg })\n"
"\n"
"\tif !gui.isEval {\n"
"\t\tgui.getStyle().containerBox.draw(gui.getContainer().getDims())\n"
"\t}\n"
"}\n"
"\n"
"//~~struct ScrollAreaConfig\n"
"// Configuration for the scroll area.\n"
"type ScrollAreaConfig* = struct {\n"
"\trect: rect::Rect\n"
"\t// scroll speed. Default is 1\n"
"\tspeed: real32\n"
"\t// if true, scrolling will be horizontal\n"
"\thorizontal: bool\n"
"}\n"
"//~~\n"
"\n"
"//~~struct ScrollArea\n"
"// Scroll area is a container which allows the user to scroll. It acts as a\n"
"// stack container, but all the elements are shifted by the scroll.\n"
"type ScrollArea* = struct {\n"
"\tdm: rect::Rect\n"
"\tcfg: ScrollAreaConfig\n"
"\tscroll: ^real32\n"
"\tmaxScroll: real32\n"
"}\n"
"//~~\n"
"\n"
"fn (this: ^ScrollArea) pushRect(r: rect::Rect): rect::Rect {\n"
"\tif r.x == 0 { r.x = this.dm.x }\n"
"\tif r.y == 0 { r.y = this.dm.y }\n"
"\tif this.cfg.horizontal {\n"
"\t\tif r.w == 0 { r.w = this.maxScroll }\n"
"\t\tif r.h == 0 { r.h = this.dm.h }\n"
"\t\treturn { r.x - this.scroll^, r.y, r.w, r.h }\n"
"\t}\n"
"\n"
"\tif r.w == 0 { r.w = this.dm.w }\n"
"\tif r.h == 0 { r.h = this.maxScroll }\n"
"\treturn { r.x, r.y - this.scroll^, r.w, r.h }\n"
"}\n"
"\n"
"fn (this: ^ScrollArea) getDims(): rect::Rect {\n"
"\treturn this.dm\n"
"}\n"
"\n"
"//~~fn Gui.scrollArea\n"
"// Pushes a scroll area. `scroll` is both input and output value. Both `scroll`\n"
"// and `maxScroll` are in pixels.\n"
"fn (gui: ^Gui) scrollArea*(scroll: ^real32, maxScroll: real32, cfg: ScrollAreaConfig = {}) {\n"
"//~~\n"
"\tif cfg.speed == 0 {\n"
"\t\tcfg.speed = 1\n"
"\t}\n"
"\n"
"\tthis := ScrollArea{\n"
"\t\tdm: gui.pushRect(cfg.rect),\n"
"\t\tcfg: cfg,\n"
"\t\tscroll: scroll }\n"
"\tgui.pushContainer(this)\n"
"\n"
"\tdm := this.dm.h\n"
"\tif this.cfg.horizontal {\n"
"\t\tdm = this.dm.w\n"
"\t}\n"
"\n"
"\tif maxScroll < dm {\n"
"\t\tscroll ^= 0\n"
"\t\treturn\n"
"\t}\n"
"\n"
"\tif gui.isEval && gui.hover(this.dm) {\n"
"\t\tv := input::getMouseScroll().y\n"
"\t\tif this.cfg.horizontal {\n"
"\t\t\tv = input::getMouseScroll().x\n"
"\t\t}\n"
"\n"
"\t\tscroll ^= scroll^ - v*th::delta*this.cfg.speed\n"
"\t\tif scroll^ < 0 { scroll^ = 0 }\n"
"\t\tif maxScroll > dm && scroll^ >= maxScroll - dm { scroll^ = maxScroll - dm }\n"
"\t\tif maxScroll < dm && scroll^ >= maxScroll { scroll^ = maxScroll }\n"
"\t}\n"
"}\n"
"\n"
"//~~struct ButtonConfig\n"
"// Configuration for the button.\n"
"type ButtonConfig* = struct {\n"
"\trect: rect::Rect\n"
"}\n"
"//~~\n"
"\n"
"//~~fn Gui.button\n"
"// Adds a button to the gui.  The button acts like a `Stack` container, but it\n"
"// is drawn using the pos/nexBox styles and handles clicks. If the button is\n"
"// pressed and the gui is in the eval phase, the return value will be true.\n"
"fn (gui: ^Gui) button*(cfg: ButtonConfig = {}): bool {\n"
"//~~\n"
"\tgui.stack(StackConfig{ rect: cfg.rect })\n"
"\tr := gui.getContainer().getDims()\n"
"\n"
"\tif gui.isEval {\n"
"\t\tif gui.hover(r) && input::isJustReleased(input::Key.mouse1) {\n"
"\t\t\treturn true\n"
"\t\t}\n"
"\t\treturn false\n"
"\t} else {\n"
"\t\tif gui.hover(r) && gui.m1Pressed {\n"
"\t\t\tgui.getStyle().negBox.draw(r)\n"
"\t\t} else {\n"
"\t\t\tgui.getStyle().posBox.draw(r)\n"
"\t\t}\n"
"\t}\n"
"\n"
"\treturn false\n"
"}\n"
"\n"
"//~~struct LabelConfig\n"
"type LabelConfig* = struct {\n"
"\t// centers the label along the X axis, enables `stretchX`\n"
"\tcenterX: bool\n"
"\t// centers the label along the Y axis, enables `stretchY`\n"
"\tcenterY: bool\n"
"\t// if false, the rect passed to `pushRect` will have the width of\n"
"\t// the text, else it will be 0\n"
"\tstretchX: bool\n"
"\t// if false, the rect passed to `pushRect` will have the height of\n"
"\t// the text, else it will be 0\n"
"\tstretchY: bool\n"
"\t// forces the rectangle the label will use\n"
"\trect: rect::Rect\n"
"}\n"
"//~~\n"
"\n"
"//~~fn Gui.label\n"
"// Draws a label using the current font style.\n"
"fn (gui: ^Gui) label*(text: str, cfg: LabelConfig = {\n"
"//~~\n"
"\tstretchX: true,\n"
"\tstretchY: true }) {\n"
"\n"
"\tif cfg.centerX { cfg.stretchX = true }\n"
"\tif cfg.centerY { cfg.stretchY = true }\n"
"\n"
"\tr := cfg.rect\n"
"\tstyle := gui.getStyle()\n"
"\ttxtSize := style.ft.measure(text).mulf(style.ftScale)\n"
"\tif r.w == 0 { r.w = txtSize.x }\n"
"\tif r.h == 0 { r.h = txtSize.y }\n"
"\n"
"\tif cfg.stretchX { r.w = 0 }\n"
"\tif cfg.stretchY { r.h = 0 }\n"
"\tr = gui.pushRect(r)\n"
"\n"
"\tif gui.isEval { return }\n"
"\n"
"\tx := r.x\n"
"\ty := r.y\n"
"\tif cfg.centerX {\n"
"\t\tx += (r.w-txtSize.x)/2.0\n"
"\t}\n"
"\tif cfg.centerY {\n"
"\t\ty += (r.h-txtSize.y)/2.0\n"
"\t}\n"
"\n"
"\tstyle.ft.draw(text, {x, y},\n"
"\t\tstyle.ftColor, style.ftScale)\n"
"}\n"
"\n"
"//~~fn Gui.qbutton\n"
"// Adds a button with a label to gui.\n"
"fn (gui: ^Gui) qbutton*(text: str, cfg: ButtonConfig = {}): bool {\n"
"//~~\n"
"\tpressed := gui.button(cfg)\n"
"\tgui.label(text, LabelConfig{centerX: true, centerY: true})\n"
"\tgui.popContainer()\n"
"\treturn pressed;\n"
"}\n"
"\n"
"//~~struct TextBoxConfig\n"
"type TextBoxConfig* = struct {\n"
"\t// force the rect of the text box\n"
"\trect: rect::Rect\n"
"}\n"
"//~~\n"
"\n"
"//~~struct TextBox\n"
"type TextBox* = struct {\n"
"\t// index of the cursor\n"
"\tcursor: int\n"
"\t// contains other unexported rules...\n"
"//~~\n"
"\tbuffer: []utf8::Rune\n"
"}\n"
"\n"
"//~~fn TextBox.clear\n"
"// Clears the textbox\n"
"fn (this: ^TextBox) clear*() {\n"
"//~~\n"
"\tthis.buffer = {}\n"
"\tthis.cursor = 0\n"
"}\n"
"\n"
"//~~fn TextBox.getBuf()\n"
"// Get the content of the textbox.\n"
"fn (this: ^TextBox) getBuf*(): str {\n"
"//~~\n"
"\treturn utf8::encode(this.buffer)\n"
"}\n"
"\n"
"//~~fn TextBox.setBuf()\n"
"// Get the content of the textbox.\n"
"fn (this: ^TextBox) setBuf*(s: str) {\n"
"//~~\n"
"\tthis.buffer = utf8::decode(s)\n"
"\tthis.cursor = len(this.buffer)\n"
"}\n"
"\n"
"//~~fn Gui.textBox\n"
"// Adds a single line textbox to the gui.\n"
"// TODO:\n"
"// * right-to-left unicode is not supported.\n"
"// * no selection\n"
"// * multiline\n"
"// * copy paste (now implemented but in a limited way due to the lack of selection)\n"
"// * common input shortcuts\n"
"//   - ctrl+delete / ctrl+backspace (delete word)\n"
"fn (gui: ^Gui) textBox*(tb: ^TextBox, cfg: TextBoxConfig = {}) {\n"
"//~~\n"
"\tgui.idx++\n"
"\n"
"\tr := gui.pushRect(cfg.rect)\n"
"\n"
"\thover := gui.hover(r)\n"
"\n"
"\tif gui.isEval {\n"
"\t\tif input::isJustPressed(input::Key.mouse1) && hover {\n"
"\t\t\tgui.selection = gui.idx\n"
"\t\t}\n"
"\n"
"\t\tif input::isJustPressed(input::Key.mouse1) && !hover &&\n"
"\t\t\tgui.selection == gui.idx {\n"
"\t\t\t\tgui.selection = 0\n"
"\t\t}\n"
"\n"
"\t\tif input::isJustPressed(input::Key.escape) && gui.selection == gui.idx {\n"
"\t\t\tgui.selection = 0\n"
"\t\t}\n"
"\n"
"\t\tif gui.selection != gui.idx {\n"
"\t\t\treturn\n"
"\t\t}\n"
"\n"
"\t\tif input::isPressedRepeat(input::Key.backspace) {\n"
"\n"
"\t\t\tif tb.cursor > 0 {\n"
"\t\t\t\ttb.buffer = append(slice(tb.buffer, 0, tb.cursor - 1), slice(tb.buffer, tb.cursor))\n"
"\t\t\t\ttb.cursor--\n"
"\t\t\t}\n"
"\t\t}\n"
"\n"
"\t\tif input::isPressedRepeat(input::Key.delete) {\n"
"\n"
"\t\t\tif tb.cursor >= 0 && tb.cursor < len(tb.buffer) {\n"
"\t\t\t\ttb.buffer = append(slice(tb.buffer, 0, tb.cursor), slice(tb.buffer, tb.cursor+1))\n"
"\t\t\t}\n"
"\t\t}\n"
"\n"
"\t\tif input::isPressedRepeat(input::Key.home) {\n"
"\t\t\ttb.cursor = 0\n"
"\t\t}\n"
"\n"
"\t\tif input::isPressedRepeat(input::Key.end) {\n"
"\t\t\ttb.cursor = len(tb.buffer)\n"
"\t\t}\n"
"\n"
"\t\tv := true\n"
"\n"
"\t\tif input::isPressed(input::Key.ctrl) && input::isJustPressedc(\'v\') {\n"
"\t\t\ttoInsert := utf8::decode(window::getClipboard())\n"
"\n"
"\t\t\ttb.buffer = append(append(slice(tb.buffer, 0, tb.cursor), toInsert), slice(tb.buffer, tb.cursor))\n"
"\t\t\ttb.cursor += len(toInsert)\n"
"\t\t\tv = false\n"
"\t\t}\n"
"\n"
"\t\tif input::isPressed(input::Key.ctrl) && input::isJustPressedc(\'c\') {\n"
"\t\t\twindow::setClipboard(utf8::encode(tb.buffer))\n"
"\t\t\tv = false\n"
"\t\t}\n"
"\n"
"\t\tif input::isPressed(input::Key.ctrl) && input::isJustPressedc(\'u\') {\n"
"\t\t\ttb.clear()\n"
"\t\t\tv = false\n"
"\t\t}\n"
"\n"
"\t\tconst isRuneSpace = fn (r: utf8::Rune): bool {\n"
"\t\t\treturn r == utf8::Rune(\' \') || r == utf8::Rune(\'\\t\') || r == utf8::Rune(\'\\n\')\n"
"\t\t}\n"
"\n"
"\t\tif input::isPressed(input::Key.ctrl) && input::isPressedRepeat(input::Key.left) {\n"
"\t\t\t// skip spaces\n"
"\t\t\tfor tb.cursor > 0 && isRuneSpace(tb.buffer[tb.cursor-1]) {\n"
"\t\t\t\ttb.cursor--\n"
"\t\t\t}\n"
"\n"
"\t\t\tfor tb.cursor > 0 && !isRuneSpace(tb.buffer[tb.cursor-1]) {\n"
"\t\t\t\ttb.cursor--\n"
"\t\t\t}\n"
"\t\t\tv = false\n"
"\t\t}\n"
"\n"
"\t\tif input::isPressed(input::Key.ctrl) && input::isPressedRepeat(input::Key.right) {\n"
"\t\t\t// skip spaces\n"
"\t\t\tfor tb.cursor < len(tb.buffer) && isRuneSpace(tb.buffer[tb.cursor]) {\n"
"\t\t\t\ttb.cursor++\n"
"\t\t\t}\n"
"\n"
"\t\t\tfor tb.cursor < len(tb.buffer) && !isRuneSpace(tb.buffer[tb.cursor]) {\n"
"\t\t\t\ttb.cursor++\n"
"\t\t\t}\n"
"\t\t\tv = false\n"
"\t\t}\n"
"\n"
"\t\tif input::isPressedRepeat(input::Key.left) && v {\n"
"\t\t\tif tb.cursor > 0 { tb.cursor-- }\n"
"\t\t}\n"
"\n"
"\t\tif input::isPressedRepeat(input::Key.right) && v {\n"
"\t\t\tif tb.cursor < len(tb.buffer) { tb.cursor++ }\n"
"\t\t}\n"
"\n"
"\t\trunes := utf8::decode(input::getStr())\n"
"\t\tif len(runes) > 0 && v {\n"
"\t\t\ttb.buffer = append(append(slice(tb.buffer, 0, tb.cursor), runes), slice(tb.buffer, tb.cursor))\n"
"\t\t\ttb.cursor += len(runes)\n"
"\t\t}\n"
"\n"
"\t\treturn\n"
"\t}\n"
"\n"
"\tstyle := gui.getStyle()\n"
"\n"
"\tstyle.negBox.draw(r)\n"
"\tcanvas::beginScissorRect(r)\n"
"\n"
"\tbuf := utf8::encode(tb.buffer)\n"
"\tdm := style.ft.measure(buf).mulf(style.ftScale)\n"
"\n"
"\tp := th::Vf2{}\n"
"\tp.y = r.y + r.h/2 - dm.y/2\n"
"\tc := th::Vf2{r.x, p.y}\n"
"\n"
"\tcdmx := style.ft.measure(utf8::encode(slice(tb.buffer, 0, tb.cursor))).x * style.ftScale\n"
"\tif cdmx < r.w - 2 {\n"
"\t\tp.x = r.x + 1\n"
"\t\tc.x = p.x + cdmx\n"
"\t} else {\n"
"\t\tc.x = r.x + r.w - 1\n"
"\t\tp.x = c.x - cdmx\n"
"\t}\n"
"\n"
"\taW := style.ft.measure(\"A\").x * style.ftScale\n"
"\n"
"\tstyle.ft.draw(buf, p, style.ftColor, style.ftScale)\n"
"\tif gui.selection == gui.idx {\n"
"\t\tcanvas::drawRect(style.ftColor, rect::mk(c.x, c.y, aW / 4, dm.y))\n"
"\t}\n"
"\n"
"\tcanvas::endScissor()\n"
"}\n"
"\n"
"//~~struct ImageConfig\n"
"// Configuration for the images element. Behaves similarly to labels.\n"
"type ImageConfig* = struct {\n"
"\tstretchX, stretchY: bool\n"
"\tcenterX, centerY: bool\n"
"\tcolor: uint32\n"
"\tscale: th::Vf2\n"
"\trect: rect::Rect\n"
"}\n"
"//~~\n"
"\n"
"//~~fn Gui.image\n"
"// Draws an image.\n"
"fn (gui: ^Gui) image*(i: image::Image, cfg: ImageConfig = {\n"
"\tstretchX: true,\n"
"\tstretchY: true,\n"
"\tcolor: th::white,\n"
"\tscale: { 1, 1 } }) {\n"
"//~~\n"
"\n"
"\tif cfg.centerX { cfg.stretchX = true }\n"
"\tif cfg.centerY { cfg.stretchY = true }\n"
"\n"
"\tr := cfg.rect\n"
"\tdm := i.getDims().mul(cfg.scale)\n"
"\tif r.w == 0 { r.w = dm.x }\n"
"\tif r.h == 0 { r.h = dm.y }\n"
"\n"
"\tif cfg.stretchX { r.w = 0 }\n"
"\tif cfg.stretchY { r.h = 0 }\n"
"\n"
"\tr = gui.pushRect(r)\n"
"\n"
"\tif gui.isEval { return }\n"
"\n"
"\tx := r.x\n"
"\ty := r.y\n"
"\tif cfg.centerX {\n"
"\t\tx += (r.w - dm.x) / 2\n"
"\t}\n"
"\n"
"\tif cfg.centerY {\n"
"\t\ty += (r.h - dm.y) / 2\n"
"\t}\n"
"\n"
"\ti.draw(th::Transform{\n"
"\t\tp: { x, y },\n"
"\t\ts: cfg.scale }, cfg.color)\n"
"}\n"
"\n"
"//~~fn getDefaultStyle\n"
"// Returns the default tophat ui style.\n"
"fn getDefaultStyle*(): Style {\n"
"//~~\n"
"\treturn {\n"
"\t\tft: PixelFont{},\n"
"\t\tftScale: 1,\n"
"\t\tftColor: th::black,\n"
"\n"
"\t\tposBox: {\n"
"\t\t\timg: placeholders::button,\n"
"\t\t\touter: { 0, 0, 5, 5 },\n"
"\t\t\tinner: { 2, 2, 1, 1 },\n"
"\t\t\tscale: 1,\n"
"\t\t\tcolor: th::white },\n"
"\t\tnegBox: {\n"
"\t\t\timg: placeholders::button,\n"
"\t\t\touter: { 5, 0, 5, 5 },\n"
"\t\t\tinner: { 2, 2, 1, 1 },\n"
"\t\t\tscale: 1,\n"
"\t\t\tcolor: th::white },\n"
"\t\tcontainerBox: {\n"
"\t\t\tcolor: 0x888888ff } }\n"
"}\n"
"\n"
"//~~fn mk\n"
"// Creates a GUI instance.\n"
"fn mk*(r: rect::Rect, s: Style): Gui {\n"
"//~~\n"
"\tgui := Gui{}\n"
"\tgui.pushStyle(s)\n"
"\tgui.container = []Container{ Stack{ dm: r } }\n"
"\n"
"\treturn gui\n"
"}\n"
"",
};
const char *th_em_modulenames[] = { "anim.um", "audio.um", "csv.um", "ent.um", "image.um", "input.um", "misc.um", "canvas.um", "rect.um", "tilemap.um", "window.um", "particles.um", "lerp.um", "font.um", "th.um", "signal.um", "atlas.um", "shader.um", "color.um", "coll.um", "placeholders.um", "nav.um", "ui.um",  };
int th_em_modulenames_count = 23;
const char *th_em_misc[] = {
"BSD 3-Clause License\n"
"\n"
"Copyright (c) 2023, Marek Maskarinec\n"
"All rights reserved.\n"
"\n"
"Redistribution and use in source and binary forms, with or without\n"
"modification, are permitted provided that the following conditions are met:\n"
"\n"
"1. Redistributions of source code must retain the above copyright notice, this\n"
"   list of conditions and the following disclaimer.\n"
"\n"
"2. Redistributions in binary form must reproduce the above copyright notice,\n"
"   this list of conditions and the following disclaimer in the documentation\n"
"   and/or other materials provided with the distribution.\n"
"\n"
"3. Neither the name of the copyright holder nor the names of its\n"
"   contributors may be used to endorse or promote products derived from\n"
"   this software without specific prior written permission.\n"
"\n"
"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n"
"AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n"
"IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n"
"DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n"
"FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n"
"DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n"
"SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n"
"CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n"
"OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n"
"OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
"",
"v1.4\n"
"",
};
const char *th_em_moduledocs[] = {
"[1mstruct Anim[0m\n"
"\n"
"[3mtype Anim* = struct {\n"
"\t// the source atlas\n"
"\tatl: atlas::Atlas\n"
"\t// the first cell of the animation\n"
"\tmin: int\n"
"\t// the last cell of the animation\n"
"\tmax: int\n"
"\tfps: real32\n"
"\t// offset in time\n"
"\toffset: int\n"
"}\n"
"[0m\n"
"Anim allows you to animate between individual frames of an atlas.\n"
"\n"
"---------\n"
"\n"
"[1mfn mk[0m\n"
"\n"
"[3mfn mk*(atl: atlas::Atlas, fps: int, min: int = 0, max: int = -1 /* len(atl) - 1 */, offset: int = -1 /* th.time */): Anim {\n"
"[0m\n"
"`Anim` constructor\n"
"\n"
"---------\n"
"\n"
"[1mfn Anim.animate[0m\n"
"\n"
"[3mfn (anm: ^Anim) animate*(time: int) {\n"
"[0m\n"
"Crops the base atlas to the cell that should be visible at `time`.\n"
"\n"
"---------\n"
"\n"
"[1mfn Anim.framesPlayed[0m\n"
"\n"
"[3mfn (anm: ^Anim) framesPlayed*(time: int): int {\n"
"[0m\n"
"Returns how many frames were played at `time`.\n"
"\n"
"---------\n"
"\n"
"",
"[1m[0m\n"
"\n"
"[3m[0m\n"
"Module for audio loading and playback.\n"
"\n"
"---------\n"
"\n"
"[1mopaque Sound[0m\n"
"\n"
"[3mtype Sound* = struct { _: ^struct{} }\n"
"[0m\n"
"Represents an instance of a playable sound. It is an opaque structure.\n"
"\n"
"---------\n"
"\n"
"[1menum LoadFlag[0m\n"
"\n"
"[3mtype LoadFlag* = enum (uint32) {\n"
"\tnone = 0\n"
"\t// Streams the audio, only saving 2 seconds into memory.\n"
"\tstream = 1\n"
"\t// Loads the sound in async. Use `audio.waitForLoad` to wait for the\n"
"\t// sounds to load.\n"
"\tasync = 4\n"
"}\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1mfn load[0m\n"
"\n"
"[3mfn load*(path: str, flags: LoadFlag = LoadFlag.none): (Sound, std::Err) {\n"
"[0m\n"
"Loads a sounds at path, if there is an error, the underlying pointer\n"
"will be `NULL` and `validate` will return false.\n"
"\n"
"---------\n"
"\n"
"[1mfn Sound.validate[0m\n"
"\n"
"[3mfn (s: ^Sound) validate*(): bool {\n"
"[0m\n"
"Returns `true` if `s` loaded correctly.\n"
"\n"
"---------\n"
"\n"
"[1mfn Sound.copy[0m\n"
"\n"
"[3mfn (s: ^Sound) copy*(): (Sound, std::Err) {\n"
"[0m\n"
"Copies the sound. This will create another sound which can be configured\n"
"and played independently from the original sound.\n"
"\n"
"---------\n"
"\n"
"[1mfn Sound.isPlaying[0m\n"
"\n"
"[3mfn (s: ^Sound) isPlaying*(): bool {\n"
"[0m\n"
"Returns true if the sound is still playing.\n"
"\n"
"---------\n"
"\n"
"[1mfn Sound.play[0m\n"
"\n"
"[3mfn (s: ^Sound) play*() {\n"
"[0m\n"
"Plays the sound.\n"
"\n"
"---------\n"
"\n"
"[1mfn Sound.start[0m\n"
"\n"
"[3mfn (s: ^Sound) start*(): (^Sound, std::Err) {\n"
"[0m\n"
"The start function allows you to play a single sound multiple times.\n"
"It will create a copy and return a pointer to it, so you can controll it\n"
"while it is playing. The returned pointer can be discarded.\n"
"\n"
"---------\n"
"\n"
"[1mfn Sound.stop[0m\n"
"\n"
"[3mfn (s: ^Sound) stop*() {\n"
"[0m\n"
"Stops the sound, but keeps the progress. If you want to start from the\n"
"begginning, use `audio.Sound.seekToFrame(0)`.\n"
"\n"
"---------\n"
"\n"
"[1mfn Sound.setVol[0m\n"
"\n"
"[3mfn (s: ^Sound) setVol*(vol: real32) {\n"
"[0m\n"
"Sets the volume as a multiplier of the base volume.\n"
"\n"
"---------\n"
"\n"
"[1mfn Sound.setPan[0m\n"
"\n"
"[3mfn (s: ^Sound) setPan*(pan: real32) {\n"
"[0m\n"
"Sets the pan of the sound.\n"
"\n"
"---------\n"
"\n"
"[1mfn Sound.setPitch[0m\n"
"\n"
"[3mfn (s: ^Sound) setPitch*(pitch: real32) {\n"
"[0m\n"
"Sets the pitch of the sound.\n"
"\n"
"---------\n"
"\n"
"[1mfn Sound.setLooping[0m\n"
"\n"
"[3mfn (s: ^Sound) setLooping*(looping: bool) {\n"
"[0m\n"
"Sets whether the sound will loop upon finishing.\n"
"\n"
"---------\n"
"\n"
"[1mfn Sound.seekToFrame[0m\n"
"\n"
"[3mfn (s: ^Sound) seekToFrame*(frame: uint) {\n"
"[0m\n"
"Seeks to a specified PCM frame.\n"
"\n"
"---------\n"
"\n"
"[1mfn Sound.frameCount[0m\n"
"\n"
"[3mfn (s: ^Sound) frameCount*(): uint {\n"
"[0m\n"
"Returns length of the sound in PCM frames.\n"
"\n"
"---------\n"
"\n"
"[1mfn Sound.lengthMs[0m\n"
"\n"
"[3mfn (s: ^Sound) lengthMs*(): uint {\n"
"[0m\n"
"Returns length of the sound in ms.\n"
"\n"
"---------\n"
"\n"
"[1mfn Sound.setStartTimeMs[0m\n"
"\n"
"[3mfn (s: ^Sound) setStartTimeMs*(t: uint) {\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1mfn Sound.setStopTimeMs[0m\n"
"\n"
"[3mfn (s: ^Sound) setStopTimeMs*(t: uint) {\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"",
"[1m[0m\n"
"\n"
"[3m[0m\n"
"A CSV parser, which also works for similar formats. It doesn\'t support\n"
"quotes, but you can escape characters using a backslash.\n"
"\n"
"---------\n"
"\n"
"[1mfn parse[0m\n"
"\n"
"[3mfn parse*(inp: str, sep: char = \',\'): [][]str {\n"
"[0m\n"
"Parses input into a 2d string array.\n"
"\n"
"---------\n"
"\n"
"[1mfn encode[0m\n"
"\n"
"[3mfn encode*(inp: [][]str, sep: char = \',\'): str {\n"
"[0m\n"
"Converts 2d array to csv string.\n"
"\n"
"---------\n"
"\n"
"",
"[1mstruct Ent[0m\n"
"\n"
"[3mtype Ent* = struct {\n"
"\t// used as a collider, used as backup when invalid image is supplied\n"
"\tr: rect::Rect\n"
"\t// used in drawing\n"
"\ti: image::Image\n"
"\t// used to transform and translate the image and rect\n"
"\tt: th::Transform\n"
"\t// used as a color of the rect and a color filter for the image\n"
"\tc: uint32\n"
"}\n"
"[0m\n"
"Entity is the main game object. It features drawing and collisions.\n"
"Every entity has an image used for drawing and a rectangle used\n"
"for collisions. It also has a transform used for transforming it\'s image\n"
"and rectangle.\n"
"\n"
"---------\n"
"\n"
"[1mstruct Coll[0m\n"
"\n"
"[3mtype Coll* = struct {\n"
"\tindex: th::uu\n"
"\tpos: th::Vf2\n"
"}\n"
"[0m\n"
"Value returned by get coll. It contains a position where the collision\n"
"happened and the index of the entity involved in said collision.\n"
"\n"
"---------\n"
"\n"
"[1mfn Ent.draw[0m\n"
"\n"
"[3mfn (e: ^Ent) draw*() {\n"
"[0m\n"
"Draws the entity onto the screen.\n"
"\n"
"---------\n"
"\n"
"[1mfn mk[0m\n"
"\n"
"[3mfn mk*(img: image::Image = image::Image{}, t: th::Transform = th::Transform{ s: {1, 1} }): Ent {\n"
"[0m\n"
"ent\'s constructor\n"
"\n"
"---------\n"
"\n"
"[1mfn Ent.getColl[0m\n"
"\n"
"[3mfn (e: ^Ent) getColl*(s: []^Ent, maxColls: th::uu): []Coll {\n"
"[0m\n"
"Checks collisions of e with entities in s. Checks at max maxColl collisions.\n"
"If s contains e, the collision won\'t be returned.\n"
"\n"
"---------\n"
"\n"
"[1mfn Ent.animate[0m\n"
"\n"
"[3mfn (e: ^Ent) animate*(fps: int, frames: ^[]image::Image, t: int) {\n"
"[0m\n"
"Animates the entity\'s image with one of the `anim` array. <b>Won\'t</b> begin on\n"
"the first frame. If you want that, use anim.Anim.\n"
"\n"
"---------\n"
"\n"
"",
"[1mopaque Image[0m\n"
"\n"
"[3mtype Image* = struct{ _: ^struct{} }\n"
"[0m\n"
"Represents a drawable image. It is an opaque structure.\n"
"Images support a color filter. It is applied by multiplying the color\n"
"of each pixel with the filter.\n"
"\n"
"---------\n"
"\n"
"[1mopaque RenderTarget[0m\n"
"\n"
"[3mtype RenderTarget* = struct { _: ^struct{} }\n"
"[0m\n"
"An image you can render to.\n"
"\n"
"---------\n"
"\n"
"[1mfn createRenderTarget[0m\n"
"\n"
"[3mfn createRenderTarget*(size: th::Vf2, filter: int): (RenderTarget, std::Err) {\n"
"[0m\n"
"Creates a render target you can draw to, like to a window.\n"
"Filter specifies specfifies filtering for resulting image.\n"
"Image can be retrieved via `toImage`.\n"
"\n"
"---------\n"
"\n"
"[1mfn RenderTarget.end[0m\n"
"\n"
"[3mfn (rt: ^RenderTarget) begin*(): std::Err {\n"
"[0m\n"
"Begins the render target rendering pass.\n"
"\n"
"---------\n"
"\n"
"[1mfn RenderTarget.end[0m\n"
"\n"
"[3mfn (rt: ^RenderTarget) end*(wp: th::Vf2): std::Err {\n"
"[0m\n"
"Ends the render target rendering pass.\n"
"\n"
"---------\n"
"\n"
"[1mfn RenderTarget.toImage[0m\n"
"\n"
"[3mfn (rt: ^RenderTarget) toImage*(): Image {\n"
"[0m\n"
"Returns the image of the render target. The resulting image has the same\n"
"lifetime as the base RenderTarget. If you need to use it past the lifetime\n"
"of the RenderTarget, use the copy method.\n"
"Do not call `setfilter` on the resulting image.\n"
"\n"
"---------\n"
"\n"
"[1mfn load[0m\n"
"\n"
"[3mfn load*(path: str): (Image, std::Err) {\n"
"[0m\n"
"Loads an image at path.\n"
"\n"
"---------\n"
"\n"
"[1mfn Image.validate[0m\n"
"\n"
"[3mfn (i: ^Image) validate*(): bool {\n"
"[0m\n"
"Returns true, if i\'s handle points to an image.\n"
"\n"
"---------\n"
"\n"
"[1mfn Image.flipv[0m\n"
"\n"
"[3mfn (i: ^Image) flipv*(flip: bool) {\n"
"[0m\n"
"Flips image on it\'s vertical axis.\n"
"\n"
"---------\n"
"\n"
"[1mfn Image.fliph[0m\n"
"\n"
"[3mfn (i: ^Image) fliph*(flip: bool) {\n"
"[0m\n"
"Flips image on it\'s horizontal axis.\n"
"\n"
"---------\n"
"\n"
"[1mfn Image.draw[0m\n"
"\n"
"[3mfn (i: ^Image) draw*(t: th::Transform, color: uint32 = th::white) {\n"
"[0m\n"
"Draws the image in screen coordinates. It transforms it with t and\n"
"applies color as a color filter.\n"
"\n"
"---------\n"
"\n"
"[1mfn Image.blit[0m\n"
"\n"
"[3mfn (i: ^Image) blit*(src, dest: rect::Rect, color: uint32 = 0xFFFFFFFF, rot: th::fu = 0, origin: th::Vf2 = {0, 0}) {\n"
"[0m\n"
"Copies source rectangle (texture coordinates) to destination rectangle (screen coordinates).\n"
"\n"
"---------\n"
"\n"
"[1mfn Image.drawNinepatch[0m\n"
"\n"
"[3mfn (i: ^Image) drawNinepatch*(outer, inner, dest: rect::Rect, color: uint32 = th::white, scale: real = 1.0) {\n"
"[0m\n"
"Draws \"nine-patch\" image.\n"
"`outer` specifies the texture coordinates of the outer rect of source image,\n"
"`inner` specifies coordinates of inner rect of source image, positioned relative to `outer`.\n"
"You can tint with `color`.\n"
"\n"
"![](img/ninepatch.png)\n"
"\n"
"---------\n"
"\n"
"[1mfn Image.drawOnQuad[0m\n"
"\n"
"[3mfn (i: ^Image) drawOnQuad*(q: th::Quad, color: uint32 = th::white) {\n"
"[0m\n"
"Draws the image on top of a quad with corners of the image positioned\n"
"on the verticies of the quad.\n"
"\n"
"---------\n"
"\n"
"[1mfn Image.getDims[0m\n"
"\n"
"[3mfn (i: ^Image) getDims*(): th::Vf2 {\n"
"[0m\n"
"Returns width and heigth.\n"
"\n"
"---------\n"
"\n"
"[1mfn Image.crop[0m\n"
"\n"
"[3mfn (i: ^Image) crop*(tl, br: th::Vf2) {\n"
"[0m\n"
"Crops an image. Coordinates are between 0, 0 (top left) and\n"
"1, 1 (bottom right)\n"
"\n"
"---------\n"
"\n"
"[1mfn Image.cropPx[0m\n"
"\n"
"[3mfn (i: ^Image) cropPx*(tr, br: th::Vf2) {\n"
"[0m\n"
"Same as `Image.crop`, but the positions are in pixels.\n"
"\n"
"---------\n"
"\n"
"[1mfn Image.cropRect[0m\n"
"\n"
"[3mfn (i: ^Image) cropRect*(r: rect::Rect) {\n"
"[0m\n"
"Same as `Image.crop`, but uses a rect instead of two positions.\n"
"\n"
"---------\n"
"\n"
"[1mfn Image.cropQuad[0m\n"
"\n"
"[3mfn (i: ^Image) cropQuad*(q: th::Quad) {\n"
"[0m\n"
"Crop an image using a quad.\n"
"\n"
"---------\n"
"\n"
"[1mfn Image.getCropQuad[0m\n"
"\n"
"[3mfn (i: ^Image) getCropQuad*(): th::Quad {\n"
"[0m\n"
"Crop an image using a quad.\n"
"\n"
"---------\n"
"\n"
"[1mfn mk[0m\n"
"\n"
"[3mfn mk*(data: []uint32, dm: th::Vf2): (Image, std::Err) {\n"
"[0m\n"
"Creates an image from raw data.\n"
"\n"
"---------\n"
"\n"
"[1mfn Image.copy[0m\n"
"\n"
"[3mfn (i: ^Image) copy*(): (Image, std::Err) {\n"
"[0m\n"
"Copies image into a new one.\n"
"\n"
"---------\n"
"\n"
"[1mfn Image.setfilter[0m\n"
"\n"
"[3mfn (i: ^Image) setfilter*(filter: int): std::Err {\n"
"[0m\n"
"Sets a mag/min filter. 0 is nearest, others are linear.\n"
"This function will regenerate the texture. This means it shouldn\'t be\n"
"used in a loop.\n"
"https://learnopengl.com/img/getting-started/texture_filtering.png\n"
"left is nearest, right is linear.\n"
"\n"
"---------\n"
"\n"
"[1mfn Image.setData[0m\n"
"\n"
"[3mfn (i: ^Image) setData*(data: []uint32, dm: th::Vf2): std::Err {\n"
"[0m\n"
"Updates the image data. dm are the dimensions of the new image.\n"
"The new image doesn\'t have to be the same size as the old one.\n"
"\n"
"---------\n"
"\n"
"[1mfn Image.getData[0m\n"
"\n"
"[3mfn (i: ^Image) getData*(): []uint32 {\n"
"[0m\n"
"Gets the image data. This downloads the data from the GPU on **each call**.\n"
"Don\'t use in performance critical sections.\n"
"\n"
"---------\n"
"\n"
"",
"[1m[0m\n"
"\n"
"[3m[0m\n"
"Module for getting keyboard and mouse input.\n"
"is* functions return info based on a us QWERTY layout. They are supposed to\n"
"be used for game controls. For text input use getStr.\n"
"\n"
"---------\n"
"\n"
"[1mKeycode constants[0m\n"
"\n"
"[3mtype Key* = enum {\n"
"\tmouse1         = 1   // NOTE: mouse 2 and 3 key codes are swapped\n"
"\tmouse2         = 3   //       because sokol uses 3 for middle mouse\n"
"\tmouse3         = 2   //       button.\n"
"\n"
"\tctrl           = 16\n"
"\tshift          = 17\n"
"\talt            = 18\n"
"\n"
"\tspace          = 32\n"
"\tapostrophe     = 39  /* \' */\n"
"\tcomma          = 44  /* , */\n"
"\tminus          = 45  /* - */\n"
"\tdot            = 46  /* . */\n"
"\tslash          = 47  /* / */\n"
"\tnum0           = 48\n"
"\tnum1           = 49\n"
"\tnum2           = 50\n"
"\tnum3           = 51\n"
"\tnum4           = 52\n"
"\tnum5           = 53\n"
"\tnum6           = 54\n"
"\tnum7           = 55\n"
"\tnum8           = 56\n"
"\tnum9           = 57\n"
"\tsemicolon      = 59  /* ; */\n"
"\tequal          = 61  /* = */\n"
"\ta              = 65\n"
"\tb              = 66\n"
"\tc              = 67\n"
"\td              = 68\n"
"\te              = 69\n"
"\tf              = 70\n"
"\tg              = 71\n"
"\th              = 72\n"
"\ti              = 73\n"
"\tj              = 74\n"
"\tk              = 75\n"
"\tl              = 76\n"
"\tm              = 77\n"
"\tn              = 78\n"
"\to              = 79\n"
"\tp              = 80\n"
"\tq              = 81\n"
"\tr              = 82\n"
"\ts              = 83\n"
"\tt              = 84\n"
"\tu              = 85\n"
"\tv              = 86\n"
"\tw              = 87\n"
"\tx              = 88\n"
"\ty              = 89\n"
"\tz              = 90\n"
"\tleftBracket    = 91  /* [ */\n"
"\tbackslash      = 92  /* \\ */\n"
"\trightBracket   = 93  /* ] */\n"
"\tgraveAccent    = 96  /* ` */\n"
"\tworld1         = 161 /* non-US #1 */\n"
"\tworld2         = 162 /* non-US #2 */\n"
"\tescape         = 256\n"
"\tenter          = 257\n"
"\ttab            = 258\n"
"\tbackspace      = 259\n"
"\tinsert         = 260\n"
"\tdelete         = 261\n"
"\tright          = 262\n"
"\tleft           = 263\n"
"\tdown           = 264\n"
"\tup             = 265\n"
"\tpageUp         = 266\n"
"\tpageDown       = 267\n"
"\thome           = 268\n"
"\tend            = 269\n"
"\tcapsLock       = 280\n"
"\tscrollLock     = 281\n"
"\tnumLock        = 282\n"
"\tprintScreen    = 283\n"
"\tpause          = 284\n"
"\tfn0            = 289\n"
"\tfn1            = 290\n"
"\tfn2            = 291\n"
"\tfn3            = 292\n"
"\tfn4            = 293\n"
"\tfn5            = 294\n"
"\tfn6            = 295\n"
"\tfn7            = 296\n"
"\tfn8            = 297\n"
"\tfn9            = 298\n"
"\tfn10           = 299\n"
"\tfn11           = 300\n"
"\tfn12           = 301\n"
"\tfn13           = 302\n"
"\tfn14           = 303\n"
"\tfn15           = 304\n"
"\tfn16           = 305\n"
"\tfn17           = 306\n"
"\tfn18           = 307\n"
"\tfn19           = 308\n"
"\tfn20           = 309\n"
"\tfn21           = 310\n"
"\tfn22           = 311\n"
"\tfn23           = 312\n"
"\tfn24           = 313\n"
"\tfn25           = 314\n"
"\tkp0            = 320\n"
"\tkp1            = 321\n"
"\tkp2            = 322\n"
"\tkp3            = 323\n"
"\tkp4            = 324\n"
"\tkp5            = 325\n"
"\tkp6            = 326\n"
"\tkp7            = 327\n"
"\tkp8            = 328\n"
"\tkp9            = 329\n"
"\tkpDecimal      = 330\n"
"\tkpDivide       = 331\n"
"\tkpMultiply     = 332\n"
"\tkpSubtract     = 333\n"
"\tkpAdd          = 334\n"
"\tkpEnter        = 335\n"
"\tkpEqual        = 336\n"
"\tleftShift      = 340\n"
"\tleftControl    = 341\n"
"\tleftAlt        = 342\n"
"\tleftSuper      = 343\n"
"\trightShift     = 344\n"
"\trightControl   = 345\n"
"\trightAlt       = 346\n"
"\trightSuper     = 347\n"
"\tmenu           = 348\n"
"}\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1mGamepad button number[0m\n"
"\n"
"[3mtype GamepadButton* = enum {\n"
"\ta\n"
"\tb\n"
"\tx\n"
"\ty\n"
"\tlt\n"
"\trt\n"
"\tlb\n"
"\trb\n"
"\tselect\n"
"\tstart\n"
"\tup\n"
"\tdown\n"
"\tleft\n"
"\tright\n"
"\tlstick\n"
"\trstick\n"
"\t_count\n"
"}\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1mGamepad stick number[0m\n"
"\n"
"[3mtype GamepadStick* = enum {\n"
"\tleft\n"
"\tright\n"
"}\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1mfn getMousePos[0m\n"
"\n"
"[3mfn getMousePos*(): th::Vf2 {\n"
"[0m\n"
"Returns the position of mouse cursor in relation to the screen.\n"
"\n"
"---------\n"
"\n"
"[1mfn getGlobalMousePos[0m\n"
"\n"
"[3mfn getGlobalMousePos*(): th::Vf2 {\n"
"[0m\n"
"Returns the position of mouse cursor in relation to cam.\n"
"\n"
"---------\n"
"\n"
"[1mfn isPressed[0m\n"
"\n"
"[3mfn isPressed*(code: Key): bool {\n"
"[0m\n"
"Returns true if key is pressed. Either use codes defined in the file above,\n"
"or pass lower case char/number.\n"
"\n"
"---------\n"
"\n"
"[1mfn isPressedc[0m\n"
"\n"
"[3mfn isPressedc*(code: char): bool {\n"
"[0m\n"
"Like `isPressed`, but you can pass char as the code.\n"
"\n"
"---------\n"
"\n"
"[1mfn isJustPressed[0m\n"
"\n"
"[3mfn isJustPressed*(code: Key): bool {\n"
"[0m\n"
"Returns, whether code was just pressed this loop.\n"
"\n"
"---------\n"
"\n"
"[1mfn isJustPressedc[0m\n"
"\n"
"[3mfn isJustPressedc*(code: char): bool {\n"
"[0m\n"
"Like `isJustPressed`, but you can pass char as the code.\n"
"\n"
"---------\n"
"\n"
"[1mfn isPressedRepeat[0m\n"
"\n"
"[3mfn isPressedRepeat*(code: Key): bool {\n"
"[0m\n"
"Returns, whether code was just pressed this loop, with key repeat.\n"
"\n"
"---------\n"
"\n"
"[1mfn isPressedRepeatc[0m\n"
"\n"
"[3mfn isPressedRepeatc*(code: char): bool {\n"
"[0m\n"
"Like `isPressedRepeat`, but you can pass char as the code.\n"
"\n"
"---------\n"
"\n"
"[1mfn isJustReleased[0m\n"
"\n"
"[3mfn isJustReleased*(code: Key): bool {\n"
"[0m\n"
"Returns true if a key was just released.\n"
"\n"
"---------\n"
"\n"
"[1mfn isJustReleasedc[0m\n"
"\n"
"[3mfn isJustReleasedc*(code: char): bool {\n"
"[0m\n"
"Like `isJustReleased`, but you can pass char as the code.\n"
"\n"
"---------\n"
"\n"
"[1mfn clear[0m\n"
"\n"
"[3mfn clear*(code: Key) {\n"
"[0m\n"
"Clears both the pressed and justPressed state of a code.\n"
"\n"
"---------\n"
"\n"
"[1mfn clearc[0m\n"
"\n"
"[3mfn clearc*(code: char) {\n"
"[0m\n"
"Like `clear`, but you can pass char as the code.\n"
"\n"
"---------\n"
"\n"
"[1mfn getStr[0m\n"
"\n"
"[3mfn getStr*(): str {\n"
"[0m\n"
"Returns a string entered by the user in the last cycle.\n"
"\n"
"---------\n"
"\n"
"[1mfn getMouseDelta[0m\n"
"\n"
"[3mfn getMouseDelta*(): th::Vf2 {\n"
"[0m\n"
"Returns the difference between mouse positions in the last cycle. Will work\n"
"even if `window.freezeCursor` is enabled.\n"
"\n"
"---------\n"
"\n"
"[1mfn getMouseScroll[0m\n"
"\n"
"[3mfn getMouseScroll*(): th::Vf2 {\n"
"[0m\n"
"Returns the scroll wheel value\n"
"\n"
"---------\n"
"\n"
"[1mfn gamepads[0m\n"
"\n"
"[3mfn gamepads*(): []Gamepad {\n"
"[0m\n"
"Returns a list of gamepads that are currently connected.\n"
"\n"
"---------\n"
"\n"
"[1mfn gamepad[0m\n"
"\n"
"[3mfn gamepad*(): Gamepad {\n"
"[0m\n"
"Returns the connected gamepad.\n"
"\n"
"---------\n"
"\n"
"[1mfn isPressed[0m\n"
"\n"
"[3mfn (g: ^Gamepad) isPressed*(button: GamepadButton): bool {\n"
"[0m\n"
"Returns true if the gamepad button is pressed.\n"
"\n"
"---------\n"
"\n"
"[1mfn isJustPressed[0m\n"
"\n"
"[3mfn (g: ^Gamepad) isJustPressed*(button: GamepadButton): bool {\n"
"[0m\n"
"Returns true if the gamepad button was just pressed.\n"
"\n"
"---------\n"
"\n"
"[1mfn isJustReleased[0m\n"
"\n"
"[3mfn (g: ^Gamepad) isJustReleased*(button: GamepadButton): bool {\n"
"[0m\n"
"Returns true if the gamepad button was just released.\n"
"\n"
"---------\n"
"\n"
"[1mfn pressure[0m\n"
"\n"
"[3mfn (g: ^Gamepad) pressure*(button: GamepadButton): th::fu {\n"
"[0m\n"
"Returns the pressure of the gamepad button in the range [0, 1].\n"
"\n"
"---------\n"
"\n"
"[1mfn stick[0m\n"
"\n"
"[3mfn (g: ^Gamepad) stick*(stick: GamepadStick): th::Vf2 {\n"
"[0m\n"
"Returns the movement of the gamepad stick in the range [-1, 1] for each axis.\n"
"\n"
"---------\n"
"\n"
"[1mfn rumble[0m\n"
"\n"
"[3mfn (g: ^Gamepad) rumble*(left, right: th::fu) {\n"
"[0m\n"
"Rumbles/vibrates the gamepad.\n"
"\n"
"---------\n"
"\n"
"",
"[1m[0m\n"
"\n"
"[3m[0m\n"
"Misc functions.\n"
"\n"
"---------\n"
"\n"
"[1mfn readall **DEPRECATED**[0m\n"
"\n"
"[3mfn readall*(path: str): str {\n"
"[0m\n"
"Use std.freadall instaed.\n"
"\n"
"---------\n"
"\n"
"[1mfn stepify[0m\n"
"\n"
"[3mfn stepify*(val, step: th::fu): th::fu {\n"
"[0m\n"
"Snaps a value to step.\n"
"\n"
"---------\n"
"\n"
"[1mfn maxf[0m\n"
"\n"
"[3mfn maxf*(a, b: th::fu): th::fu {\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1mfn minf[0m\n"
"\n"
"[3mfn minf*(a, b: th::fu): th::fu {\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"",
"[1m[0m\n"
"\n"
"[3m[0m\n"
"Canvas library allowing for drawing basic shapes. Coordinates are based on\n"
"the screen.\n"
"\n"
"---------\n"
"\n"
"[1mfn drawText[0m\n"
"\n"
"[3mfn drawText*(text: str, pos: th::Vf2, color: uint32, size: th::fu) {\n"
"[0m\n"
"Draws a basic pixel text. Only ascii is supported.\n"
"\n"
"---------\n"
"\n"
"[1mfn textSize[0m\n"
"\n"
"[3mfn textSize*(text: str, scale: th::fu): th::Vf2 {\n"
"[0m\n"
"Returns the size of text taken by an equivalent drawText call.\n"
"\n"
"---------\n"
"\n"
"[1mPixel Font[0m\n"
"\n"
"[3mvar pixelFont*: PixelFont\n"
"[0m\n"
"The `pixelFont` variable exposes the canvas pixel font as a generic font.\n"
"\n"
"---------\n"
"\n"
"[1mfn drawRect[0m\n"
"\n"
"[3mfn drawRect*(color: uint32, r: rect::Rect) {\n"
"[0m\n"
"Draws a Rectangle.\n"
"\n"
"---------\n"
"\n"
"[1mfn drawLine[0m\n"
"\n"
"[3mfn drawLine*(color: uint32, b, e: th::Vf2, thickness: th::fu) {\n"
"[0m\n"
"Draws a line.\n"
"\n"
"---------\n"
"\n"
"[1mfn drawRectLines[0m\n"
"\n"
"[3mfn drawRectLines*(color: uint32, r: rect::Rect, thickness: real32 = 1.0) {\n"
"[0m\n"
"Draws rect border.\n"
"\n"
"---------\n"
"\n"
"[1mfn drawQuad[0m\n"
"\n"
"[3mfn drawQuad*(color: uint32, q: th::Quad) {\n"
"[0m\n"
"Draws a convex quad.\n"
"\n"
"---------\n"
"\n"
"[1mfn beginScissorRect[0m\n"
"\n"
"[3mfn beginScissorRect*(r: rect::Rect, debug: bool = false) {\n"
"[0m\n"
"Disable rendering outside of rect `r`\n"
"\n"
"---------\n"
"\n"
"[1mfn endScissor[0m\n"
"\n"
"[3mfn endScissor*() {\n"
"[0m\n"
"Stops cropping\n"
"\n"
"---------\n"
"\n"
"",
"[1mstruct Rect[0m\n"
"\n"
"[3mtype Rect* = struct {\n"
"\tx, y, w, h: th::fu\n"
"}\n"
"[0m\n"
"A set of points representing a rectangle.\n"
"\n"
"---------\n"
"\n"
"[1mfn mk[0m\n"
"\n"
"[3mfn mk*(x, y, w, h: th::fu): Rect {\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1mfn mk[0m\n"
"\n"
"[3mfn fromVf2*(p: th::Vf2, dm: th::Vf2): Rect {\n"
"[0m\n"
"Creates a rect from two Vf2s - the position and the dimensions.\n"
"\n"
"---------\n"
"\n"
"[1mfn Rect.getPos[0m\n"
"\n"
"[3mfn (r: ^Rect) getPos*(): th::Vf2 {\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1mfn Rect.getDims[0m\n"
"\n"
"[3mfn (r: ^Rect) getDims*(): th::Vf2 {\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1mfn Rect.getEnd[0m\n"
"\n"
"[3mfn (r: ^Rect) getEnd*(): th::Vf2 {\n"
"[0m\n"
"returns where the second point of the rectangle lies.\n"
"\n"
"---------\n"
"\n"
"[1mfn Rect.transformed[0m\n"
"\n"
"[3mfn (r: ^Rect) transformed*(t: th::Transform): th::Quad {\n"
"[0m\n"
"Transforms a rect into a quad.\n"
"Order:\n"
"1. scale\n"
"2. rotation\n"
"3. position\n"
"\n"
"---------\n"
"\n"
"[1mfn Rect.shrink[0m\n"
"\n"
"[3mfn (r: ^Rect) shrink*(p: th::Vf2): Rect {\n"
"[0m\n"
"Shrink the rectangle by `p` pixels from all sides.\n"
"\n"
"---------\n"
"\n"
"[1mfn Rect.shift[0m\n"
"\n"
"[3mfn (r: ^Rect) shift*(p: th::Vf2): Rect {\n"
"[0m\n"
"Shift the rectangle by `p` pixels.\n"
"\n"
"---------\n"
"\n"
"[1mfn Rect.scale[0m\n"
"\n"
"[3mfn (r: ^Rect) scale*(p: th::Vf2): Rect {\n"
"[0m\n"
"Multiply the dimensions by `p`\n"
"\n"
"---------\n"
"\n"
"[1mfn Rect.center[0m\n"
"\n"
"[3mfn (r: ^Rect) center*(): th::Vf2 {\n"
"[0m\n"
"Returns the position, which is the center of the rect.\n"
"\n"
"---------\n"
"\n"
"[1mfn Rect.centerWithinRect[0m\n"
"\n"
"[3mfn (r: ^Rect) centerWithinRect*(child: Rect): Rect {\n"
"[0m\n"
"Centers `child` with the rect `r`.\n"
"\n"
"---------\n"
"\n"
"",
"[1m[0m\n"
"\n"
"[3m[0m\n"
"Tilemaps allow for easy level construction and fast collisions. You can even\n"
"use them for some games instead of entities (tetris comes to mind)\n"
"\n"
"---------\n"
"\n"
"[1mDirection constants used for autotile[0m\n"
"\n"
"[3mconst (\n"
"\ttop* = 1\n"
"\tright* = 2\n"
"\tbot* = 4\n"
"\tleft* = 8\n"
")\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1mstruct Tilemap[0m\n"
"\n"
"[3mtype Tilemap* = struct {\n"
"\tatlas: atlas::Atlas\n"
"\tpos: th::Vf2\n"
"\tw: th::uu // width of tilemap\n"
"\tcells: []th::uu // all cells (this will draw the tile in tiles with number in cells - 1)\n"
"\tcollMask: []bool // if true, the tile collides\n"
"\tscale: th::fu\n"
"}\n"
"[0m\n"
"Tilemap struct\n"
"\n"
"---------\n"
"\n"
"[1mfn mk[0m\n"
"\n"
"[3mfn mk*(w, h: th::uu, at: atlas::Atlas, scale: th::fu = 1): Tilemap {\n"
"[0m\n"
"Make a tilemap with all cells set to 0.\n"
"\n"
"---------\n"
"\n"
"[1mfn mk2[0m\n"
"\n"
"[3mfn mk2*(cells: []th::uu, w: th::uu, at: atlas::Atlas, scale: th::fu = 1): Tilemap {\n"
"[0m\n"
"Make a tilemap from a list of cells.\n"
"\n"
"---------\n"
"\n"
"[1mfn Tilemap.has[0m\n"
"\n"
"[3mfn (t: ^Tilemap) has*(x, y: int): bool {\n"
"[0m\n"
"Check if a tile exists at the given coordinates.\n"
"\n"
"---------\n"
"\n"
"[1mfn Tilemap.edit[0m\n"
"\n"
"[3mfn (t: ^Tilemap) edit*(x, y, tile: int){\n"
"[0m\n"
"Edit a tile in the tilemap.\n"
"\n"
"---------\n"
"\n"
"[1mfn Tilemap.get[0m\n"
"\n"
"[3mfn (t: ^Tilemap) get*(x, y: int): int {\n"
"[0m\n"
"Get a tile from the tilemap.\n"
"\n"
"---------\n"
"\n"
"[1mfn Tilemap.draw[0m\n"
"\n"
"[3mfn (t: ^Tilemap) draw*(tr: th::Transform) {\n"
"[0m\n"
"Draws the tilemap.\n"
"\n"
"---------\n"
"\n"
"[1mfn Tilemap.getColl[0m\n"
"\n"
"[3mfn (t: ^Tilemap) getColl*(e: ent::Ent, ic: ^th::Vf2, pos: ^th::Vf2): bool {\n"
"[0m\n"
"Checks whether `e` collides with any of the tiles in `t`, which are in the\n"
"collmask.\n"
"\n"
"* `ic`[out] - the position where a collision occured\n"
"* `pos`[out] - coordinates of a tile where a collision occured\n"
"\n"
"Note: While there may be multiple collisions with a tilemap, this function\n"
"will only return one.\n"
"\n"
"---------\n"
"\n"
"[1mfn Tilemap.getCollLine[0m\n"
"\n"
"[3mfn (t: ^Tilemap) getCollLine*(b, e: th::Vf2, ic: ^th::Vf2): bool {\n"
"[0m\n"
"Check for a collision between a tilemap and a line. `ic` will be a point of\n"
"an intersection, if there is one.\n"
"\n"
"---------\n"
"\n"
"[1mfn Tilemap.autotile[0m\n"
"\n"
"[3mfn (t: ^Tilemap) autotile*(src, tileCfg: []th::uu, tile: th::uu) {\n"
"[0m\n"
"Autotile turns all `tile` tiles in `src` into tiles in `tileCfg`, so they\n"
"follow up correctly. `tileCfg` is an array of 16 tiles. They are placed in\n"
"a way where OR of all the places where the tile continues (top, right bot,\n"
"right). The constants for them are defined in this file. Example:\n"
"tileCfg[top | bot] = 21\n"
"top | bot would look something like this: |\n"
"\n"
"---------\n"
"\n"
"",
"[1mCursor types[0m\n"
"\n"
"[3mtype Cursor* = enum {\n"
"\tsystem = 0\t\t// Default system cursor\n"
"\tarrow\t\t\t// Normal cursor; Arrow cursor\n"
"\tiBeam\t\t\t// \'I\' text cursor; I-Beam\n"
"\tcrosshair\t\t// \'+\' cursor; Select region cursor\n"
"\tfinger\t\t\t// Index finger pointing cursor; Click cursor\n"
"\tsizeEW\t\t\t// \'<->\' cursor; Resize width cursor; Resize horizontally cursor; East-West resize cursor\n"
"\tsizeNS\t\t\t// Resize height cursor; Resize vertically cursor; North-South resize cursor\n"
"\tsizeNWSE\t\t\t// Resize width and height from the right side cursor; Northwest-Southeast resize cursor\n"
"\tsizeSWNE\t\t\t// Resize width and height from the left side cursor; Southwest-Northeast resize cursor\n"
"\tsizeAll\t\t\t// Resize all cursor; Move cursor\n"
"\tno\t\t\t// \'(/)\' cursor; Disabled cursor; Disallowed cursor\n"
"\tcount_\n"
"}\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1mWindow dimensions[0m\n"
"\n"
"[3mvar (\n"
"\tw*, h*: int32\n"
")\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1mViewport size[0m\n"
"\n"
"[3mvar wp*: th::Vf2\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1msignal OnFrame[0m\n"
"\n"
"[3mvar onFrame*: signal::Signal\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1msignal OnDestroy[0m\n"
"\n"
"[3mvar onDestroy*: signal::Signal\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1mfn setViewport[0m\n"
"\n"
"[3mfn setViewport*(dm: th::Vf2) {\n"
"[0m\n"
"Sets the dimensions of the viewport. The dimensions are saved in the `wp`\n"
"variable.\n"
"\n"
"`dm`\n"
": dimension of the viewport\n"
"\n"
"---------\n"
"\n"
"[1mfn isDpiEnabled[0m\n"
"\n"
"[3mfn isDpiEnabled*(): bool {\n"
"[0m\n"
"Returns true if DPI awareness was enabled\n"
"\n"
"---------\n"
"\n"
"[1mfn getDpiScaleFactor[0m\n"
"\n"
"[3mfn getDpiScaleFactor*(): th::fu {\n"
"[0m\n"
"Returns the DPI scaling of the current window.\n"
"If `dpiAware` was not enabled in window setup, this function will return 1.0 (default scaling).\n"
"\n"
"---------\n"
"\n"
"[1mfn setup[0m\n"
"\n"
"[3mfn setup*(title: str = \"tophat game\", width: int = 400, height: int32 = 400) {\n"
"[0m\n"
"Sets up the engine and opens a window.\n"
"\n"
"---------\n"
"\n"
"[1mfn setFullscreen[0m\n"
"\n"
"[3mfn setFullscreen*(fullscreen: bool) {\n"
"[0m\n"
"Makes window go full screen\n"
"\n"
"---------\n"
"\n"
"[1mfn isFullscreen[0m\n"
"\n"
"[3mfn isFullscreen*(): bool {\n"
"[0m\n"
"Returns true if window is fullscreen\n"
"\n"
"---------\n"
"\n"
"[1mfn getDims[0m\n"
"\n"
"[3mfn getDims*(): th::Vf2 {\n"
"[0m\n"
"Returns dimensions of the window in screen pixels.\n"
"\n"
"---------\n"
"\n"
"[1mfn setTargetFps[0m\n"
"\n"
"[3mfn setTargetFps*(fps: int) {\n"
"[0m\n"
"Sets the fps limit.\n"
"\n"
"`fps`\n"
": amount of fps the limit should be set to\n"
"\n"
"\n"
"---------\n"
"\n"
"[1mfn setTitle[0m\n"
"\n"
"[3mfn setTitle*(title: str) {\n"
"[0m\n"
"Sets the title of the window.\n"
"\n"
"---------\n"
"\n"
"[1mfn setDims[0m\n"
"\n"
"[3mfn setDims*(dm: th::Vf2) {\n"
"[0m\n"
"Sets the dimensions of the window.\n"
"\n"
"`dm`\n"
": the target dimensions in screen pixels\n"
"\n"
"---------\n"
"\n"
"[1mfn setIcon[0m\n"
"\n"
"[3mfn setIcon*(img: image::Image) {\n"
"[0m\n"
"Sets the window icon.\n"
"\n"
"---------\n"
"\n"
"[1mfn showCursor[0m\n"
"\n"
"[3mfn showCursor*(show: bool) {\n"
"[0m\n"
"Show or hide the cursor, linux only.\n"
"\n"
"---------\n"
"\n"
"[1mfn freezeCursor[0m\n"
"\n"
"[3mfn freezeCursor*(freeze: bool) {\n"
"[0m\n"
"Freezes the cursor in place. `input.getMouseDelta` will still report mouse\n"
"movements.  The cursor will be automatically hidden.\n"
"\n"
"---------\n"
"\n"
"[1mfn setCursor[0m\n"
"\n"
"[3mfn setCursor*(cursor: Cursor) {\n"
"[0m\n"
"Allows you to set the displaying cursor. Refer to the cursors section for available cursors.\n"
"\n"
"---------\n"
"\n"
"[1mfn requestExit[0m\n"
"\n"
"[3mfn requestExit*() {\n"
"[0m\n"
"Requests the window to close.\n"
"\n"
"---------\n"
"\n"
"[1mfn setClipboard[0m\n"
"\n"
"[3mfn setClipboard*(s: str) {\n"
"[0m\n"
"Puts a string to the system clipboard.\n"
"\n"
"---------\n"
"\n"
"[1mfn getClipboard[0m\n"
"\n"
"[3mfn getClipboard*(): str {\n"
"[0m\n"
"Gets a string from the system clipboard.\n"
"\n"
"---------\n"
"\n"
"[1mfn setViewportOffset[0m\n"
"\n"
"[3mfn setViewportOffset*(s: th::Vf2) {\n"
"[0m\n"
"Sets the offset of the viewport.\n"
"\n"
"---------\n"
"\n"
"[1mfn getViewportOffset[0m\n"
"\n"
"[3mfn getViewportOffset*(): th::Vf2 {\n"
"[0m\n"
"Gets the offset of the viewport (as set by `setViewportShift`)\n"
"\n"
"---------\n"
"\n"
"",
"[1m[0m\n"
"\n"
"[3m[0m\n"
"Particles allow for *performant* and random particle systems.\n"
"\n"
"---------\n"
"\n"
"[1mstruct Particle[0m\n"
"\n"
"[3mtype Particle* = struct {\n"
"[0m\n"
"Particle struct. You can tweak the start_time for godot-like explossivness.\n"
"\n"
"---------\n"
"\n"
"[1mstruct Emitter[0m\n"
"\n"
"[3mtype Emitter* = struct {\n"
"\tpos: th::Vf2 // position\n"
"\tdm: th::Vf2 // size of the emittion area\n"
"\tgravity: th::Vf2 // gravity\n"
"\trepeat: bool // if false, particle won\'t be renewed\n"
"\tactive: bool // false, if there aren\'t any active particles anymore\n"
"\n"
"\tangle: th::Vf2 // angle in which particles are emitted\n"
"\n"
"\tlifetime: th::uu // lifetime of particles\n"
"\tlifetimeRandomness: th::fu // randomness in %/100\n"
"\n"
"\tvelocity: th::fu // velocity\n"
"\tvelocityRandomness: th::fu // randomness in %/100\n"
"\n"
"\tsize: th::fu // size\n"
"\tsizeRandomness: th::fu // randomness in %/100\n"
"\tmaxSize: th::fu // size at the end of particles lifetime\n"
"\n"
"\trotation: th::fu\n"
"\trotationRandomness: th::fu\n"
"\tmaxRotation: th::fu\n"
"\n"
"\tcolors: []uint32 // array of colors, which are interpolated between\n"
"\n"
"\tparticles: []Particle // list of particles\n"
"}\n"
"[0m\n"
"Emitter. This is where everything is configured.\n"
"\n"
"---------\n"
"\n"
"[1mfn Emitter.draw[0m\n"
"\n"
"[3mfn (e: ^Emitter) draw*(t: int32) {\n"
"[0m\n"
"Draws and updates the particles.\n"
"\n"
"---------\n"
"\n"
"[1mfn Emitter.genParticles[0m\n"
"\n"
"[3mfn (e: ^Emitter) genParticles*(time, count: uint, explosiveness: th::fu = 0.0) {\n"
"[0m\n"
"Generates particles for an emitter. The time specifies the time the first\n"
"particles is emitted. The explosiveness argument specifies the interval at\n"
"which particles are emitted using this formula:\n"
"/ ```umka\n"
"/ e.lifetime / count * explosiveness\n"
"/ ```\n"
"\n"
"---------\n"
"\n"
"",
"[1m[0m\n"
"\n"
"[3m[0m\n"
"Simple linear interpolation module.\n"
"\n"
"---------\n"
"\n"
"",
"[1m[0m\n"
"\n"
"[3m[0m\n"
"Module for font rendering. Unicode is supported, but only left to right.\n"
"\n"
"---------\n"
"\n"
"[1mFiltering constants[0m\n"
"\n"
"[3mtype Filter* = enum {\n"
"\tnearest = 0\n"
"\tlinear = 1\n"
"}\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1minterface Font[0m\n"
"\n"
"[3mtype Font* = interface {\n"
"\t// Draw text to the viewport\n"
"\tdraw(text: str, pos: th::Vf2, color: uint32, scale: th::fu = 1.0)\n"
"\t// Return the dimensions of the text at scale 1\n"
"\tmeasure(text: str): th::Vf2\n"
"\t// Return true if the font is valid\n"
"\tvalidate(): bool\n"
"}\n"
"[0m\n"
"A generic interface for fonts. Fonts can be loaded from file using\n"
"`font::load`, or a built in canvas can be used from `canvas::pixelFont`.\n"
"\n"
"---------\n"
"\n"
"[1mfn load[0m\n"
"\n"
"[3mfn load*(path: str, size: th::fu, filter: Filter = Filter.linear): (Font, std::Err) {\n"
"[0m\n"
"Loads a font from a path and returns it.\n"
"\n"
"---------\n"
"\n"
"",
"[1m[0m\n"
"\n"
"[3m[0m\n"
"Module with useful variables and types.\n"
"Variables: time, delta, platform\n"
"Constants: black, white, red, green, blue, yellow, magenta, cyan.\n"
"\n"
"---------\n"
"\n"
"[1mTophat type aliases[0m\n"
"\n"
"[3mtype fu* = real32\n"
"// standard type for integer values\n"
"type iu* = int32\n"
"// standard type for unsigned values\n"
"type uu* = uint32\n"
"[0m\n"
"standard type for real values\n"
"\n"
"---------\n"
"\n"
"[1menum ErrCode[0m\n"
"\n"
"[3mtype ErrCode* = enum (int32) {\n"
"\tok = 0\n"
"\tfailure = 1\n"
"\tio\n"
"\tbad_enum\n"
"\tbad_action\n"
"\tbad_input\n"
"\talloc\n"
"\talready\n"
"\tout_of_bounds\n"
"}\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1mstruct Vf2[0m\n"
"\n"
"[3mtype Vf2* = struct {\n"
"\tx, y: fu\n"
"}\n"
"[0m\n"
"vector 2\n"
"\n"
"---------\n"
"\n"
"[1mfn mkVf2[0m\n"
"\n"
"[3mfn mkVf2*(x: fu = 0, y: fu = 0): Vf2 {\n"
"\treturn Vf2{x, y}\n"
"}\n"
"[0m\n"
"Vf2 constructor\n"
"\n"
"---------\n"
"\n"
"[1mfn Vf2.rotated[0m\n"
"\n"
"[3mfn (p: ^Vf2) rotated*(origin: Vf2, rot: fu): Vf2 {\n"
"[0m\n"
"rotates `p` around `origin` with `rot` in degrees\n"
"\n"
"---------\n"
"\n"
"[1mfn Vf2.distanceTo[0m\n"
"\n"
"[3mfn (p1: ^Vf2) distanceTo*(p2: Vf2): fu {\n"
"[0m\n"
"distance between p1 and p2\n"
"\n"
"---------\n"
"\n"
"[1mfn Vf2.angleTo[0m\n"
"\n"
"[3mfn (p1: ^Vf2) angleTo*(p2: Vf2): real {\n"
"[0m\n"
"Angle between p1 and p2\n"
"\n"
"---------\n"
"\n"
"[1mfn Vf2.abs[0m\n"
"\n"
"[3mfn (p: ^Vf2) abs*(): Vf2 {\n"
"[0m\n"
"Absolute value of a vector.\n"
"\n"
"---------\n"
"\n"
"[1mfn Vf2.round[0m\n"
"\n"
"[3mfn (p: ^Vf2) round*(): Vf2 {\n"
"[0m\n"
"Rounds a vector.\n"
"\n"
"---------\n"
"\n"
"[1mfn Vf2.trunc[0m\n"
"\n"
"[3mfn (p: ^Vf2) trunc*(): Vf2 {\n"
"[0m\n"
"Truncates a vector.\n"
"\n"
"---------\n"
"\n"
"[1mfn Vf2.floor[0m\n"
"\n"
"[3mfn (p: ^Vf2) floor*(): Vf2 {\n"
"[0m\n"
"Floors a vector.\n"
"\n"
"---------\n"
"\n"
"[1mfn Vf2.ceil[0m\n"
"\n"
"[3mfn (p: ^Vf2) ceil*(): Vf2 {\n"
"[0m\n"
"Ceils a vector.\n"
"\n"
"---------\n"
"\n"
"[1mfn vf2f[0m\n"
"\n"
"[3mfn vf2f*(f: fu): Vf2 {\n"
"[0m\n"
"Creates a vector with both x and y set to f\n"
"\n"
"---------\n"
"\n"
"[1mfn Vf2.sub[0m\n"
"\n"
"[3mfn (p: ^Vf2) sub*(p2: Vf2): Vf2 {\n"
"[0m\n"
"Subtracts a vector from another one.\n"
"\n"
"---------\n"
"\n"
"[1mfn Vf2.subf[0m\n"
"\n"
"[3mfn (p: ^Vf2) subf*(f: fu): Vf2 {\n"
"[0m\n"
"Subtracts a fu from a vector.\n"
"\n"
"---------\n"
"\n"
"[1mfn Vf2.add[0m\n"
"\n"
"[3mfn (p: ^Vf2) add*(p2: Vf2): Vf2 {\n"
"[0m\n"
"Adds a vector to another one.\n"
"\n"
"---------\n"
"\n"
"[1mfn Vf2.addf[0m\n"
"\n"
"[3mfn (p: ^Vf2) addf*(f: fu): Vf2 {\n"
"[0m\n"
"Adds a fu to a vector.\n"
"\n"
"---------\n"
"\n"
"[1mfn Vf2.div[0m\n"
"\n"
"[3mfn (p: ^Vf2) div*(p2: Vf2): Vf2 {\n"
"[0m\n"
"Divides a vector by another one.\n"
"\n"
"---------\n"
"\n"
"[1mfn Vf2.divf[0m\n"
"\n"
"[3mfn (p: ^Vf2) divf*(f: fu): Vf2 {\n"
"[0m\n"
"Divides a vector by a fu.\n"
"\n"
"---------\n"
"\n"
"[1mfn Vf2.mul[0m\n"
"\n"
"[3mfn (p: ^Vf2) mul*(p2: Vf2): Vf2 {\n"
"[0m\n"
"Multiplies a vector by another one.\n"
"\n"
"---------\n"
"\n"
"[1mfn Vf2.mulf[0m\n"
"\n"
"[3mfn (p: ^Vf2) mulf*(f: fu): Vf2 {\n"
"[0m\n"
"Multiplies a vector by a fu.\n"
"\n"
"---------\n"
"\n"
"[1mfn Vf2.mag[0m\n"
"\n"
"[3mfn (p: ^Vf2) mag*(): fu {\n"
"[0m\n"
"Returns the magnitude of a vector p.\n"
"\n"
"---------\n"
"\n"
"[1mfn Vf2.norm[0m\n"
"\n"
"[3mfn (p: ^Vf2) norm*(): Vf2 {\n"
"[0m\n"
"Normalizes a vector.\n"
"\n"
"---------\n"
"\n"
"[1mfn Vf2.dot[0m\n"
"\n"
"[3mfn (p: ^Vf2) dot*(q: Vf2): fu {\n"
"[0m\n"
"Calculates dot product between 2 vectors.\n"
"\n"
"---------\n"
"\n"
"[1mstruct Transform[0m\n"
"\n"
"[3mtype Transform* = struct {\n"
"\tp: Vf2 // position\n"
"\ts: Vf2 // scale\n"
"\to: Vf2 // origin\n"
"\tr: fu  // rotation\n"
"}\n"
"[0m\n"
"Struct defining transformation. Used for example by entities.\n"
"\n"
"---------\n"
"\n"
"[1mfn mkTransform[0m\n"
"\n"
"[3mfn mkTransform*(p: Vf2, s: Vf2 = Vf2{1, 1}, o: Vf2 = Vf2{0, 0}, r: fu = 0.0): Transform {\n"
"[0m\n"
"Transform constructor\n"
"\n"
"---------\n"
"\n"
"[1mfn Transform.transformed[0m\n"
"\n"
"[3mfn (o: ^Transform) transformed*(t: Transform): Transform {\n"
"[0m\n"
"Transforms a transform with another transform.\n"
"\n"
"---------\n"
"\n"
"[1mfn Vf2.transformed[0m\n"
"\n"
"[3mfn (v: ^Vf2) transformed*(t: Transform): Vf2 {\n"
"[0m\n"
"Transforms a vf2 to another vf2.\n"
"Order:\n"
"1. scale\n"
"2. rotation\n"
"3. position\n"
"\n"
"This allows conversion from a relative to an absolute vf2.\n"
"\n"
"---------\n"
"\n"
"[1mtype Quad[0m\n"
"\n"
"[3mtype Quad* = [4]Vf2\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1mfn Quad.transformed[0m\n"
"\n"
"[3mfn (q: ^Quad) transformed*(t: Transform): Quad {\n"
"[0m\n"
"Transforms a quad with a transform.\n"
"\n"
"---------\n"
"\n"
"[1mfn Quad.getMax[0m\n"
"\n"
"[3mfn (q: ^Quad) getMax*(): Vf2 {\n"
"[0m\n"
"Gets the maximum coordinate.\n"
"\n"
"---------\n"
"\n"
"[1mfn Quad.getMin[0m\n"
"\n"
"[3mfn (q: ^Quad) getMin*(): Vf2 {\n"
"[0m\n"
"Gets the minimum coordinate.\n"
"\n"
"---------\n"
"\n"
"[1mfn Quad.getDims[0m\n"
"\n"
"[3mfn (q: ^Quad) getDims*(): Vf2 {\n"
"[0m\n"
"Returns the dimensions of the quad\'s bounding box\n"
"\n"
"---------\n"
"\n"
"[1mfn getGlobal[0m\n"
"\n"
"[3mfn getGlobal*(): ^struct{} {\n"
"[0m\n"
"returns a pointer to the th_global. Set this as your extensions thg.\n"
"\n"
"---------\n"
"\n"
"[1mfn getFuncs[0m\n"
"\n"
"[3mfn getFuncs*(): ^struct{} {\n"
"[0m\n"
"returns pointer to tophat functions. Pass this to th_ext_set.\n"
"\n"
"---------\n"
"\n"
"[1mvar enableErrrors[0m\n"
"\n"
"[3mvar enableErrors*: bool = true\n"
"[0m\n"
"If true, errors will result in a call to exit(255), otherwise printf is used.\n"
"\n"
"---------\n"
"\n"
"[1mColor constants[0m\n"
"\n"
"[3mconst (\n"
"\tblack* = 0xff\n"
"\twhite* = 0xffffffff\n"
"\tred* = 0xff0000ff\n"
"\tgreen* = 0x00ff00ff\n"
"\tblue* = 0x0000ffff\n"
"\tyellow* = 0xffff00ff\n"
"\tmagenta* = 0xff00ffff\n"
"\tcyan* = 0x00ffffff\n"
")\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1menum Platform[0m\n"
"\n"
"[3mtype Platform* = enum {\n"
"\tunknown\n"
"\tlinux\n"
"\twindows\n"
"\tmacOs\n"
"\tweb\n"
"}\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1mMisc variables[0m\n"
"\n"
"[3mvar (\n"
"\t// time in ms from start of the game\n"
"\ttime*: uint\n"
"\t// length of the last frame in ms\n"
"\tdelta*: int\n"
"\t// platform tophat is running on\n"
"\tplatform*: Platform\n"
")\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"",
"[1m[0m\n"
"\n"
"[3m[0m\n"
"A module for importless communication between modules. A signal is a set of\n"
"callbacks.  You can use signals directly in your own structs if you want\n"
"them to be instance specific, of you can use global signals which are\n"
"adressed by a string name.\n"
"\n"
"---------\n"
"\n"
"[1mtype Callback[0m\n"
"\n"
"[3mtype Callback* = fn(args: []any)\n"
"[0m\n"
"`args` is a list of arguments passed to the `emit` method.\n"
"\n"
"---------\n"
"\n"
"[1mtype Id[0m\n"
"\n"
"[3mtype Id* = uint\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1mtype Signal[0m\n"
"\n"
"[3mtype Signal* = map[Id]Callback\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1mfn mk[0m\n"
"\n"
"[3mfn mk*(): Signal {\n"
"[0m\n"
"`Signal` constructor\n"
"\n"
"---------\n"
"\n"
"[1mfn Signal.register[0m\n"
"\n"
"[3mfn (this: ^Signal) register*(callback: Callback): Id {\n"
"[0m\n"
"Registers a callback to a signal and returns the callback id.\n"
"\n"
"---------\n"
"\n"
"[1mfn Signal.remove[0m\n"
"\n"
"[3mfn (this: ^Signal) remove*(id: Id) {\n"
"[0m\n"
"Removes a callback by id.\n"
"\n"
"---------\n"
"\n"
"[1mfn Signal.emit[0m\n"
"\n"
"[3mfn (this: ^Signal) emit*(args: ..any) {\n"
"[0m\n"
"Emits a signal.\n"
"\n"
"---------\n"
"\n"
"[1mfn Signal.clear[0m\n"
"\n"
"[3mfn (this: ^Signal) clear*() {\n"
"[0m\n"
"Removes all signal handlers.\n"
"\n"
"---------\n"
"\n"
"[1mfn register[0m\n"
"\n"
"[3mfn register*(name: str, callback: Callback): Id {\n"
"[0m\n"
"Registers a callback to a global signal.  There is no need to explicitly\n"
"create global signals.  Returns id of the added callback\n"
"\n"
"---------\n"
"\n"
"[1mfn remove[0m\n"
"\n"
"[3mfn remove*(name: str, id: Id) {\n"
"[0m\n"
"Removes a callback from a global signal by id.\n"
"\n"
"---------\n"
"\n"
"[1mfn remove[0m\n"
"\n"
"[3mfn clear*(name: str) {\n"
"[0m\n"
"Removes all signal handlers from a global signal.\n"
"\n"
"---------\n"
"\n"
"[1mfn emit[0m\n"
"\n"
"[3mfn emit*(name: str, args: ..any): std::Err {\n"
"[0m\n"
"Calls all callbacks associated with the passed global signal name.\n"
"\n"
"---------\n"
"\n"
"",
"[1mstruct Atlas[0m\n"
"\n"
"[3mtype Atlas* = struct {\n"
"\ti: image::Image // source image\n"
"\tcs: th::Vf2 // size of a cell in pixels\n"
"\tdm: th::Vf2 // amount of cells in image\n"
"}\n"
"[0m\n"
"Atlas is an image containing tiles in a square grid.\n"
"\n"
"---------\n"
"\n"
"[1mfn mk[0m\n"
"\n"
"[3mfn mk*(i: image::Image, dm: th::Vf2): Atlas {\n"
"[0m\n"
"i: source image\n"
"dm: amount of cells\n"
"\n"
"---------\n"
"\n"
"[1mfn mk2[0m\n"
"\n"
"[3mfn mk2*(i: image::Image, cs: th::Vf2): Atlas {\n"
"[0m\n"
"i: source image\n"
"cs: size of a cell in pixels\n"
"\n"
"---------\n"
"\n"
"[1mfn Atlas.coords[0m\n"
"\n"
"[3mfn (a: ^Atlas) coords*(n: int): th::Vf2 {\n"
"[0m\n"
"returns the coordinates of the nth tile\n"
"\n"
"---------\n"
"\n"
"[1mfn Atlas.rect[0m\n"
"\n"
"[3mfn (a: ^Atlas) rect*(n: int): rect::Rect {\n"
"[0m\n"
"returns the rectangle of the nth tile\n"
"\n"
"---------\n"
"\n"
"[1mfn Atlas.index[0m\n"
"\n"
"[3mfn (a: ^Atlas) index*(at: th::Vf2): int {\n"
"[0m\n"
"returns the index of the tile at the given coordinates\n"
"\n"
"---------\n"
"\n"
"[1mfn Atlas.has[0m\n"
"\n"
"[3mfn (a: ^Atlas) has*(at: th::Vf2): bool {\n"
"[0m\n"
"returns true if the tile at the given coordinates exists\n"
"\n"
"---------\n"
"\n"
"[1mfn Atlas.hasIndex[0m\n"
"\n"
"[3mfn (a: ^Atlas) hasIndex*(n: int): bool {\n"
"[0m\n"
"returns true if the tile at the given index exists\n"
"\n"
"---------\n"
"\n"
"[1mfn Atlas.cropSource[0m\n"
"\n"
"[3mfn (a: ^Atlas) cropSource*(at: th::Vf2) {\n"
"[0m\n"
"Crops the sourse image to only show a wanted tile\n"
"\n"
"---------\n"
"\n"
"[1menum PackStrategy[0m\n"
"\n"
"[3mtype PackStrategy = enum {\n"
"\tsquare\n"
"\trow\n"
"\tcolumn\n"
"}\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1mfn pack[0m\n"
"\n"
"[3mfn pack*(images: []image::Image, strategy: PackStrategy): (Atlas, std::Err) {\n"
"[0m\n"
"Packs an array of images into an atlas\n"
"\n"
"---------\n"
"\n"
"[1mfn Atlas.draw[0m\n"
"\n"
"[3mfn (a: ^Atlas) draw*(at: th::Vf2, t: th::Transform) {\n"
"[0m\n"
"Draws the tile at `at`\n"
"\n"
"---------\n"
"\n"
"",
"[1mopaque Shader[0m\n"
"\n"
"[3mtype Shader* = struct {\n"
"[0m\n"
"Shader allows you to define your own vertex and fragment GLSL shaders. This\n"
"is a low-level feature, so it\'s very easy to mess up.\n"
"\n"
"In tophat, instead of a main function, shaders provide th_vertex and\n"
"th_fragment. The signature of th_vertex is:\n"
"\n"
"```\n"
"vec2 th_vertex(vec2 vert);\n"
"```\n"
"\n"
"where vert is the position of the vertex taken from the vertex buffer.\n"
"The output is the vertex shader output.\n"
"\n"
"As for fragment shaders, there are two types of them. One for canvas\n"
"and one for images. In canvas shaders, the fragment function is very simple:\n"
"\n"
"```\n"
"vec4 th_fragment(vec4 color);\n"
"```\n"
"\n"
"Image fragment function looks like this:\n"
"\n"
"```\n"
"vec4 th_fragment(sampler2D tex, vec2 coord);\n"
"```\n"
"\n"
"where tex is the texture and coord are the texture coordinates. Be aware to\n"
"swap the output of the `texture2D` function. Example:\n"
"\n"
"```\n"
"texture2D(tex, coord).abgr\n"
"```\n"
"\n"
"---------\n"
"\n"
"[1mDefault shader constants[0m\n"
"\n"
"[3mconst (\n"
"\tdefaultImageShader* = Shader{1}\n"
"\tdefaultCanvasShader* = Shader{2}\n"
")\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1mstruct Uniform[0m\n"
"\n"
"[3mtype Uniform* = struct {\n"
"\ts: Shader\n"
"\tl: uint\n"
"}\n"
"[0m\n"
"Represents a GLSL uniform.\n"
"\n"
"---------\n"
"\n"
"[1mfn mkCanvas[0m\n"
"\n"
"[3mfn mkCanvas*(vertex, fragment: str): Shader {\n"
"[0m\n"
"Compiles a canvas shader from source. If there is a compilation error, it\n"
"will print something to the console.\n"
"\n"
"---------\n"
"\n"
"[1mfn mkImage[0m\n"
"\n"
"[3mfn mkImage*(vertex, fragment: str): Shader {\n"
"[0m\n"
"Compiles an image shader from source. If there is a compilation error, it\n"
"will print something to the console.\n"
"\n"
"---------\n"
"\n"
"[1mfn Shader.pickForCanvas[0m\n"
"\n"
"[3mfn (s: ^Shader) pickForCanvas*() {\n"
"[0m\n"
"Picks the shader to be used for canvas drawing. Flushes the canvas batch.\n"
"\n"
"---------\n"
"\n"
"[1mfn Shader.pickForImage[0m\n"
"\n"
"[3mfn (s: ^Shader) pickForImage*() {\n"
"[0m\n"
"Picks the shader to be used for image drawing. Flushes the image batch.\n"
"\n"
"---------\n"
"\n"
"[1mfn Shader.getUniformLocation[0m\n"
"\n"
"[3mfn (s: ^Shader) getUniformLocation*(name: str): Uniform {\n"
"[0m\n"
"Retunrs a uniform by name.\n"
"\n"
"---------\n"
"\n"
"[1mfn Uniform.setInt[0m\n"
"\n"
"[3mfn (u: ^Uniform) setInt*(value: int) {\n"
"[0m\n"
"Sets a uniform to an int value. Flushes both batches.\n"
"\n"
"---------\n"
"\n"
"[1mfn Uniform.setVf2[0m\n"
"\n"
"[3mfn (u: ^Uniform) setVf2*(value: th::Vf2) {\n"
"[0m\n"
"Sets a uniform to a vf2. Flushes both batches.\n"
"\n"
"---------\n"
"\n"
"",
"[1m[0m\n"
"\n"
"[3m[0m\n"
"Color operations. Operate on RGBA uint32 values.\n"
"\n"
"---------\n"
"\n"
"[1mfn hsv[0m\n"
"\n"
"[3mfn hsv*(h, s, v: th::fu, a: th::fu = 1.0): uint32 {\n"
"[0m\n"
"Converts HSV values into RGBA uint32 color.\n"
"NOTE: Hue is between 0 and 1\n"
"\n"
"---------\n"
"\n"
"[1mfn alpha[0m\n"
"\n"
"[3mfn alpha*(c: uint32, to: th::fu): uint32 {\n"
"[0m\n"
"Sets alpha of the color c to a value in to.\n"
"\n"
"---------\n"
"\n"
"[1mfn rgb[0m\n"
"\n"
"[3mfn rgb*(r, g, b: th::fu, a: th::fu = 1.0): uint32 {\n"
"[0m\n"
"Constructs RGBA uint32 from RGBA of reals.\n"
"\n"
"---------\n"
"\n"
"",
"[1m[0m\n"
"\n"
"[3m[0m\n"
"Builtin collision functions. The ic argument stores the collision position.\n"
"\n"
"---------\n"
"\n"
"[1mfn lineToLine[0m\n"
"\n"
"[3mfn lineToLine*(b1, e1, b2, e2: th::Vf2, ic: ^th::Vf2): bool {\n"
"[0m\n"
"Checks for a collision between 2 lines specified by their end points.\n"
"\n"
"---------\n"
"\n"
"[1mfn vf2ToQuad[0m\n"
"\n"
"[3mfn vf2ToQuad*(p: th::Vf2, q: th::Quad, ic: ^th::Vf2): bool {\n"
"[0m\n"
"Checks for a collision between a vf2 and a quad.\n"
"\n"
"---------\n"
"\n"
"[1mfn lineToQuad[0m\n"
"\n"
"[3mfn lineToQuad*(b, e: th::Vf2, q: th::Quad, ic1, ic2: ^th::Vf2): bool {\n"
"[0m\n"
"Check for a collision between a line and quad edges.\n"
"\n"
"---------\n"
"\n"
"[1mfn quadToQuad[0m\n"
"\n"
"[3mfn quadToQuad*(q1, q2: th::Quad, ic: ^th::Vf2): bool {\n"
"[0m\n"
"Check for a collision between two quads.\n"
"\n"
"---------\n"
"\n"
"[1mfn vf2ToRect[0m\n"
"\n"
"[3mfn vf2ToRect*(p: th::Vf2, r: rect::Rect): bool {\n"
"[0m\n"
"Check for a collision between a vf2 and a rectangle.\n"
"\n"
"---------\n"
"\n"
"[1mfn rectToRect[0m\n"
"\n"
"[3mfn rectToRect*(r1, r2: rect::Rect): bool {\n"
"[0m\n"
"Check for a collision between two rects\n"
"\n"
"---------\n"
"\n"
"[1mfn rectIntersect[0m\n"
"\n"
"[3mfn rectIntersect*(r1, r2: rect::Rect): rect::Rect {\n"
"[0m\n"
"Get the intersection of two rects.\n"
"\n"
"---------\n"
"\n"
"",
"[1mPlaceholder images[0m\n"
"\n"
"[3mvar (\n"
"\t// an image useful for testing\n"
"\ttest*: image::Image\n"
"\t// the image used for the app icon\n"
"\ticon*: image::Image\n"
"\t// Windows 95 style button, to be used with ninepatch (image.um)\n"
"\tbutton*: image::Image\n"
")\n"
"[0m\n"
"These images are included with tophat and don\'t have to be loaded.\n"
"\n"
"---------\n"
"\n"
"",
"[1mstruct Mesh[0m\n"
"\n"
"[3mtype Mesh* = struct {\n"
"\t// The mesh data.\n"
"\td: []bool\n"
"\t// The dimensions and position of the mesh, r.w == w * s\n"
"\tr: rect::Rect\n"
"\t// Width of the mesh.  Used to adress the mesh data.\n"
"\tw: th::uu\n"
"\t// Scale of one cell (cell is a square)\n"
"\ts: th::fu\n"
"}\n"
"[0m\n"
"Mesh is a 2d array of bool cells.  If a cell is true, the cell can be used\n"
"in a path.  The mesh is located in a world using the `r` field.  A cell can\n"
"have an arbitrary size as specified by `s`.\n"
"\n"
"The mesh can be edited using the `addQuad` method, but it should be trivial\n"
"to add your own, similar methods.\n"
"\n"
"Please use the `mk` constructor to construct a `Mesh`, unless you really\n"
"know what you\'re doing.\n"
"\n"
"---------\n"
"\n"
"[1mfn mk[0m\n"
"\n"
"[3mfn mk*(r: rect::Rect, s: th::fu): Mesh {\n"
"[0m\n"
"Creates a new nav mesh.\n"
"`r`\n"
": the rectangle of the mask\n"
"\'s\'\n"
": the scale of the mask\n"
"\n"
"---------\n"
"\n"
"[1mfn Mesh.addQuad[0m\n"
"\n"
"[3mfn (m: ^Mesh) addQuad*(q: th::Quad) {\n"
"[0m\n"
"Sets mask\'s fields overlapping `q` to `false`.\n"
"\n"
"---------\n"
"\n"
"[1mfn Mesh.nav[0m\n"
"\n"
"[3mfn (m: ^Mesh) nav*(p1, p2: th::Vf2): []th::Vf2 {\n"
"[0m\n"
"Navigates between `p1` and `p2`. Returns the path as an array of `th.Vf2`s.\n"
"If it doesn\'t find any path, or one of the points is outside of the mask,\n"
"returns an empty array.\n"
"\n"
"---------\n"
"\n"
"[1mfn Mesh.draw[0m\n"
"\n"
"[3mfn (m: ^Mesh) draw*(alpha: real32 = 1.0) {\n"
"[0m\n"
"Draws the mesh for debugging purposes.\n"
"\n"
"---------\n"
"\n"
"",
"[1m[0m\n"
"\n"
"[3m[0m\n"
"`ui.um` offers an immediate GUI library suitable both for simple game menus\n"
"and more complex applications.\n"
"\n"
"---------\n"
"\n"
"[1mstruct BoxStyle[0m\n"
"\n"
"[3mtype BoxStyle* = struct {\n"
"\timg: image::Image\n"
"\touter, inner: rect::Rect\n"
"\tscale: th::fu\n"
"\tcolor: uint32\n"
"}\n"
"[0m\n"
"`BoxStyle` describes how a box within the GUI is styled.  In this case box\n"
"can be anything, ranging from a button to a container.  By default the box\n"
"is drawn using the `image.Image.drawNinepatch` method.  However if the image\n"
"is invalid, a rectangle with color `color` is drawn.\n"
"\n"
"---------\n"
"\n"
"[1minterface Font[0m\n"
"\n"
"[3mtype Font* = interface {\n"
"\tdraw(text: str, pos: th::Vf2, color: uint32, scale: th::fu = 1.0)\n"
"\tmeasure(test: str): th::Vf2\n"
"}\n"
"[0m\n"
"This interface is used by all elements that draw text. A `font.Font`\n"
"implements this interface.\n"
"\n"
"---------\n"
"\n"
"[1mstruct PixelFont[0m\n"
"\n"
"[3mtype PixelFont* = struct { }\n"
"[0m\n"
"This struct implement the `Font` interface using the `canvas.um` pixel font.\n"
"\n"
"---------\n"
"\n"
"[1mstruct Style[0m\n"
"\n"
"[3mtype Style* = struct {\n"
"\t// current font\n"
"\tft: Font\n"
"\t// font scale\n"
"\tftScale: th::fu\n"
"\t// text color\n"
"\tftColor: uint32\n"
"\n"
"\t// Positive box - i. e. unpressed button\n"
"\tposBox: BoxStyle\n"
"\t// Negative box - i. e. pressed button, text box\n"
"\tnegBox: BoxStyle\n"
"\t// Used to draw containers\n"
"\tcontainerBox: BoxStyle\n"
"}\n"
"[0m\n"
"`Style` is used as a global state for styling the GUI.\n"
"\n"
"---------\n"
"\n"
"[1minterface Container[0m\n"
"\n"
"[3mtype Container* = interface {\n"
"\t// This adds a rectangle to the container, and returns the rectangle\n"
"\t// which was actually added (the container can modify the rectangle).\n"
"\t// See individual containers for further documentation.\n"
"\tpushRect(r: rect::Rect): rect::Rect\n"
"\tgetDims(): rect::Rect\n"
"}\n"
"[0m\n"
"Containers are used to layout elements or other containers.\n"
"\n"
"---------\n"
"\n"
"[1mstruct Gui[0m\n"
"\n"
"[3mtype Gui* = struct {\n"
"\t// user context passed to layout functions\n"
"\tctx: any\n"
"\n"
"\t// the index of the current selection. TODO implement properly\n"
"\tselection: int\n"
"\t// true, if the layout is being evaluated, not drawn\n"
"\tisEval: bool\n"
"\t// contains more unexported fields\n"
"[0m\n"
"This is the main struct of any UI.  Styles and containers are in a stack.\n"
"\n"
"---------\n"
"\n"
"[1mfn mk[0m\n"
"\n"
"[3mfn mk*(r: rect::Rect, s: Style): Gui\n"
"[0m\n"
"Creates a new gui spanning `r`, with style `s`.\n"
"\n"
"---------\n"
"\n"
"[1mtype LayoutFn[0m\n"
"\n"
"[3mtype LayoutFn* = fn(gui: ^Gui)\n"
"[0m\n"
"The layout function calls different element or container methods to create\n"
"the user interface itself.  It is called in the `eval` and `draw`.\n"
"\n"
"---------\n"
"\n"
"[1mfn BoxStyle.draw[0m\n"
"\n"
"[3mfn (this: ^BoxStyle) draw*(r: rect::Rect) {\n"
"[0m\n"
"Draws a rectangle using a BoxStyle\n"
"\n"
"---------\n"
"\n"
"[1mfn Gui.pushStyle[0m\n"
"\n"
"[3mfn (this: ^Gui) pushStyle*(s: Style) {\n"
"[0m\n"
"Pushes a style onto the style stack.\n"
"\n"
"---------\n"
"\n"
"[1mfn Gui.popStyle[0m\n"
"\n"
"[3mfn (this: ^Gui) popStyle*() {\n"
"[0m\n"
"Pops a style from the style stack.\n"
"\n"
"---------\n"
"\n"
"[1mfn Gui.getStyle[0m\n"
"\n"
"[3mfn (this: ^Gui) getStyle*(): ^Style {\n"
"[0m\n"
"Returns a pointer to the style atop the style stack.\n"
"\n"
"---------\n"
"\n"
"[1mfn Gui.getContainer[0m\n"
"\n"
"[3mfn (this: ^Gui) getContainer*(): Container {\n"
"[0m\n"
"Returns the container atop the container stack.\n"
"\n"
"---------\n"
"\n"
"[1mfn Gui.pushRect[0m\n"
"\n"
"[3mfn (this: ^Gui) pushRect*(r: rect::Rect): rect::Rect {\n"
"[0m\n"
"Shortcut to `this.getContainer().pushRect(r)`\n"
"\n"
"---------\n"
"\n"
"[1mfn Gui.getDims[0m\n"
"\n"
"[3mfn (this: ^Gui) getDims*(): rect::Rect {\n"
"[0m\n"
"Shortcut to `this.getContainer().getDims(r)`\n"
"\n"
"---------\n"
"\n"
"[1mfn Gui.dupStyle[0m\n"
"\n"
"[3mfn (this: ^Gui) dupStyle*() {\n"
"[0m\n"
"Duplicates the current style.\n"
"\n"
"---------\n"
"\n"
"[1mfn Gui.pushContainer[0m\n"
"\n"
"[3mfn (this: ^Gui) pushContainer*(c: Container) {\n"
"[0m\n"
"Pushes a container onto the container stack.\n"
"\n"
"---------\n"
"\n"
"[1mfn Gui.popContainer[0m\n"
"\n"
"[3mfn (this: ^Gui) popContainer*() {\n"
"[0m\n"
"Pops a container from the container stack.\n"
"\n"
"---------\n"
"\n"
"[1mfn Gui.eval[0m\n"
"\n"
"[3mfn (this: ^Gui) eval*(layout: LayoutFn) {\n"
"[0m\n"
"Runs the evaluation phase on `layout`.\n"
"\n"
"---------\n"
"\n"
"[1mfn Gui.draw[0m\n"
"\n"
"[3mfn (this: ^Gui) draw*(layout: LayoutFn) {\n"
"[0m\n"
"Runs the draw phase on `layout`.\n"
"\n"
"---------\n"
"\n"
"[1menum BoxGrow[0m\n"
"\n"
"[3mtype BoxGrow* = enum {\n"
"\tdimension\n"
"\tsubdiv\n"
"\tspan\n"
"\tpxSpan\n"
"}\n"
"[0m\n"
"The different types of \"growing\" the box can do.\n"
"\n"
"---------\n"
"\n"
"[1menum BoxDirection[0m\n"
"\n"
"[3mtype BoxDir* = enum {\n"
"\tdown\n"
"\tright\n"
"\tup\n"
"\tleft\n"
"}\n"
"[0m\n"
"Direction in which the box will grow.\n"
"\n"
"---------\n"
"\n"
"[1mstruct BoxConfig[0m\n"
"\n"
"[3mtype BoxConfig* = struct {\n"
"\t// dimension to grow by if `BoxGrowDimension` is used\n"
"\tdimension: th::fu\n"
"\t// number of subdivisions if `BoxGrowSubdivisions` is used\n"
"\tsubdivisions: uint\n"
"\t// the grow type\n"
"\tgrowType: BoxGrow\n"
"\t// the grow direction\n"
"\tdir: BoxDir\n"
"\t// Specifies the values used with BoxGrowSpan nad BoxGrowPxSpan.\n"
"\t// If BoxGrowSpan is used, 1 equals the size of the box divided by the sum\n"
"\t// of all spans.\n"
"\t// If BoxGrowPxSpan is used, 1 equals one pixel.\n"
"\tspan: []th::fu\n"
"\t// rect passed to the current container\n"
"\trect: rect::Rect\n"
"\t// padding inserted after each element\n"
"\tpadding: th::fu\n"
"}\n"
"[0m\n"
"Configuration of the `Box` container.\n"
"\n"
"---------\n"
"\n"
"[1mstruct Box[0m\n"
"\n"
"[3mtype Box* = struct {\n"
"\tgrow: th::fu\n"
"\tspanCursor: int\n"
"\tdm: rect::Rect\n"
"\tcfg: BoxConfig\n"
"}\n"
"[0m\n"
"`Box` is the main layout.  It puts the elements next to each other,\n"
"according to the config.\n"
"\n"
"If the dimensions of the rect passed to `pushRect` are non zero, they will\n"
"be kept. Position is always forced.\n"
"\n"
"---------\n"
"\n"
"[1mfn Gui.box[0m\n"
"\n"
"[3mfn (gui: ^Gui) box*(cfg: BoxConfig = {\n"
"\tdimension: 30,\n"
"\tgrowType: BoxGrow.dimension,\n"
"\tdir: BoxDir.down }) {\n"
"[0m\n"
"Adds the `Box` container to the gui.\n"
"\n"
"---------\n"
"\n"
"[1mstruct StackConfig[0m\n"
"\n"
"[3mtype StackConfig* = struct {\n"
"\trect: rect::Rect\n"
"\tpadding: th::fu\n"
"}\n"
"[0m\n"
"Configuration for the `Stack` container.\n"
"\n"
"---------\n"
"\n"
"[1mstruct Stack[0m\n"
"\n"
"[3mtype Stack* = struct {\n"
"\tdm: rect::Rect\n"
"\tcfg: StackConfig\n"
"}\n"
"[0m\n"
"The stack container puts elements on top of each other.\n"
"If a property of the rect passed to `pushRect` is zero, it will be changed\n"
"to an equivalent property of the containers\' dimensions (minus the padding),\n"
"else it will stay the same.  This means stack can be used either to put\n"
"multiple elements/containers on top of each other, or for absolutely\n"
"positioned elements.\n"
"\n"
"---------\n"
"\n"
"[1mfn Gui.stack[0m\n"
"\n"
"[3mfn (gui: ^Gui) stack*(cfg: StackConfig = {}) {\n"
"[0m\n"
"Adds the `Stack` container to the gui.\n"
"\n"
"---------\n"
"\n"
"[1mstruct ScrollAreaConfig[0m\n"
"\n"
"[3mtype ScrollAreaConfig* = struct {\n"
"\trect: rect::Rect\n"
"\t// scroll speed. Default is 1\n"
"\tspeed: real32\n"
"\t// if true, scrolling will be horizontal\n"
"\thorizontal: bool\n"
"}\n"
"[0m\n"
"Configuration for the scroll area.\n"
"\n"
"---------\n"
"\n"
"[1mstruct ScrollArea[0m\n"
"\n"
"[3mtype ScrollArea* = struct {\n"
"\tdm: rect::Rect\n"
"\tcfg: ScrollAreaConfig\n"
"\tscroll: ^real32\n"
"\tmaxScroll: real32\n"
"}\n"
"[0m\n"
"Scroll area is a container which allows the user to scroll. It acts as a\n"
"stack container, but all the elements are shifted by the scroll.\n"
"\n"
"---------\n"
"\n"
"[1mfn Gui.scrollArea[0m\n"
"\n"
"[3mfn (gui: ^Gui) scrollArea*(scroll: ^real32, maxScroll: real32, cfg: ScrollAreaConfig = {}) {\n"
"[0m\n"
"Pushes a scroll area. `scroll` is both input and output value. Both `scroll`\n"
"and `maxScroll` are in pixels.\n"
"\n"
"---------\n"
"\n"
"[1mstruct ButtonConfig[0m\n"
"\n"
"[3mtype ButtonConfig* = struct {\n"
"\trect: rect::Rect\n"
"}\n"
"[0m\n"
"Configuration for the button.\n"
"\n"
"---------\n"
"\n"
"[1mfn Gui.button[0m\n"
"\n"
"[3mfn (gui: ^Gui) button*(cfg: ButtonConfig = {}): bool {\n"
"[0m\n"
"Adds a button to the gui.  The button acts like a `Stack` container, but it\n"
"is drawn using the pos/nexBox styles and handles clicks. If the button is\n"
"pressed and the gui is in the eval phase, the return value will be true.\n"
"\n"
"---------\n"
"\n"
"[1mstruct LabelConfig[0m\n"
"\n"
"[3mtype LabelConfig* = struct {\n"
"\t// centers the label along the X axis, enables `stretchX`\n"
"\tcenterX: bool\n"
"\t// centers the label along the Y axis, enables `stretchY`\n"
"\tcenterY: bool\n"
"\t// if false, the rect passed to `pushRect` will have the width of\n"
"\t// the text, else it will be 0\n"
"\tstretchX: bool\n"
"\t// if false, the rect passed to `pushRect` will have the height of\n"
"\t// the text, else it will be 0\n"
"\tstretchY: bool\n"
"\t// forces the rectangle the label will use\n"
"\trect: rect::Rect\n"
"}\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1mfn Gui.label[0m\n"
"\n"
"[3mfn (gui: ^Gui) label*(text: str, cfg: LabelConfig = {\n"
"[0m\n"
"Draws a label using the current font style.\n"
"\n"
"---------\n"
"\n"
"[1mfn Gui.qbutton[0m\n"
"\n"
"[3mfn (gui: ^Gui) qbutton*(text: str, cfg: ButtonConfig = {}): bool {\n"
"[0m\n"
"Adds a button with a label to gui.\n"
"\n"
"---------\n"
"\n"
"[1mstruct TextBoxConfig[0m\n"
"\n"
"[3mtype TextBoxConfig* = struct {\n"
"\t// force the rect of the text box\n"
"\trect: rect::Rect\n"
"}\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1mstruct TextBox[0m\n"
"\n"
"[3mtype TextBox* = struct {\n"
"\t// index of the cursor\n"
"\tcursor: int\n"
"\t// contains other unexported rules...\n"
"[0m\n"
"\n"
"---------\n"
"\n"
"[1mfn TextBox.clear[0m\n"
"\n"
"[3mfn (this: ^TextBox) clear*() {\n"
"[0m\n"
"Clears the textbox\n"
"\n"
"---------\n"
"\n"
"[1mfn TextBox.getBuf()[0m\n"
"\n"
"[3mfn (this: ^TextBox) getBuf*(): str {\n"
"[0m\n"
"Get the content of the textbox.\n"
"\n"
"---------\n"
"\n"
"[1mfn TextBox.setBuf()[0m\n"
"\n"
"[3mfn (this: ^TextBox) setBuf*(s: str) {\n"
"[0m\n"
"Get the content of the textbox.\n"
"\n"
"---------\n"
"\n"
"[1mfn Gui.textBox[0m\n"
"\n"
"[3mfn (gui: ^Gui) textBox*(tb: ^TextBox, cfg: TextBoxConfig = {}) {\n"
"[0m\n"
"Adds a single line textbox to the gui.\n"
"TODO:\n"
"* right-to-left unicode is not supported.\n"
"* no selection\n"
"* multiline\n"
"* copy paste (now implemented but in a limited way due to the lack of selection)\n"
"* common input shortcuts\n"
"- ctrl+delete / ctrl+backspace (delete word)\n"
"\n"
"---------\n"
"\n"
"[1mstruct ImageConfig[0m\n"
"\n"
"[3mtype ImageConfig* = struct {\n"
"\tstretchX, stretchY: bool\n"
"\tcenterX, centerY: bool\n"
"\tcolor: uint32\n"
"\tscale: th::Vf2\n"
"\trect: rect::Rect\n"
"}\n"
"[0m\n"
"Configuration for the images element. Behaves similarly to labels.\n"
"\n"
"---------\n"
"\n"
"[1mfn Gui.image[0m\n"
"\n"
"[3mfn (gui: ^Gui) image*(i: image::Image, cfg: ImageConfig = {\n"
"\tstretchX: true,\n"
"\tstretchY: true,\n"
"\tcolor: th::white,\n"
"\tscale: { 1, 1 } }) {\n"
"[0m\n"
"Draws an image.\n"
"\n"
"---------\n"
"\n"
"[1mfn getDefaultStyle[0m\n"
"\n"
"[3mfn getDefaultStyle*(): Style {\n"
"[0m\n"
"Returns the default tophat ui style.\n"
"\n"
"---------\n"
"\n"
"[1mfn mk[0m\n"
"\n"
"[3mfn mk*(r: rect::Rect, s: Style): Gui {\n"
"[0m\n"
"Creates a GUI instance.\n"
"\n"
"---------\n"
"\n"
"",
};
static uint32_t th_em_placeholder_data_2[] = {0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff0a35d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0, 0xff3f0cf8, 0xff3f0cf8, 0xffef0cf8, 0xffef0cf8, 0xffd00a20, 0xffd00a20, 0xffd0d00a, 0xffd0d00a, 0xff3dd00a, 0xff3dd00a, 0xff0ac0d0, 0xff0ac0d0};
static uint32_t th_em_placeholder_data_3[] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xff262626, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0xffd5aeae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
static uint32_t th_em_placeholder_data_4[] = {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xffffffff, 0xffc0c0c0, 0xffc0c0c0, 0xff808080, 0xff000000, 0xff000000, 0xff808080, 0xff808080, 0xff808080, 0xffffffff, 0xffffffff, 0xffc0c0c0, 0xffc0c0c0, 0xff808080, 0xff000000, 0xff000000, 0xff808080, 0xffc0c0c0, 0xffc0c0c0, 0xffffffff, 0xffffffff, 0xff808080, 0xff808080, 0xff808080, 0xff000000, 0xff000000, 0xff808080, 0xffc0c0c0, 0xffc0c0c0, 0xffffffff, 0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff};
th_em_placeholder th_em_placeholders[] = {
{ th_em_placeholder_data_2, { .w = 12, .h = 12 } },
{ th_em_placeholder_data_3, { .w = 69, .h = 69 } },
{ th_em_placeholder_data_4, { .w = 10, .h = 5 } },
};
