import (
	"canvas.um"
	"rect.um"
	"th.um"
	"window.um"
	"image.um"
	"gameplay.um"
	"presets.um"
	"piece.um"
	"field.um"
	"falling_piece.um"
	"crazytext.um"
)

reference_frame := rect::Rect{ 0, 0, field::FieldWidth*16+6*16, field::FieldHeight*16 }
const EffectClearRow = 0

type Effect = struct {
	kind: int
	life: real
	int_data: int
}

var (
	brick: image::Image
	fallingPiecePos: th::Vf2
	offset_x : real = 0
	offset_y : real = 0
	effects: []Effect
)

fn getNextPiecePos(): th::Vf2 {
	return th::Vf2{
		trunc(offset_x)-16*5,
		trunc(offset_y)+32+trunc(sin(th::time/1000.0)*5)}
}

fn getStashPos(): th::Vf2 {
	return th::Vf2{16*11+trunc(offset_x), 1*16+trunc(offset_y)}
}

fn init*() {
	offset_x = (window::wp.x-reference_frame.w)/2
	offset_y = (window::wp.y-reference_frame.h)/2
	fallingPiecePos = getNextPiecePos()
	effects = make([]Effect, 0)
	brick = image::load("brick.png").item0
	brick.setfilter(.linear)
}

const clearEffect* = fn(row: int) {
	effects = append(effects, Effect { EffectClearRow, 1, row })
}

fn drawEffect(effect: Effect) {
	opacity := trunc(effect.life * effect.life * 255);
	switch effect.kind {
	case EffectClearRow:
		canvas::drawRect(0xFFFFFF00|opacity,
			rect::Rect{
				offset_x, offset_y + effect.int_data*16,
				field::FieldWidth*16, 16})
	}
}

fn processFx() {
		newEffects := []Effect{}

	for i, effect in effects {
		drawEffect(effect)
		effect.life -= th::delta/1000.0
		if effect.life > 0 {
			newEffects = append(newEffects, effect)
		}
	}

		effects = newEffects
}

const cellOffs = 10
const cellW = 128+cellOffs

fn drawCell(c: uint32, r: rect::Rect, falling: bool) {
	r = r.shrink({-r.w*0.04, -r.h*0.04})

	if !falling {
		brick.blit({cellOffs+cellW*0, 0, cellW, cellW}, r, c)
		brick.blit({cellOffs+cellW*1, 0, cellW, cellW}, r, 0xFFEECCAA)
	}
		brick.blit({cellOffs+cellW*2, 0, cellW, cellW}, r, c|0x777777FF)
}

fn cellRec(x, y: int) {
	r := rect::Rect { offset_x + x * 16, offset_y + y * 16, 16, 16 }
	if field::playfield[x][y] != 0 {
		drawCell(field::colors[field::playfield[x][y]], r, false)
	} else {
		r = r.shrink({-r.w*0.05, -r.h*0.05})
		brick.blit({cellOffs+cellW*0, 0, cellW, cellW}, r, 0xFFFFFF08)
		brick.blit({cellOffs+cellW*2, 0, cellW, cellW}, r, 0xFFFFFF11)
	}
}

fn drawPiece(it: piece::Piece, x, y: int, mask: int, falling: bool) {
	x_origin := x
	for _, chr in it.data {
		if chr == '#' {
			drawCell(field::colors[it.color] & mask, rect::Rect { x, y, 16, 16 }, falling)
		}
		x += 16
		if chr == '\n' {
			y += 16
			x = x_origin
		}
	}
}

fn drawStash() {
	canvas::drawText("STASH:", th::Vf2{trunc(offset_x)-16*5+256, trunc(offset_y)}, th::white, 2)
	if gameplay::stash < 0 {
		return 
	}

	pos := getStashPos()
	drawPiece(presets::pieceValue(gameplay::stash, 0), round(pos.x), round(pos.y), 0xFFFFFFFF, false)
}

fn drawFallingPiece() {

	targetPos := th::Vf2{trunc(falling_piece::x)*16+trunc(offset_x), trunc(falling_piece::y)*16+trunc(offset_y)}
	mul := th::delta/30.0
	if mul > 1.0 {
		mul = 1.0
	}
	fallingPiecePos = targetPos
	val := falling_piece::pieceValue(falling_piece::rotation)

	// draw ghost
	prev := falling_piece::y
	timerPrev := falling_piece::placeTimer
	falling_piece::push()
	drawPiece(val, trunc(falling_piece::x)*16+trunc(offset_x), trunc(falling_piece::y)*16+trunc(offset_y), 0x555555FF, true)
	falling_piece::y = prev
	falling_piece::placeTimer = timerPrev

	drawPiece(val, round(fallingPiecePos.x), round(fallingPiecePos.y), 0xFFFFFFFF, false)
}

fn drawNextPiece() {
	canvas::drawText("NEXT:", th::Vf2{trunc(offset_x)-16*5, trunc(offset_y)}, th::white, 2)
	val := presets::pieceValue(gameplay::bag.getNextPiece(), 0)
	pos := getNextPiecePos()
	drawPiece(val, trunc(pos.x), trunc(pos.y), 0xFFFFFFFF, false)
}

fn draw*() {
	offset_x = (window::wp.x-reference_frame.w)/2
	offset_y = (window::wp.y-reference_frame.h)/2

	drawStash()
	field_rect := rect::Rect { offset_x-1, offset_y-1, field::FieldWidth * 16+1, field::FieldHeight * 16+1 }
	
	if gameplay::hasPlaced {
		fallingPiecePos = getNextPiecePos()
	}
	if gameplay::hasUsedStash {
		fallingPiecePos = getStashPos()
	}

	for i := 0; i < field::FieldWidth; i += 1 {
		for j := 0; j < field::FieldHeight; j += 1 {
			cellRec(i, j)
		}
	}
	drawNextPiece()
	drawFallingPiece()
	processFx()

	crazytext::draw(16.0*11.0-1.0+offset_x, 6.0*16.0-1.0+offset_y)
}
