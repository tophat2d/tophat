
import (
	"audio.um"
	"canvas.um"
	"image.um"
	"placeholders.um"
	"rect.um"
	"signal.um"
	"std.um"
	"th.um"
)

var (
	start, clockOffset: real
	fpsLimit: int = 60
)

//~~Cursor types
const (
	cursorDefault* = 0		// Default system cursor
	cursorArrow*			// Normal cursor; Arrow cursor
	cursorIBeam*			// 'I' text cursor; I-Beam
	cursorCrosshair*		// '+' cursor; Select region cursor
	cursorFinger*			// Index finger pointing cursor; Click cursor
	cursorSizeEW*			// '<->' cursor; Resize width cursor; Resize horizontally cursor; East-West resize cursor
	cursorSizeNS*			// Resize height cursor; Resize vertically cursor; North-South resize cursor
	cursorSizeNWSE*			// Resize width and height from the right side cursor; Northwest-Southeast resize cursor
	cursorSizeSWNE*			// Resize width and height from the left side cursor; Southwest-Northeast resize cursor
	cursorSizeAll*			// Resize all cursor; Move cursor
	cursorNo*			// '(/)' cursor; Disabled cursor; Disallowed cursor
	cursorCount_*
)
//~~

//~~Window dimensions
var (
	w*, h*: int32
)
//~~

//~~Viewport size
var wp*: th.Vf2
//~~

//~~signal OnFrame
var onFrame*: signal.Signal
//~~
//~~signal OnDestroy
var onDestroy*: signal.Signal
//~~

fn umth_window_setup(title: str, w, h: int)
fn umth_window_get_dimensions(w, h: ^int32)

fn umth_window_set_viewport(dm: th.Vf2)
//~~fn setViewport
// Sets the dimensions of the viewport. The dimensions are saved in the `wp`
// variable.
//
// `dm`
// : dimension of the viewport
fn setViewport*(dm: th.Vf2) {
//~~
	wp = dm
	umth_window_set_viewport(dm)
}

fn setIcon*(img: image.Image)

fn umth_window_is_dpi_enabled(): bool

//~~fn isDpiEnabled
// Returns true if DPI awareness was enabled
fn isDpiEnabled*(): bool {
//~~
	return umth_window_is_dpi_enabled()
}

fn umth_window_get_dpi_scale(): th.fu

//~~fn getDpiScaleFactor
// Returns the DPI scaling of the current window.
// If `dpiAware` was not enabled in window setup, this function will return 1.0 (default scaling).
fn getDpiScaleFactor*(): th.fu {
//~~
	return umth_window_get_dpi_scale()
}

// 0 = other/unknown
// 2 = linux
// 3 = windows
// 4 = macos (unsupported currently)
// 5 = emscripten
fn umth_window_get_platform_id(): int

//~~fn setup
// Sets up the engine and opens a window.
fn setup*(title: str = "tophat game", width: int = 400, height: int32 = 400) {
//~~
	w, h = width, height
	umth_window_setup(title, width, height)

	th.platform = umth_window_get_platform_id()

	audio.__setup()
	placeholders.__setup()

	setIcon(placeholders.icon)

	clockOffset = std.clock() * 1000
	start = std.clock() * 1000

	setViewport(th.Vf2{width, height})
}

//~~fn cycle
// Cycle needs to be called every cycle for the window to work. If the window
// was closed, it returns false.
fn cycle(delta: real) {
//~~
	umth_window_set_viewport(wp)

	th.delta = trunc(delta*1000.0)
	if th.delta == 0 {
		th.delta = 1
	}

	start = std.clock()*1000
	th.time = round(start - clockOffset)

	umth_window_get_dimensions(&w, &h)

	audio.__cycle()
	canvas.drawRect(th.white, rect.mk(0, 0, wp.x, wp.y))
}

fn setViewportOffset*(s: th.Vf2)
fn getViewportOffset*(): th.Vf2

fn drawClear() {
	of := getViewportOffset()
	setViewportOffset({})
	canvas.drawRect(th.black, rect.mk(-4 * wp.x, 0, 4 * wp.x, wp.y))
	canvas.drawRect(th.black, rect.mk(0, -4 * wp.y, wp.x, 4 * wp.y))
	canvas.drawRect(th.black, rect.mk(wp.x, 0, 4 * wp.x, wp.y))
	canvas.drawRect(th.black, rect.mk(0, wp.y, wp.x, 4 * wp.y))
	setViewportOffset(of)
}

fn umth_frame_callback*(delta: real) {
	cycle(delta)
	onFrame.emit(null)
	drawClear()
}

fn umth_destroy_callback*() {
  onDestroy.emit(null)
}

fn umth_window_set_fullscreen(fullscreen: bool)
fn umth_window_get_fullscreen(): bool

//~~fn setFullscreen
// Makes window go full screen
fn setFullscreen*(fullscreen: bool) {
//~~
	umth_window_set_fullscreen(fullscreen)
}

//~~fn isFullscreen
// Returns true if window is fullscreen
fn isFullscreen*(): bool {
//~~
	return umth_window_get_fullscreen()
}

//~~fn getDims
// Returns dimensions of the window in screen pixels.
fn getDims*(): th.Vf2 {
//~~
	return th.Vf2{w, h}
}

fn umth_window_set_target_fps(fps: int)

//~~fn setTargetFps
// Sets the fps limit.
//
// `fps`
// : amount of fps the limit should be set to
//
fn setTargetFps*(fps: int) {
//~~
	fpsLimit = fps
	umth_window_set_target_fps(fps)
}

fn umth_window_set_dims(dm: th.Vf2)
//~~fn setDims
// Sets the dimensions of the window.
//
// `dm`
// : the target dimensions in screen pixels
fn setDims*(dm: th.Vf2) {
//~~
	umth_window_set_dims(dm)
}

fn umth_window_set_icon(img: image.Image)
//~~fn setIcon
// Sets the window icon.
fn setIcon*(img: image.Image) {
//~~
	if !img.validate() {
		th.__error("invalid image")
	}	

	umth_window_set_icon(img)
}

fn umth_window_show_cursor(show: bool)
//~~fn showCursor
// Show or hide the cursor, linux only.
fn showCursor*(show: bool) {
//~~
	umth_window_show_cursor(show)
}

fn umth_window_freeze_cursor(freeze: bool)
//~~fn freezeCursor
// Freezes the cursor in place. `input.getMouseDelta` will still report mouse
// movements.  The cursor will be automatically hidden.
fn freezeCursor*(freeze: bool) {
//~~
	showCursor(freeze)
	umth_window_freeze_cursor(freeze)
}

fn umth_window_set_cursor(cursor: int)
//~~fn setCursor
// Allows you to set the displaying cursor. Refer to the cursors section for available cursors.
fn setCursor*(cursor: int) {
//~~
	umth_window_set_cursor(cursor);
}


fn umth_window_quit()
//~~fn quit
// Exits the application. Use this instead of umka's default `exit`.
fn quit*() {
//~~
	umth_window_quit()
}

fn umth_window_set_clipboard(s: str)
//~~fn setClipboard
// Puts a string to the system clipboard.
fn setClipboard*(s: str) {
//~~
	umth_window_set_clipboard(s)
}

fn umth_window_get_clipboard(s: ^char)
//~~fn getClipboard
// Gets a string from the system clipboard.
fn getClipboard*(): str {
//~~
	buf := make([]char, 8192)
	umth_window_get_clipboard(&buf[0])
	return str(buf)
}

fn umth_window_set_viewport_shift(s: th.Vf2)
//~~fn setViewportOffset
// Sets the offset of the viewport.
fn setViewportOffset*(s: th.Vf2) {
//~~
	umth_window_set_viewport_shift(s)
}

fn umth_window_get_viewport_shift(s: ^th.Vf2)
//~~fn getViewportOffset
// Gets the offset of the viewport (as set by `setViewportShift`)
fn getViewportOffset*(): th.Vf2 {
	o := th.Vf2{}

	umth_window_get_viewport_shift(&o)
	return o
}
